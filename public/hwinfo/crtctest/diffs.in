<html><head><title>Differences of CRTC models</title>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../style.css">
</head><body>
@MENU@
<DIV ID="content">
<h1>Differences between the different CRTC types</h1>
<p>
I have gathered together the differences between CRTC models from various 
sources. The docs to 
</p><ul>
<li>Rockwell 6545-1
<li>Motorola 6845, 6845-1, 68A45, 68A45-1, 68B45, 68B45-1
<li>Hitachi 46505
<li>Commodore 6545-1
</ul><p>
have been taken from <a href="http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/index.html">http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/index.html</a>. 
The Motorola chips are actually only two different chips, 
namely 6845 and 6845-1, with different speed ratings ("", "A", "B").
I will therefore only use the names without speed ratings.
I checked the Motorola 6845 with my private docs, and added the 
</p><ul>
<li>Rockwell 6545, 6545E
</ul><p>
docs from my <code>Rockwell International 1987 Controller Products Data 
Book</code>. Again the only difference I found between those two chips 
was the maximum allowed clock frequency (2.5&nbsp;MHz vs. 3.7&nbsp;MHz for 
the R6545E).
</p><hr><p>
I will not go into details that are common to all chips.
If you have further questions please refer to the CRTC documentation
on http://www.zimmers.net/anonftp/pub/cbm/documents/chipdata/index.html
</p>
<h2>Pinout</h2>
<p>
Although the pin naming is different, the pinout itself is the same for 
all chips, and all pins have the same meaning.
</p>
<h2>Status Register</h2>
<p>
The Status register is read when the register select (RS) pin is low
(when writing to this address, the index in the CRTC register file is written).
</p><pre>
Commodore 6545-1, Rockwell 6545-1

	Bits 0-4: not used

	Bit 5: 0= scan currently not in vertical blanking portion
	       1= scan is currently in vertical blanking portion [1]

	Bit 6: LPEN register full
	       0= goes to 0 whenever R16 or R17 are read
	       1= goes 1 when an LPEN strobe occurs

	Bit 7: not used

Rockwell 6545

	Bits 0-6: see Rockwell 6545-1

	Bit 7: Update Ready
	       0= register 16 or 17 has been read by the CPU
  	       1= an update strobe has been occurred.

Motorola 6845, 6845-1, Hitachi 46505

	The status register is not mentioned at all...

[1] The Rockwell 6545 docs say that this bit "switches state at end of
    last displayed rasterline" and "goes to a 0 five character clock times 
    before vertical retrace ends to ensure that critical timings for
    refresh RAM is met."
</pre>
<h2>Register File</h2>
<p>
The following registers are basically the same for all chips (see notes):
</p>
<pre>
R0	Horizontal Total (-1)
R1 	Horizontal Display
R2	Horizontal Sync position [1]

R4	Vertical total character lines (-1) (7 bit)
R5	Vertical total adjust rasterlines (5 bit)
R6	Vertical displayed character lines (7 bit)
R7	Vertical Sync position (7 bit) [1]

R9	Number of rasterlines per characterline (-1) [2]
R10	Cursor start rasterline + cursor mode control (5+2 bit)
R11	Cursor end rasterline (5 bit)
R12	Display start address high (6 bit) [3]
R13	Display start address low (8 bit) [3]
R14	Cursor address high (6 bit)
R15	Cursor address low (8 bit)
R16	Lightpen address high (6 bit)
R17	Lightpen address low (8 bit)

[1] Motorola states that "(Set data) = (Designated Data) - 1",
    as it is known for R0, R4, and R9
[2] Commodore does not mention the "-1"
[3] It is possible to read R12 and R13 on Motorola CRTCs only.
    All others can only read R14-R17.
</pre><p>
Reading unused bits where possible reads a "0", which is, however,
only explicitly stated in the Commodore docs.
</p>
<h2>The major differences in the register file</h2>
<h3>R3, sync widths</h3>
<pre>
Motorola 6845, Hitachi 46505:

	Bits 0-3: horizontal sync width in character times. Value=0 -&gt; 16
	Bits 4-7: unused

Commodore 6545-1, Rockwell 6545 and 6545-1, Motorola 6845-1:

	Bits 0-3: horizontal sync width in character times. Value=0 -&gt; 16
	Bits 4-7: vertical sync width in rasterlines. Value=0 -&gt; 16
</pre>
<h3>R8, Mode Control</h3>
<pre>
Commodore 6545-1 and Rockwell 6545-1:

	Bit 0,1: Interlace control 
	   value of bits (1/0):
		x0: non-interlace [Rockwell says "Bit 0 must program to 0"]
		x1: invalid "do not use" [Rockwell says "not used"]

	Bit 2:  0 = straight binary addressing
		1 = row/column addressing (see below)

	Bit 3:  "Must Program to '0'"

	Bit 4:  Display Enable Skew 
		0 = no delay
		1 = delay Display Enable for one character clock cycle

	Bit 5:  Cursor Enable Skew
		0 = no delay
		1 = delay Cursor Enable for one character clock cycle

	Bit 6,7: not used

Rockwell 6545:

	Bits 0,1: Interlace control, see Motorola 6545
 
	Bit 2: Addressing Mode, see Rockwell 6545-1

	Bit 3: Refresh RAM access
	       0= shared memory access
	       1= transparent memory access

	Bit 4/5: display enable and cursor skew. See Rockwell 6545-1

	Bit 6: Update Strobe (Transparent mode):
	       0= Pin 34 functions as memory address (RA4)
	       1= Pin 34 functions as update strobe

	Bit 7: Update/Read mode (Transparent mode):
	       0= Update occurs during horizontal and vertical blanking
	       1= Update interleaves during Phi2 portion of cycle

Motorola 6845 and Hitachi 46505

	Bit 0,1: Interlace control (see below)
	   value of bits (1/0):
		x0: non-interlace, normal mode
		01: interlace mode
		11: interlace and video mode
		
	Bit 2-7: not used

Motorola 6845-1

	Bit 0-3: see Motorola 6845

	Bit 4,5: Display Enable Skew
	   value of bits (5/4):
		00: no delay
		01: delay Display Enable for one character clock cycle
		10: delay Display Enable for two character clock cycles
		11: not available

	Bit 6,7: Display Enable Skew
	   value of bits (7/6):
		00: no delay
		01: delay Cursor Enable for one character clock cycle
		10: delay Cursor Enable for two character clock cycles
		11: not available
</pre>
<p>
What can be learned already from this diagram? The Motorola 6845
(or the Hitachi 46505, but unlikely) was first and defined a basic
set of features. Rockwell and Commodore then used the same derivation
from the original design, while Motorola developed slightly different
features. However, looking at the "must program to 0" entries, it
seems Rockwell was not quick enough to implement the interlace modes
and thus released an early version as 6545-1, before getting the
full 6545 done, with some additional features.
</p><p>
Now lets explain certain features that are mentioned in the table.
</p>
<h2>Straight binary vs. row/column addressing (Commodore and Rockwell only)</h2>
<p>
The memory address counter can be set to two different modes. In the
"straight binary" mode the counter is a normal 14 bit binary counter.
The characters displayed on screen are taken from a consecutive
area when MA0-MA13 are used as memory address.
</p><p>
In row/column mode MA0-MA7 dubs as the column counter CC0-CC7
and presents the value of the character counter for each rasterline.
MA8-MA13 dub as row counter CR0-CR5 and present the number of the
current characterline.
</p>
<h2>Interlace and Video modes (All but Commodore and R6545-1)</h2>
<p>
In the interlace mode the vertical sync signal is alternately delayed
or not delayed for half of a rasterline time.
This results in that every even-numbered frame is slightly shifted
up or down as compared to the odd-numbered frame.
This allows to fill up the double number of rasterlines, where
two rasterlines always have the same content. 
The total frame time would then be double the "normal" CRTC frame time,
as the second CRTC frame is used to fill the rasterlines "in between".
So two identical CRTC frames, slightly shifted, make up a full
frame on the display.
</p><p>
This is different in the "interlace &amp; video" mode. Here the rasterline
counter for each char increases by two. Thus in the first of the two
interlaced CRTC frames the even rasterlines are drawn and in the
second the odd ones. This effectively doubles the bandwith
of the monitor: One character still is e.g. 8 rasterlines high, but the 
even 4 rasterlines are drawn in the first frame, and the odd 4 rasterlines
in the second. <br>
There are certain restrictions on the register values for interlace
and interlace &amp; video mode, please refer to the Motorola documentation.
The most important is that the vertical display register (R6) must
hold half the number of displayed characterlines.
</p>
<h2>Shared and Transparent Addressing (Rockwell 6545 only)</h2>
<p>
This mode is set with R8 bit 3. Writing a 0 sets the shared adressing mode.
In this mode the CRTC assumes that the CPU has an independent means of
accessing the video memory - sharing the memory.
A very common method is to switch the memory addresses from CRTC 
during Phi2/E low to CPU during Phi2/E high.
</p><p>
More interesting is the transparent mode that is set with R8, bit&nbsp;3=1.
In this case the CPU cannot directly access the video RAM. The CRTC
has to generate the address for the CPU. This is done via the 
write-only registers
</p><pre>
R18	Update Register high (6 bit)
R19	Update Register low (8 bit)
</pre><p>
When R8 bit&nbsp;7=1 then the CRTC puts the display memory address on 
MA0-13 during Phi2/E low, and the update address from R18/R19 during
Phi2/E high, mimicking interleaved CPU access [I would assume this
to be quite difficult if CCLK is <em>not</em> connected
to Phi2/E]. In this mode it can be assumed that the CPU hardware
knows when to access the memory.
When R8 bit&nbsp;7=0, then the CRTC waits for the horizontal and
vertical retrace times to put the update address from R18/R19 on the
address lines MA0-13. With R8 bit&nbsp;6=1 pin 34 can be programmed
to give a high pulse when the update address is valid. 
External latches might be necessary to store the data between 
initiating the access and receiving it. 
</p><p>
The CRTC docs do not say anything about the read/write control, so this
has to be set up with external hardware.
</p><p>
After each update access the address in the update register is
incremented by 1.
How does the CRTC know when an update has to be done? 
Status register bit&nbsp;7 gives the answer. Reading or writing 
the - otherwise nonexisting - register R31 tells the CRTC
to perform an update.
</p><p>
Interestingly the Commodore 8563 VDC chip used in the C128 computer
seems to be a direct descendant of the CRTC. The first 20 registers
(with the exception of the mode register, R8) are the same as the
Rockwell 6545 registers. Specifically the VDC <em>only</em> allows
the transparent addressing. Therefore even R31 is kept - here the data to be
transferred to/from the video memory must be written to/read from.
Because this access is horribly slow, the VDC can also do copy operations
in the video RAM by itself.
</p>
</DIV>
</body></html>
