<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Andr&#xE9;  Fachat" />

<meta name="description" content="6502 16bit 32bit expansion" />
<meta name="keywords" content="6502 16bit 32bit expansion" />
<link rev="made" href="mailto:afachat@gmx.de" />
<link rel="stylesheet" title="Default" type="text/css" href="../style-min.css" /><link rel="stylesheet" type="text/css" href="optable.css" /><link rel="alternate stylesheet" title="Advanced" type="text/css" href="../advanced.css" />
<title>The 65k Project - Implementation Specs</title></head>
<body><div id="mainbox"><a name="top" id="top"></a><div id="leftcol"><div id="menu" class="top"><div class="tophead">navigate</div><div id="filter"><form action="#"><table id="filterbox"><tr><td><input alt="menu filter" size="8" name="filter" value="filter" type="text" /></td><td><div id="cancel" class="i_cancel"> </div></td></tr></table><table id="expcol"><tr><td><div id="expand" class="i_expand"> </div></td><td><div id="collapse" class="i_collapse"> </div></td></tr></table></form></div>
<div id="mtree">
<a id="m_homepage" href="../index.html">Homepage</a>
<ul class="menu0" >
<li class="separator">Commodore</li>
<li class="dir" id="m_petindex"><div class="i_dir">&nbsp;</div><a href="../petindex/index.html">CBM PETindex</a>
</li>
<li class="dir" id="m_cbmhw"><div class="i_dir">&nbsp;</div><a href="../cbmhw/index.html">CBM hardware and mods</a>
</li>
<li class="separator">Hardware</li>
<li class="dir" id="m_65k"><div class="i_dir">&nbsp;</div><a href="../65k/index.html">The 65k Project</a>
<ul class="menu1" >
<li><div class="i_file">&nbsp;</div><a href="features.html">Features</a></li>
<li class="separator">Specification</li>
<li><div class="i_file">&nbsp;</div><a href="specsprog.html" class="mcurrent">Programming Model</a></li>
<li><div class="i_file">&nbsp;</div><a href="designnotes.html">Design Notes</a></li>
<li class="separator">Tools</li>
<li><div class="i_file">&nbsp;</div><a href="crossass.html">Cross-Assembler</a></li>
<li><div class="i_file">&nbsp;</div><a href="nativetools.html">Native Tools</a></li>
<li class="separator">Implementation</li>
<li><div class="i_file">&nbsp;</div><a href="arch.html">General architecture</a></li>
<li class="dir" id="m_65k_af65002"><div class="i_dir">&nbsp;</div><a href="af65002/index.html">af65002 </a>
</li>
<li><div class="i_file">&nbsp;</div><a href="tests.html">Test setup</a></li>
</ul>
</li>
<li class="dir" id="m_csa"><div class="i_dir">&nbsp;</div><a href="../csa/index.html">CS/A65 Caspaer and Gecko computer</a>
</li>
<li class="dir" id="m_adv65"><div class="i_dir">&nbsp;</div><a href="../adv65/index.html">Advanced 6502</a>
</li>
<li class="dir" id="m_hwinfo"><div class="i_dir">&nbsp;</div><a href="../hwinfo/index.html">ICs and Standards Info</a>
</li>
<li class="dir" id="m_mischw"><div class="i_dir">&nbsp;</div><a href="../mischw/index.html">Other hardware (e.g. tools)</a>
</li>
<li class="separator">Software</li>
<li><div class="i_file">&nbsp;</div><a href="../osa/index.html">GeckOS operating system</a>
</li>
<li><div class="i_file">&nbsp;</div><a href="../lib6502/index.html">Lib6502 standard</a>
</li>
<li><div class="i_file">&nbsp;</div><a href="../o65/index.html">O65 file format</a>
</li>
<li><div class="i_file">&nbsp;</div><a href="../misc/index.html">Misc software</a>
</li>
<li class="separator">Knowledge Bits</li>
<li class="dir" id="m_icapos"><div class="i_dir">&nbsp;</div><a href="../icapos/index.html">Computer/OS Architecture</a>
</li>
<li class="dir" id="m_icaphw"><div class="i_dir">&nbsp;</div><a href="../icaphw/index.html">6502 Hardware Bits</a>
</li>
<li class="separator">Misc</li>
<li><div class="i_file">&nbsp;</div><a href="../contact.html">Contact</a></li>
<li><div class="i_file">&nbsp;</div><a href="../sneak.html">Sneak preview</a></li>
<li><div class="i_file">&nbsp;</div><a href="../design.html">Web design</a></li>
</ul>

</div>
		</div><div class="top" id="browser"><div class="tophead">browser</div><div>
			Site has been tested with a number of browsers and systems. Javascript required for advanced menu, but degrades gracefully without Javascript. IE6 not supported anymore!
			</div></div></div><div id="rightcol"><div class="top" id="google"><div class="tophead">search</div><div><form method="get" action="http://www.google.com/search" target="_blank"><input alt="search parameters" type="text" name="q" size="10" maxlength="255" value="" /><input class="advbutton" type="submit" value="Search my site" /><br />(Google, in new window)
	                        <input type="hidden" name="sitesearch" value="www.6502.org/users/andre" /></form></div></div><div class="top" id="share"><div class="tophead">share</div><div><div id="socialshareprivacy"></div></div></div><div class="top" id="twitter"><div class="tophead">follow</div><div>
		            Follow my 8-bit tweets on<br /><a class="extlink" target="_blank" href="https://twitter.com/#!/search/realtime/afachat%20%238bit">Twitter</a><br /> (In new window)
		</div></div><div class="top" id="forum"><div class="tophead">discuss</div><div><p>Discuss my site on <a class="extlink" target="_blank" href="http://forum.6502.org/viewtopic.php?t=956">this 6502.org forum thread</a></p><p>Discuss this page's content on <a class="extlink" target="_blank" href="http://forum.6502.org/viewtopic.php?p=12180"> this 6502.org forum thread</a></p><p>(Forum registration required to post)</p></div></div><div class="top" id="hot"><div class="tophead">Hot!</div><div>
<p>Dive into the retro feeling and build yourself a <a href="../cbmhw/ryofat40/index.html">Commodore PET replica</a></p>
<p>Need more speed? Speed up your 6502 computer with this <a href="../adv65/pet816/index.html">10&nbsp;MHz 6502 CPU replacement board</a></p>
<p>Interested in electronics design? Look at the <a href="../icaphw/design.html">design lesson</a> I got from Bil Herd, the hardware designer of the C128</p>
<p>Want 64bit? - pimp the 6502 with the <a href="../65k/index.html">65k processor design!</a></p>

		</div></div></div><div id="midcol"><div class="top" id="ie6warn">
You are using an old MS Internet Explorer as browser. This version is not supported anymore. Please use a 
more modern browser, like Internet Explorer 8 or later, 
<a target="_blank" class="extlink" href="http://www.firefox.com">Firefox</a>,
<a target="_blank" class="extlink" href="http://www.google.com/chrome">Google Chrome</a>, or
<a target="_blank" class="extlink" href="http://www.opera.com">Opera</a>.
</div><div class="top" id="content"><div id="minmax"></div>
<div id="breadcrumbs">
<a href="../index.html">Homepage</a>
&gt;&gt;  <a href="index.html">The 65k Project
</a>&gt;&gt;  Programming Model</div>
<h1>The 65k Project - Implementation Specs</h1><p class="copyright">(C)
2010-2012 André  Fachat</p> 
<div class="overview"><p>
	This page describes the implementation specs for my 65k line of processors.
	For a reasoning why a feature is implemented as it is, see the <a href="features.html">Features discussion</a>
	page.
	</p><p>
	The 65k will be available in different "sizes" - mainly in terms of register widths.
	For example options for 16 bit, 32 bit, and even 64 bit registers are defined.
	The first section will thus describe the options available.
	</p><p>
	The second section will then give an overview on the opcodes and their addressing modes
	The third section describes reset, interrupt and other special behaviour.
	</p><p>
	Note that these tables are currently preliminary. Final goal is to generate this part of the
	documentation from the same source that generates the VHDL control tables.
	</p><p>
	NOTE: NEEDS UPDATE ACCORDING TO AF65002 IMPLEMENTATION! (esp. interrupt handling)
  </p></div><div id="toc" class="h2"><div class="h2h"><div class="h2t"> </div><h2>Table of content</h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><ul><li><a href="#preface">Preface</a></li><li style="list-style-type:none;"><ul><li><a href="#lic">License</a></li><li><a href="#disc">Disclaimer</a></li><li><a href="#cont">Contributors</a></li><li><a href="#chg">Changes</a></li></ul></li><li><a href="#opts">65k Options</a></li><li style="list-style-type:none;"><ul><li><a href="#optswidth">Register Widths Options</a></li><li><a href="#optssuper">Hypervisor Mode Option</a></li><li><a href="#optsmmu">MMU Option</a></li></ul></li><li><a href="#regs">Register Set</a></li><li style="list-style-type:none;"><ul><li><a href="#regcore">Core register</a></li><li><a href="#regmem">Memory Management Register</a></li></ul></li><li><a href="#overview">65k Opcode and Addressing Mode Overview</a></li><li style="list-style-type:none;"><ul><li><a href="#ovops">Opcodes Overview</a></li><li><a href="#ovadmd">Addressing Modes Overview</a></li><li><a href="#ovpref">Prefix Overview</a></li><li><a href="#ovquick">Quick Opcodes</a></li><li><a href="#ovfp">EXT opcodes</a></li><li><a href="#ovsys">SYS opcodes</a></li><li><a href="#ovfp">FP opcodes</a></li><li><a href="#ovmmu">Blitter opcodes</a></li></ul></li><li><a href="#sys">System Environment</a></li><li style="list-style-type:none;"><ul><li><a href="#reset">Reset</a></li><li><a href="#int">Interrupts</a></li><li><a href="#trap">Trap handling</a></li><li><a href="#intproc">Interrupt and Trap Procedure</a></li><li><a href="#intret">Interrupt and Trap Return</a></li><li><a href="#jpu">Jump to User Mode</a></li><li><a href="#irqfw">Forward an interrupt to user mode</a></li></ul></li><li><a href="#mem">Memory Management</a></li><li style="list-style-type:none;"><ul><li><a href="#match">Match code</a></li><li><a href="#cont">Container</a></li><li><a href="#mmu">Paged Memory Management Unit (MMU)</a></li></ul></li><li><a href="#smp">Multiprocessing</a></li><li><a href="#compat">6502 Software Compatibility Notes</a></li><li style="list-style-type:none;"><ul><li><a href="#compatstack">Stack Frame</a></li><li><a href="#compatpointer">Interrupt Pointer</a></li><li><a href="#compattiming">Timing</a></li></ul></li></ul></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="preface" id="preface">Preface</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><h3><a name="lic" id="lic">License</a></h3><p>
        This content is licensed under the Creative Commons Attribution Share-Alike license, CC-BY-SA version 3.0.
    </p><p>
        Note this "content" includes this web page, but does not include the 6502.org header
        and the left and right web page columns.  Click on the "Maximize" link to see
        the contents covered by this license.
    </p><ul><li><a href="http://creativecommons.org/licenses/by-sa/3.0/legalcode" target="_blank" class="extlink">CC-BY-SA legal code</a> </li><li><a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_blank" class="extlink">CC-BY-SA license deed (short form)</a> </li></ul><h3><a name="disc" id="disc">Disclaimer</a></h3><p>
        The content comes with no warranty at all!
        There is no guarantee and no promise that this specification is correct, consistent, will actually work,
        or will ever be implemented at all.
    </p><p>
	To my understanding the techniques described here have been used by various processors for decades already.
	Still there is no guarantee that a processor according to this spec would not be covered by some patents.
    </p><p>
        Subject to change without notice!
    </p><h3><a name="cont" id="cont">Contributors</a></h3><ul>
        <li>André  Fachat - initial author: <a href="http://www.6502.org/users/andre">8bit Homepage</a></li>
    </ul><h3><a name="chg" id="chg">Changes</a></h3><p>This section describes the changes to the document:</p>
      <table border="1">
        <tr><th>Date</th><th>Author</th><th>Changes</th></tr>
        <tr><td>2010-10-23</td><td>André  Fachat</td><td>First working draft</td></tr>
        <tr><td>2010-11-04</td><td>André  Fachat</td><td>Defined the interrupt status/mask/effective 
		mask register; Constrained the interrupt/trap/abort vectors to two-byte vectors;
		integrated the various extra registers into the configuration register file (for less
		opcodes necessary); add WAI, STP and FIL/FILU</td></tr>
        <tr><td>2010-12-22</td><td>André  Fachat</td><td>Added the "NF" prefix bit</td></tr>
        <tr><td>2010-12-28</td><td>André  Fachat</td><td>Moved some LSB $f opcodes to the extension page
		to add STX abs,Y and STY abs,X</td></tr>
	<tr><td>2011-01-02</td><td>André  Fachat</td><td>Moved some opcodes to achieve a more regular mapping of opcodes and addressing modes</td></tr>
	<tr><td>2011-05-01</td><td>André  Fachat</td><td><ul>
		<li>WAI becomes privileged</li>
		<li>Moved no-operand opcodes in EXT page from column $f to $8, to be more aligned with standard opcode page</li>
		<li>Added the INV opcode for the 2s-complement</li>
		<li>Moved SWP to the EXT page, reordered the prefix codes</li>
		<li>reordered the EXT column $8 and $a codes</li>
		<li>Removed the INE/INB/DEE/DEB quick opcodes, added SLX/SRX/SLY/SRY quick opcodes instead</li>
		<li>Reordered opcode column $f, so all non-prefix opcodes have addressing mode abs,X</li>
		<li>removed NOP zp/abs, moved STX abs,Y to previous NOP abs location</li>
		<li>Cleaned up duplicate opcodes for AM=1, clarified table description</li>
		<li>Changed the BSR prefix usage definition to one similar to JSR, which removes the need
			for one of the BSR duplicate opcodes</li>
		<li>Added the EE "early extension" prefix flag</li>
		<li>reordered some EXT codes</li>
		<li>Added the stack peek opcodes PKA, PKX, PKY</li>
		<li>Added the EXT and CUT opcodes</li>
		<li>Added the Accumulator addressing modes for ADE/ADB/ADS/SBE/SBB/SBS</li>
		</ul></td></tr>
	<tr><td>2011-12-23</td><td>André  Fachat</td><td><ul>
		<li>Remove the EE prefix bit, and replace it with a second bit for the ZE extension - to allow
			to extend with ones and with the sign. Semantics of ZE changed as well, thus renamed to LE,
			load extend. Old ZE functionality is covered by EXT opcode</li>
		<li>Fix the description of the SLX/SLY/SRX/SRY opcodes</li>
		<li>Deprecated CLX/CLY opcodes, changed CLA to full width only</li>
		<li>Added "BIT A" variant</li>
		<li>Removed CUT, as it is the same as EXT</li>
		<li>Some small changes here and there, esp. clarifications around the interrupt handling</li>
		<li>Added the Software Compatibility section</li>
		</ul></td></tr>
	<tr><td>2011-12-31</td><td>André  Fachat</td><td><ul>
		<li>Replace manually maintained tables (std/EXT pages and addressing modes) with 
			ones generated from an XML file which will be the basis for an assembler
			and some VHDL code generation.</li>
		<li>Added LEA/PEA with relwide addressing modes</li>
		<li>Cleared up some flag settings</li>
		<li>Add the RDR/RDL/ASR opcodes, moved a number of opcodes around in the EXT page,
			also rearranged the QUICK page to accomodate for the new opcodes.</li>
		</ul></td></tr>
      </table>
    </div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="opts" id="opts">65k Options</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><p>This section describes the different versions of the 65k processor
	</p>
     <h3><a name="optswidth" id="optswidth">Register Widths Options</a></h3><p>
	The 65k will be available in different "register widths". Register here means all address registers
	(stack pointer (SP), program counter (PC), base offset register (BR)), but also all data registers (AC, XR, YR).
	This does not include the status register for example. For details see the register model below.
	Address and Data registers will always have the same width to accomodate for address offsets computed
	in data registers.
	</p><p>
	The following options are available:</p>
	<ul>
	<li>16 bit - a small extension to the original 6502 programming model, the PC stays 16 bit as 
		it already is in the 6502.</li>
	<li>32 bit - all data and address registers extended to 32 bit</li>
	<li>64 bit - all data and address registers extended to 64 bit</li>
	</ul><p>
	The original register width for most of the registers is a byte. To use the registers with more than
	8 bit a prefix opcode to the existing 8 bit opcodes is used. 2 bit of the prefix opcode are
	reserved for operation width, which allows to address registers as 8, 16, 32 or 64 bit.
	</p><p>
	The different register or operand widths are noted by a prefix. These prefixes are defined and used
	here:</p>
	<table border="1">
	<tr><th>Prefix</th><th>Width</th><th>Comment</th></tr>
	<tr><td> </td><td>8</td><td>no prefix gives the 6502 8 bit behaviour</td></tr>
	<tr><td>W</td><td>16</td><td>Word</td></tr>
	<tr><td>L</td><td>32</td><td>Long</td></tr>
	<tr><td>Q</td><td>64</td><td>Quadword (alternatively LL, but Q should be used)</td></tr>
	</table>
    	<h3><a name="optssuper" id="optssuper">Hypervisor Mode Option</a></h3><p>
	The 65k will optionally provide a hypervisor mode. When using a hypervisor mode, critical instructions -
	those that modify system state - become privileged and are thus only allowed in hypervisor mode.
	Hypervisor mode allows to separate user space programs from kernel space, and protects the kernel from
	unwanted modifications from user space.
    	</p><h3><a name="optsmmu" id="optsmmu">MMU Option</a></h3><p>
	The 65k will optionally provide an MMU to translate virtual addresses (opcode effective addresses) into
	physical addresses. When the MMU is not included, virtual addresses are directly taken as physical addresses.
    	</p></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="regs" id="regs">Register Set</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><p>
	The register set is very similar to the 6502, with only a few extensions...
	As there are different options for register widths, "W" describes the width
	option, i.e. either 16, 32 or 64 bit. 
	</p><p>In addition to the core registers there are registers for the memory management.
    </p>
    <h3><a name="regcore" id="regcore">Core register</a></h3>
    <table border="1">
	<tr><th>Register</th><th>Name</th><th>6502</th><th>65k</th><th>Comment</th></tr>
	<tr><td>A</td><td>Accumulator</td><td>8 bit</td><td>W bit</td><td>Operations can be done in 8, 16, 32, 64 bit (up to W)</td></tr>
	<tr><td>X</td><td>X register</td><td>8 bit</td><td>W bit</td><td>Operations can be done in 8, 16, 32, 64 bit (up to W)</td></tr>
	<tr><td>Y</td><td>Y register</td><td>8 bit</td><td>W bit</td><td>Operations can be done in 8, 16, 32, 64 bit (up to W)</td></tr>
	<tr><td>E</td><td>Effective Address Register</td><td>-</td><td>W bit</td><td>Stores effective address for opcodes</td></tr>
	<tr><td>B</td><td>Base Offset Register</td><td>-</td><td>W bit</td><td>Address offset for addressing modes</td></tr>
	<tr><td>S(U)</td><td>User mode Stack pointer</td><td>-</td><td>W bit</td><td></td></tr>
	<tr><td>S(H)</td><td>Hypervisor mode Stack pointer</td><td>8 bit, with high byte set to 1</td><td>W bit</td><td></td></tr>
	<tr><td>SR</td><td>Status Register</td><td>8 bit, with bit 5 set to 1</td><td>8/8 bit</td><td>low 8 bit are the same as 6502, bit5 set to 0, high 8 bit see below</td></tr>
	<tr><th colspan="5">Interrupt Management Registers</th></tr>
	<tr><td>IMR</td><td>Interrupt Level Mask Register</td><td>-</td><td>8 bit</td><td>Interrupt Mask - define which interrupt levels are accepted</td></tr>
	<tr><td>EIM</td><td>Effective Interrupt Level Mask Register</td><td>-</td><td>8 bit</td><td>Temporary Interrupt Mask. set from the ISR when an interrupt routine is initiated. Reset to IMR on RTI.</td></tr>
	<tr><td>ISR</td><td>Interrupt Level Status Register</td><td>-</td><td>8 bit</td><td>Interrupt line status - number of highest active interrupt line</td></tr>
	<tr><td>PC</td><td>Program Counter</td><td>16 bit</td><td>W bit</td><td></td></tr>
	<tr><th colspan="5">System Management Registers</th></tr>
	<tr><td>IV</td><td>Interrupt base register</td><td>-</td><td>W bit</td><td>Base address for interrupt vectors</td></tr>
	<tr><td>TV</td><td>Trap vector base register</td><td>-</td><td>W bit</td><td>Base address for trap vectors</td></tr>
	<tr><td>AV</td><td>Abort vector base register</td><td>-</td><td>W bit</td><td>Base address for abort vectors</td></tr>
	<tr><td>TMV</td><td>Trap maximum allowed vector number</td><td>-</td><td>W bit</td><td>set the maximum allowed trap vector number</td></tr>
	<tr><td>M(U)</td><td>User Mode Match register</td><td>-</td><td>8/8 bit</td><td>Match register for user mode</td></tr>
	<tr><td>M(H)</td><td>Hypervisor Mode Match register</td><td>-</td><td>8 bit</td><td>Match register for hypervisor mode</td></tr>
    </table>
    <p>The status register is divided into two bytes. The first mirrors the original 6502 status byte:</p>
    <table border="1">
<tr><th>bit 7</th><th>bit 6</th><th>bit 5</th><th>bit 4</th><th>bit 3</th><th>bit 2</th><th>bit 1</th><th>bit 0</th></tr>
<tr><th>128</th><th>64</th><th>32</th><th>16</th><th>8</th><th>4</th><th>2</th><th>1</th></tr>
<tr><td>N</td><td>V</td><td>0</td><td>B</td><td>D</td><td>I</td><td>Z</td><td>C</td></tr>
    </table>
    <table border="1">
<tr><th>Bit</th><th>Name</th><th>Explanation</th></tr>
<tr><td>N</td><td>Negative</td><td>Set when operation results in a negative value (bit 7 set)</td></tr>
<tr><td>V</td><td>Overflow</td><td>Set when arithmetic operation or compare results in an overflow value</td></tr>
<tr><td>B</td><td>Break</td><td>Set when a BRK opcode has been executed, is only written to the stack</td></tr>
<tr><td>D</td><td>Decimal</td><td>Decimal flag</td></tr>
<tr><td>I</td><td>Interrupt</td><td>Set to disable interrupts (deprecated)</td></tr>
<tr><td>Z</td><td>Zero</td><td>Set when operation results in a zero value</td></tr>
<tr><td>C</td><td>Carry</td><td>Carry for arithmetic operations and compares</td></tr>
    </table>
    <p>The second byte is an extended status byte. It is written on the stack frame on TRAP (user and
	hypervisor mode) and interrupts in hypervisor mode:</p>
    <table border="1">
<tr><th>bit 7</th><th>bit 6</th><th>bit 5</th><th>bit 4</th><th>bit 3</th><th>bit 2</th><th>bit 1</th><th>bit 0</th></tr>
<tr><th>128</th><th>64</th><th>32</th><th>16</th><th>8</th><th>4</th><th>2</th><th>1</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>H</td><td>P</td><td>SF1</td><td>SF0</td></tr>
    </table>
    <table border="1">
<tr><th>Bit</th><th>Name</th><th>Explanation</th><th>State on Reset</th></tr>
<tr><td>H</td><td>Hypervisor mode</td><td>Set when the processor is in hypervisor mode</td><td>1</td></tr>
<tr><td>P</td><td>Previous hypervisor mode</td><td>Copy of the Hypervisor mode bit made on TRAP or interrupt</td><td>1</td></tr>
<tr><td>SF1/SF0</td><td>Stack Frame Size</td><td>Determines the stack frame size for a TRAP or an interrupt
	(01=2 byte, 10=4 byte, 11=8 byte return address. 00 is reserved)
	</td><td>01</td></tr>
	<p>
	Note that the value read from the stack on RTI and RTU opcodes is fully evaluated only when read from the
	supervisor stack. When read from user stack the previous hypervisor mode bit P is ignored. 
	If the hypervisor mode bit H is set when reading from user stack, a privilege violation abort (PRIVRTI) is executed.
	If H is not set, the stack frame size bits SF are evaluated and the return address is read from the stack
	with a size according to SF.
	</p>
    </table>

    <p>The interrupt registers allow to query the current interrupt state and
	to control interrupt execution. They are not stored on the stack frame.
	</p>
    <table border="1">
<tr><th>Register</th><th>bit 7</th><th>bit 6</th><th>bit 5</th><th>bit 4</th><th>bit 3</th><th>bit 2</th><th>bit 1</th><th>bit 0</th></tr>
<tr><th>Value</th><th>128</th><th>64</th><th>32</th><th>16</th><th>8</th><th>4</th><th>2</th><th>1</th></tr>
<tr><th>IMR</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>IMR2</td><td>IMR1</td><td>IMR0</td></tr>
<tr><th>EIM</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>EIM2</td><td>EIM1</td><td>EIM0</td></tr>
<tr><th>ISR</th><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>ISR2</td><td>ISR1</td><td>ISR0</td></tr>
    </table>
    <table border="1">
<tr><th>Bit</th><th>Name</th><th>Explanation</th><th>Default</th></tr>
<tr><td>IMR2/IMR1/IMR0</td><td>Interrupt Priority Mask</td><td>Defines a number from 0 to 3. Each interrupt that 
	has a vector number above the value set here is disabled. Lower or equal interrupt numbers are enabled.
	I.e. value 0 disables all interrupts but NMI. Value 3 enables all interrupts.
	</td><td>00 (all interrupts disabled)</td></tr>
<tr><td>ISR2/ISR1/ISR0</td><td>Interrupt Status Register</td><td>Defines a number from 0 to 3 that determines the
	current interrupt level, i.e. the highest priority of all current - maskable - active interrupts,
	even if the interrupt itself is masked. 00 means no interrupt. For example 01 means interrupt 1 is active,
	but none other, while 10 means interrupt 2 is active, no matter if interrupt 1 is active or not.
	</td></tr>
<tr><td>EIM2/EIM1/EIM0</td><td>Temporary Interrupt Priority Mask</td><td>This value is set from the 
	interrupt mask register on RTI and CLEIM (both only on hypervisor mode), and set to the 
	interrupt level when the interrupt occurs. An interrupt routine is initiated when 
	EIM has a lower value than ISR - e.g. after an RTI or CLEIM when a lower priority interrupt is pending.</td></tr>
    </table>
    <p>The three interrupt registers work as follows.

	The supervisor-writable IMR defines which interrupts initiate 
	an interrupt routine. For example if the value is set to 2, interrupts with priority 0 (NMI), 1 and 2 are enabled.
	Interrupt with priority 3 and more are disabled.

	The ISR presents the "highest" interrupt level (lowest value(!)) that is currently active. 
	For example if interrupt lines 2, 5, and 7 are active, the ISR presents "2" as current status.

	When the ISR has a value that is lower or equal than the IMR value, an interrupt routine is initiated. 
	To stop the processor from continously starting the interrupt routine, when an interrupt routine is
	initiated, the EIM is used. It is the effective interrupt mask and normally set to the IMR value.
	When an interrupt routine is initiated, the EIM is set to the ISR value plus one. Then, as ISR is less than
	EIM, no further (stacked) interrupt routine is initiated. Only when a new interrupt with a higher
	priority (lower value) appears, the ISR value gets lower or less than EIM and a stacked interrupt routine
	is initiated.

	EIM is reset to the interrupt mask register 
	on RTI or CLEIM when executed in supervisor mode.
    </p>

    <p>The vector base registers allow define the addresses where interrupt, trap and abort vectors are 
	fetched from.
	</p>
    <table border="1">
<tr><th>Register</th><th>Description</th></tr>
<tr><th>IV</th><td>Address of interrupt vectors table; lowest 8 bit are reserved and must be 0</td></tr>
<tr><th>TV</th><td>Address of trap vectors table; lowest 8 bit are reserved and must be 0</td></tr>
<tr><th>AV</th><td>Address of abort vectors table; lowest 8 bit are reserved and must be 0</td></tr>
    </table>

    <p>The User mode match register is divided into two parts: the low byte is the actual match code. The high byte is
	a set of control bits for the user mode:</p>
    <table border="1">
<tr><th>bit 7</th><th>bit 6</th><th>bit 5</th><th>bit 4</th><th>bit 3</th><th>bit 2</th><th>bit 1</th><th>bit 0</th></tr>
<tr><th>128</th><th>64</th><th>32</th><th>16</th><th>8</th><th>4</th><th>2</th><th>1</th></tr>
<tr><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>U2</td><td>U1</td><td>U0</td></tr>
    </table>
    <table border="1">
<tr><th>Bit</th><th>Name</th><th>Explanation</th><th>State on Reset</th></tr>
<tr><td>U2/U1/U0</td><td>User mode interrupt selector</td><td>Selects one of the processor's three  external non-NMI interrupt
	sources as user mode interrupt. I.e. when in user mode and the interrupt occurs, a standard 6502
	interrupt sequence is initiated. If the processor is in hypervisor mode and the interrupt occurs, the
	standard interrupt sequence is initiated. If the interrupt is to be forwarded to the 
	user mode, the hypervisor mode interrupt routine has to explicitely setup the user mode stack
	and jump there.</td><td>000 = no interrupt source</td></tr>
    </table>
    <h3><a name="regmem" id="regmem">Memory Management Register</a></h3><p>The container management has a number of register sets. Each set contains three full size (W bits) 
	registers:</p>
    <table border="1">
	<tr><th>Container-Register</th><th>Definition</th><th>Comment</th></tr>
	<tr><td>Addr/matchcode mask</td><td>0-7: matchcode mask<br />
					8-W: address mask</td><td></td></tr>
	<tr><td>Addr/matchcode compare value</td><td>0-7: matchcode compare value<br />
					8-W: address compare value</td><td></td></tr>
	<tr><td>Addr offset/container control</td><td>0-7: Container control<br />
					8-W: address offset value</td><td></td></tr>
    </table><p>
	There can be any number of register sets. The number can be read from a configuration register. 
	If there are register sets, there must be at least four sets.
	For a full explanation see below.
    </p>
    </div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="overview" id="overview">65k Opcode and Addressing Mode Overview</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><p>
	This section describes in an overview the opcodes and addressing modes of the 65k.
	</p>
     <h3><a name="ovops" id="ovops">Opcodes Overview</a></h3>



<table class="optable"><tr><th>LSB-&gt;<br />MSB</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr>
<tr><th>0</th><td>BRK </td><td>ORA (zp,X)</td><td class="c65k">LDA zp,Y</td><td class="prefix">prefix1</td><td class="cmos">TSB zp</td><td>ORA zp</td><td>ASL zp</td><td class="prefix">prefix1</td><td>PHP </td><td>ORA #byte</td><td>ASL </td><td class="prefix">prefix2</td><td class="cmos">TSB abs</td><td>ORA abs</td><td>ASL abs</td><td class="prefix">EXT</td></tr>
<tr><th>1</th><td>BPL rel</td><td>ORA (zp),Y</td><td class="cmos">ORA (zp)</td><td class="prefix">prefix1</td><td class="cmos">TRB zp</td><td>ORA zp,X</td><td>ASL zp,X</td><td class="prefix">prefix1</td><td>CLC </td><td>ORA abs,Y</td><td class="cmos">INC </td><td class="prefix">prefix2</td><td class="cmos">TRB abs</td><td>ORA abs,X</td><td>ASL abs,X</td><td class="c65k">ASL abs,Y</td></tr>
<tr><th>2</th><td>JSR abs</td><td>AND (zp,X)</td><td class="c65k">STA zp,Y</td><td class="prefix">prefix1</td><td>BIT zp</td><td>AND zp</td><td>ROL zp</td><td class="prefix">prefix1</td><td>PLP </td><td>AND #byte</td><td>ROL </td><td class="prefix">prefix2</td><td>BIT abs</td><td>AND abs</td><td>ROL abs</td><td class="prefix">SYS</td></tr>
<tr><th>3</th><td>BMI rel</td><td>AND (zp),Y</td><td class="cmos">AND (zp)</td><td class="prefix">prefix1</td><td class="cmos">BIT zp,X</td><td>AND zp,X</td><td>ROL zp,X</td><td class="prefix">prefix1</td><td>SEC </td><td>AND abs,Y</td><td class="cmos">DEC </td><td class="prefix">prefix2</td><td class="cmos">BIT abs,X</td><td>AND abs,X</td><td>ROL abs,X</td><td class="c65k">ROL abs,Y</td></tr>
<tr><th>4</th><td>RTI </td><td>EOR (zp,X)</td><td class="c65k">LDA (abs),Y</td><td class="prefix">prefix1</td><td class="c65k">BSR relwide</td><td>EOR zp</td><td>LSR zp</td><td class="prefix">prefix1</td><td>PHA </td><td>EOR #byte</td><td>LSR </td><td class="prefix">prefix2</td><td>JMP abs</td><td>EOR abs</td><td>LSR abs</td><td class="prefix">QUICK</td></tr>
<tr><th>5</th><td>BVC rel</td><td>EOR (zp),Y</td><td class="cmos">EOR (zp)</td><td class="prefix">prefix1</td><td class="unused"></td><td>EOR zp,X</td><td>LSR zp,X</td><td class="prefix">prefix1</td><td>CLI </td><td>EOR abs,Y</td><td class="cmos">PHY </td><td class="prefix">prefix2</td><td class="unused"></td><td>EOR abs,X</td><td>LSR abs,X</td><td class="c65k">LSR abs,Y</td></tr>
<tr><th>6</th><td>RTS </td><td>ADC (zp,X)</td><td class="c65k">LDA (abs,X)</td><td class="prefix">prefix1</td><td class="cmos">STZ zp</td><td>ADC zp</td><td>ROR zp</td><td class="prefix">prefix1</td><td>PLA </td><td>ADC #byte</td><td>ROR </td><td class="prefix">prefix2</td><td>JMP (abs)</td><td>ADC abs</td><td>ROR abs</td><td class="prefix">reserved prefix</td></tr>
<tr><th>7</th><td>BVS rel</td><td>ADC (zp),Y</td><td class="cmos">ADC (zp)</td><td class="prefix">prefix1</td><td class="cmos">STZ zp,X</td><td>ADC zp,X</td><td>ROR zp,X</td><td class="prefix">prefix1</td><td>SEI </td><td>ADC abs,Y</td><td class="cmos">PLY </td><td class="prefix">prefix2</td><td class="cmos">JMP (abs,X)</td><td>ADC abs,X</td><td>ROR abs,X</td><td class="c65k">ROR abs,Y</td></tr>
<tr><th>8</th><td class="cmos">BRA rel</td><td>STA (zp,X)</td><td class="c65k">BSR rel</td><td class="prefix">prefix1</td><td>STY zp</td><td>STA zp</td><td>STX zp</td><td class="prefix">prefix1</td><td>DEY </td><td class="cmos">BIT #byte</td><td>TXA </td><td class="prefix">prefix2</td><td>STY abs</td><td>STA abs</td><td>STX abs</td><td class="prefix">reserved prefix</td></tr>
<tr><th>9</th><td>BCC rel</td><td>STA (zp),Y</td><td class="cmos">STA (zp)</td><td class="prefix">prefix1</td><td>STY zp,X</td><td>STA zp,X</td><td>STX zp,Y</td><td class="prefix">prefix1</td><td>TYA </td><td>STA abs,Y</td><td>TXS </td><td class="prefix">prefix2</td><td class="cmos">STZ abs</td><td>STA abs,X</td><td class="cmos">STZ abs,X</td><td class="c65k">STY abs,X</td></tr>
<tr><th>A</th><td>LDY #byte</td><td>LDA (zp,X)</td><td>LDX #byte</td><td class="prefix">prefix1</td><td>LDY zp</td><td>LDA zp</td><td>LDX zp</td><td class="prefix">prefix1</td><td>TAY </td><td>LDA #byte</td><td>TAX </td><td class="prefix">prefix2</td><td>LDY abs</td><td>LDA abs</td><td>LDX abs</td><td class="prefix">reserved prefix</td></tr>
<tr><th>B</th><td>BCS rel</td><td>LDA (zp),Y</td><td class="cmos">LDA (zp)</td><td class="prefix">prefix1</td><td>LDY zp,X</td><td>LDA zp,X</td><td>LDX zp,Y</td><td class="prefix">prefix1</td><td>CLV </td><td>LDA abs,Y</td><td>TSX </td><td class="prefix">prefix2</td><td>LDY abs,X</td><td>LDA abs,X</td><td>LDX abs,Y</td><td class="c65k">STX abs,Y</td></tr>
<tr><th>C</th><td>CPY #byte</td><td>CMP (zp,X)</td><td class="c65k">STA (abs),Y</td><td class="prefix">prefix1</td><td>CPY zp</td><td>CMP zp</td><td>DEC zp</td><td class="prefix">prefix1</td><td>INY </td><td>CMP #byte</td><td>DEX </td><td class="prefix">prefix2</td><td>CPY abs</td><td>CMP abs</td><td>DEC abs</td><td class="prefix">reserved prefix</td></tr>
<tr><th>D</th><td>BNE rel</td><td>CMP (zp),Y</td><td class="cmos">CMP (zp)</td><td class="prefix">prefix1</td><td class="unused"></td><td>CMP zp,X</td><td>DEC zp,X</td><td class="prefix">prefix1</td><td>CLD </td><td>CMP abs,Y</td><td class="cmos">PHX </td><td class="prefix">prefix2</td><td class="c65k">JSR (abs)</td><td>CMP abs,X</td><td>DEC abs,X</td><td class="c65k">DEC abs,Y</td></tr>
<tr><th>E</th><td>CPX #byte</td><td>SBC (zp,X)</td><td class="c65k">STA (abs,X)</td><td class="prefix">prefix1</td><td>CPX zp</td><td>SBC zp</td><td>INC zp</td><td class="prefix">prefix1</td><td>INX </td><td>SBC #byte</td><td>NOP </td><td class="prefix">prefix2</td><td>CPX abs</td><td>SBC abs</td><td>INC abs</td><td class="prefix">reserved prefix</td></tr>
<tr><th>F</th><td>BEQ rel</td><td>SBC (zp),Y</td><td class="cmos">SBC (zp)</td><td class="prefix">prefix1</td><td class="c65k">TRP #byte</td><td>SBC zp,X</td><td>INC zp,X</td><td class="prefix">prefix1</td><td>SED </td><td>SBC abs,Y</td><td class="cmos">PLX </td><td class="prefix">prefix2</td><td class="c65k">JSR (abs,X)</td><td>SBC abs,X</td><td>INC abs,X</td><td class="c65k">INC abs,Y</td></tr>
</table>


<p>Legend:</p>
<table class="optable">
<tr><td>NMOS Opcodes</td><td class="cmos">CMOS Opcodes</td><td class="c65k">New 65k opcodes</td><td class="prefix">65k Prefix codes</td><td class="unused">Unused/Reserved</td></tr>
</table>
	<p>
	Some of the opcodes are named prefix1 and prefix2, these are used as modifiers to other opcodes. For details see below. 
	Others are named like "QUICK prefix" or "EXT prefix".
	These opcodes provide a way to extend the opcode list by having a second opcode byte follow the prefix. Thus there 
	could be 256 additional "QUICK" opcodes, and 256 additional "EXT opcodes" and so on. These opcode planes are
	described below.
	</p><p>
	Note that there is still "plenty" of room for extensions. There are five reserved prefix bytes - 4 of them could be used to
	implement further modification bits (like going 128 bits ...yuck!) or they could be used as further opcode planes.
	The one prefix at $6F should be reserved for extensions like floating point or vector processors or other extensions
	that do not "just" modify existing opcodes.
	</p><p>
	Here is a short description of the new opcodes:
	</p>



<ul>
<li>
ADC: Add content of memory location to accumulator</li>
<li>
AND: Bitwise AND accumulator with content of memory location</li>
<li>
ASL: Arithmetic Shift Left - shift accumulator one bit to the left, shifting in zero in bit 0</li>
<li>
BCC: Branch on carry clear - take branch when C flag is cleared</li>
<li>
BCS: Branch on carry set - take branch when C flag is set</li>
<li>
BEQ: Branch on equal - take branch when Z flag is set</li>
<li>
BIT: Bitwise test with accumulator - AND the memory location with the accumulator, and set N (=bit 7), V (=bit 7), Z (iff all bits 
				zero) flags from the result. In case of the accumulator addressing, simply set the flags from the accumulator</li>
<li>
BMI: Branch on minus - take branch when N flag is set</li>
<li>
BNE: Branch on not equal - take branch when Z flag is cleared</li>
<li>
BPL: Branch on plus - take branch when N flag is cleared</li>
<li>
BRA: Branch always - branch independent from any flags</li>
<li>
BRK: Starts the break routine.</li>
<li>
BSR: Branch subroutine - similar to JSR, but use relative addressing similar to branch opcodes</li>
<li>
BVC: Branch on overflow clear - take branch when V flag is cleared</li>
<li>
BVS: Branch on overflow set - take branch when V flag is set</li>
<li>
CLC: Clear the C flag</li>
<li>
CLD: Clear the decimal (D) flag</li>
<li>
CLI: Clear the interrupt (I) flag</li>
<li>
CLV: Clear the overflow (V) flag</li>
<li>
CMP: Compare accumulator with content of memory location</li>
<li>
CPX: Compare X register with content of memory location</li>
<li>
CPY: Compare Y register with content of memory location</li>
<li>
DEC: Decrement the content of a memory location by one</li>
<li>
DEX: Decrement the content of the X register by one</li>
<li>
DEY: Decrement the Y register by one</li>
<li>
EOR: Bitwise Exclusive-OR accumulator with content of memory location</li>
<li>
INC: Increment the content of a memory location by one</li>
<li>
INX: Increment the content of the X register by one</li>
<li>
INY: Increment the content of the Y register by one</li>
<li>
JMP: Jump to new code address</li>
<li>
JSR: Jump subroutine - jump to a new code location, save return address on stack for RTS</li>
<li>
LDA: Load accumulator</li>
<li>
LDX: Load X register</li>
<li>
LDY: Load Y register</li>
<li>
LSR: Logical Shift Right - shift accumulator one bit to the right, shifting in zero in the highest bit</li>
<li>
NOP: No operation</li>
<li>
ORA: Bitwise OR accumulator with content of memory location</li>
<li>
PHA: Push contents of the accumulator onto the stack</li>
<li>
PHP: Push processor status register onto the stack</li>
<li>
PHX: Push contents of the X register onto the stack</li>
<li>
PHY: Push contents of the Y register onto the stack</li>
<li>
PLA: Pull the contents of the accumulator from the stack</li>
<li>
PLP: Pull processor status register from the stack</li>
<li>
PLX: Pull the contents of the X register from the stack</li>
<li>
PLY: Pull the contents of the Y register from the stack</li>
<li>
ROL: Rotate Left - shift accumulator one bit to the left, shifting in the carry flag in bit 0, and shifting the 
        	highest bit into the carry flag instead.</li>
<li>
ROR: Rotate Right - shift accumulator one bit to the right, shifting in the carry flag in the highest bit, and shifting 
        	bit 0 into the carry flag instead.</li>
<li>
RTI: Return from interrupt</li>
<li>
RTS: Return from subroutine - read return address from stack</li>
<li>
SBC: Substract content of memory location from accumulator</li>
<li>
SEC: Set the C flag</li>
<li>
SED: Set the decimal (D) flag</li>
<li>
SEI: Set the interrupt (I) flag</li>
<li>
STA: Store the content of the accumulator into a memory location</li>
<li>
STX: Store the content of the X register to memory.</li>
<li>
STY: Store the content of the Y register to memory.</li>
<li>
STZ: Store zero into a memory location</li>
<li>
TAX: Transfer the contents of accumulator into the X register</li>
<li>
TAY: Transfer the contents of accumulator into the Y register</li>
<li>
TRB: Test and Reset Bit - AND the memory location with the accumulator, and set the Z flag from the result, then CLEAR all bits in the
				memory location that are set in the accumulator.</li>
<li>
TRP: Trap into 65k supervisor mode</li>
<li>
TSB: Test and Set Bit - AND the memory location with the accumulator, and set the Z flag from the result, then SET all bits in the
				memory location that are set in the accumulator.</li>
<li>
TSX: Transfer the contents of the stack pointer into the X register (Note: needs RS to keep compatibility with 6502)</li>
<li>
TXA: Transfer the contents of the X register into the accumulator</li>
<li>
TXS: Transfer the contents of X register into the stack pointer (Note: needs RS to keep compatibility with 6502)</li>
<li>
TYA: Transfer the contents of the Y register into the accumulator</li>
</ul>



    	<h3><a name="ovadmd" id="ovadmd">Addressing Modes Overview</a></h3><p>
	This section describes an overview on the addressing modes of the 65k processor. An addressing mode determines
	effective address of an operand (no matter what size the operand is). The addressing modes are 
	described in detail below.
	</p>



<table class="optable"><tr><th>Name</th><th>Alternative Name</th><th>Prefix</th><th>Operand Length</th><th>Syntax</th><th>Origin</th><th>Description</th></tr>
<tr><td>Implied</td><td></td><td></td><td>0</td><td></td><td></td><td>Implied by the operation</td></tr>
<tr><td>Accumulator</td><td></td><td></td><td>0</td><td></td><td></td><td>Accumulator operation</td></tr>
<tr><td>Immediate</td><td></td><td></td><td>1</td><td>#byte</td><td></td><td>The immediate addressing mode uses the opcode parameter directly, without further lookup. Here it is a byte parameter</td></tr>
<tr><td>Immediate 16bit</td><td>Wide immediate</td><td>RS=01</td><td>2</td><td>#word</td><td>65k</td><td>The immediate addressing mode uses the opcode parameter directly, without further lookup. Here it is a word (16bit) parameter</td></tr>
<tr><td>Immediate 32bit</td><td>Long immediate</td><td>RS=10</td><td>4</td><td>#long</td><td>65k</td><td>The immediate addressing mode uses the opcode parameter directly, without further lookup. Here it is a long (32bit) parameter</td></tr>
<tr><td>Immediate 64bit</td><td></td><td>RS=11</td><td>8</td><td>#quad</td><td>65k</td><td>The immediate addressing mode uses the opcode parameter directly, without further lookup. Here it is a quad (64bit) parameter</td></tr>
<tr><td>E indirect</td><td></td><td></td><td>0</td><td>(E)</td><td>65k</td><td>E-register indirect: the effective address is taken from the E register.</td></tr>
<tr><td>Zeropage</td><td></td><td></td><td>1</td><td>zp</td><td></td><td>Zeropage address; The effective address of the operand is a zeropage address (i.e. 8bit)</td></tr>
<tr><td>Zeropage indexed with X</td><td>Zeropage X-indexed</td><td></td><td>1</td><td>zp,X</td><td></td><td>Zeropage address, plus content of XR; The effective address of the operand is the opcode parameter (zeropage address), plus the value of the X register</td></tr>
<tr><td>Zeropage indexed with Y</td><td>Zeropage Y-indexed</td><td></td><td>1</td><td>zp,Y</td><td></td><td>Zeropage address, plus content of YR; The effective address of the operand is the opcode parameter (zeropage address), plus the value of the Y register</td></tr>
<tr><td>Absolute 16bit</td><td>Absolute</td><td></td><td>2</td><td>abs</td><td></td><td>16 bit address; The effective address of the operand is the word address (i.e. 16 bit) given as opcode parameter</td></tr>
<tr><td>Absolute 16bit indexed with X</td><td>Absolute X-indexed</td><td></td><td>2</td><td>abs,X</td><td></td><td>16 bit address, plus content of XR; The effective address is the opcode parameter (word address), plus the value of the X register</td></tr>
<tr><td>Absolute 16bit indexed with Y</td><td>Absolute Y-indexed</td><td></td><td>2</td><td>abs,Y</td><td></td><td>16 bit address, plus content of YR; The effective address is the opcode parameter (word address), plus the value of the Y register</td></tr>
<tr><td>Absolute 32bit</td><td>Long absolute</td><td>AM=1</td><td>4</td><td>long</td><td>65k</td><td>32 bit address; The effective address is the opcode parameter, which is a long address (i.e. 32 bit)</td></tr>
<tr><td>Absolute 32bit indexed with X</td><td>Long absolute X-indexed</td><td>AM=1</td><td>4</td><td>long,X</td><td>65k</td><td>32 bit address, plus content of XR; The effective address is the opcode parameter (long address), plus the value of the X register</td></tr>
<tr><td>Absolute 32bit indexed with Y</td><td>Long absolute Y-indexed</td><td>AM=1</td><td>4</td><td>long,Y</td><td>65k</td><td>32 bit address, plus content of YR; The effective address is the opcode parameter (long address), plus the value of the Y register</td></tr>
<tr><td>Absolute 64bit</td><td>Quad absolute</td><td>AM=1</td><td>8</td><td>quad</td><td>65k</td><td>64 bit address; The effective address is the opcode parameter, which is a quad address (i.e. 64 bit)</td></tr>
<tr><td>Absolute 64bit indexed with X</td><td>Quad absolute X-indexed</td><td>AM=1</td><td>8</td><td>quad,X</td><td>65k</td><td>64 bit address, plus content of XR; The effective address is the opcode parameter (quad address), plus the value of the X register</td></tr>
<tr><td>Absolute 64bit indexed with Y</td><td>Quad absolute Y-indexed</td><td>AM=1</td><td>8</td><td>quad,Y</td><td>65k</td><td>64 bit address, plus content of YR; The effective address is the opcode parameter (quad address), plus the value of the Y register</td></tr>
<tr><td>Zeropage indirect 16bit</td><td>Zeropage indirect</td><td></td><td>1</td><td>(zp)</td><td>cmos</td><td>Load effective 16 bit address from zeropage location given; Load effective word (16bit) address from zeropage location given as parameter.</td></tr>
<tr><td>Zeropage indirect 16bit indexed with Y</td><td>Zeropage indirect Y-indexed</td><td></td><td>1</td><td>(zp),Y</td><td></td><td>Load effective 16 bit address from zeropage location given, then add content of YR; 
        	The effective address is computed as the word (16bit) address read from the zeropage location given as parameter plus the value of the Y register. The resulting address may be larger than 16bit due to overflow when Y is added.</td></tr>
<tr><td>Zeropage indexed with X indirect 16bit</td><td>Zeropage X-indexed indirect</td><td></td><td>1</td><td>(zp,X)</td><td></td><td>Load effective 16 bit address from zeropage location given plus content of XR; 
        	The effective word (16bit) address is read from the location that is computed as the zeropage location given as parameter plus the value of the X register</td></tr>
<tr><td>Absolute indirect 16bit</td><td>Absolute indirect</td><td></td><td>2</td><td>(abs)</td><td></td><td>Load effective 16 bit address from absolute location given; 
        	The effective word (16bit) address is read from word location given as parameter.</td></tr>
<tr><td>Absolute indirect 16bit indexed with Y</td><td>Absolute indirect Y-indexed</td><td></td><td>2</td><td>(abs),Y</td><td>65k</td><td>Load effective 16 bit address from absolute location given, then add content of YR; 
        	The effective address is computed as the word (16bit) address read from the word location given as parameter plus the value of the Y register. The resulting address may be larger than 16bit due to overflow when Y is added.</td></tr>
<tr><td>Absolute indexed with X indirect 16bit</td><td>Absolute X-indexed indirect</td><td></td><td>2</td><td>(abs,X)</td><td>cmos</td><td>Load effective 16 bit address from absolute location given plus content of XR;
        	The effective word address is read from the location that is computed as the word location given as parameter plus the value of the X register</td></tr>
<tr><td>Zeropage indirect 32bit</td><td>Long Zeropage indirect</td><td>AM=1</td><td>1</td><td>[zp]</td><td>65k</td><td>Load effective 32 bit address from zeropage location given; 
        	The effective long (32bit) address is read from zeropage location given as parameter.</td></tr>
<tr><td>Zeropage indirect 32bit indexed with Y</td><td>Zeropage long indirect Y-indexed</td><td>AM=1</td><td>1</td><td>[zp],Y</td><td>65k</td><td>Load effective 32 bit address from zeropage location given, then add content of YR;
        	The effective address is computed as the long (32bit) address read from the zeropage location given as parameter plus the value of the Y register.  The resulting address may be larger than 32bit due to overflow when Y is added.</td></tr>
<tr><td>Zeropage indexed with X indirect 32bit</td><td>Zeropage X-indexed long indirect</td><td>AM=1</td><td>1</td><td>[zp,X]</td><td>65k</td><td>Load effective 32 bit address from zeropage location given plus content of XR;
        	The effective long (32bit) address is read from the location that is computed as the zeropage location given as parameter plus the value of the X register</td></tr>
<tr><td>Absolute indirect 32bit</td><td>Absolute long indirect</td><td>AM=1</td><td>2</td><td>[abs]</td><td>65k</td><td>Load effective 32 bit address from absolute location given;
        	The effective long (32bit) address is read from word location given as parameter.</td></tr>
<tr><td>Absolute indirect 32bit indexed with Y</td><td>Absolute long indirect Y-indexed</td><td>AM=1</td><td>2</td><td>[abs],Y</td><td>65k</td><td>Load effective 32 bit address from absolute location given, then add content of YR;
        	The effective address is computed as the long address read from the word location given as parameter plus the value of the Y register.  The resulting address may be larger than 32bit due to overflow when Y is added.</td></tr>
<tr><td>Absolute indexed with X indirect 32bit</td><td>Absolute X-indexed long indirect</td><td>AM=1</td><td>2</td><td>[abs,X]</td><td>65k</td><td>Load effective 32 bit address from absolute location given plus content of XR;
        	The effective long (32bit) address is read from the location that is computed as the word location given as parameter plus the value of the X register</td></tr>
<tr><td>Zeropage indirect 64bit</td><td>Zeropage quad indirect</td><td>AM=1</td><td>1</td><td>[[zp]]</td><td>65k</td><td>Load effective 64 bit address from zeropage location given;
        	The effective quad (64bit) address is read from zeropage location given as parameter.</td></tr>
<tr><td>Zeropage indirect 64bit indexed with Y</td><td>Zeropage quad indirect Y-indexed</td><td>AM=1</td><td>1</td><td>[[zp]],Y</td><td>65k</td><td>Load effective 64 bit address from zeropage location given, then add content of YR;
        	The effective address is computed as the quad (64bit) address read from the zeropage location given as parameter plus the value of the Y register</td></tr>
<tr><td>Zeropage indexed with X indirect 64bit</td><td>Zeropage X-indexed quad indirect</td><td>AM=1</td><td>1</td><td>[[zp,X]]</td><td>65k</td><td>Load effective 64 bit address from zeropage location given plus content of XR;
        	The effective quad (64bit) address is read from the location that is computed as the zeropage location given as parameter plus the value of the X register</td></tr>
<tr><td>Absolute indirect 64bit</td><td>Absolute quad indirect</td><td>AM=1</td><td>2</td><td>[[abs]]</td><td>65k</td><td>Load effective 64 bit address from absolute location given;
        	The effective quad (64bit) address is read from word location given as parameter.</td></tr>
<tr><td>Absolute indirect 64bit indexed with Y</td><td>Absolute quad indirect Y-indexed</td><td>AM=1</td><td>2</td><td>[[abs]],Y</td><td>65k</td><td>Load effective 64 bit address from absolute location given, then add content of YR;
        	The effective address is computed as the quad address read from the word location given as parameter plus the value of the Y register</td></tr>
<tr><td>Absolute indexed with X indirect 64bit</td><td>Absolute X-indexed quad indirect</td><td>AM=1</td><td>2</td><td>[[abs,X]]</td><td>65k</td><td>Load effective 64 bit address from absolute location given plus content of XR;
        	The effective quad (64bit) address is read from the location that is computed as the word location given as parameter plus the value of the X register</td></tr>
<tr><td>Relative</td><td></td><td></td><td>1</td><td>rel</td><td></td><td>relative addressing modes, used in branches; from -128 to +127</td></tr>
<tr><td>Relative 16bit</td><td>Wide relative</td><td>RS=01</td><td>2</td><td>relwide</td><td>65k</td><td>relative addressing modes, used in branches; from -32768 to +32767</td></tr>
<tr><td>Relative 32bit</td><td>Long relative</td><td>RS=10</td><td>4</td><td>rellong</td><td>65k</td><td>relative addressing modes, used in branches; from -2^32 to +2^32-1</td></tr>
<tr><td>Relative 64bit</td><td>Quad relative</td><td>RS=11</td><td>8</td><td>relquad</td><td>65k</td><td>relative addressing modes, used in branches; from -2^64 to +2^64-1</td></tr>
<tr><td>Relative (BSR)</td><td></td><td></td><td>1</td><td>rel</td><td></td><td>relative addressing modes, used in BSR; from -128 to +127</td></tr>
<tr><td>Relative 16bit (BSR)</td><td>Wide relative</td><td></td><td>2</td><td>relwide</td><td>65k</td><td>relative addressing modes, used in BSR; from -32768 to +32767</td></tr>
<tr><td>Relative 32bit (BSR)</td><td>Long relative</td><td>AM=1</td><td>4</td><td>rellong</td><td>65k</td><td>relative addressing modes, used in BSR; from -2^32 to +2^32-1</td></tr>
<tr><td>Relative 64bit (BSR)</td><td>Quad relative</td><td>AM=1</td><td>8</td><td>relquad</td><td>65k</td><td>relative addressing modes, used in BSR; from -2^64 to +2^64-1</td></tr>
</table>



<p>
	You will note that not all of these addressing modes are shown in the above table. Here the prefix codes come into play.
    	</p><h3><a name="ovpref" id="ovpref">Prefix Overview</a></h3><p>
	In the opcode map there are 32 codes designated as "prefix1" and 16 codes designated as "prefix2". These opcodes are no operations in themselves, but
	modify the following operation. The prefix has these values:</p>
<table class="bittable">
<tr><th colspan="8">prefix1</th></tr>
<tr><th>bit 7</th><th>bit 6</th><th>bit 5</th><th>bit 4</th><th>bit 3</th><th>bit 2</th><th>bit 1</th><th>bit 0</th></tr>
<tr><th>128</th><th>64</th><th>32</th><th>16</th><th>8</th><th>4</th><th>2</th><th>1</th></tr>
<tr><td>OF1</td><td>OF0</td><td>RS1</td><td>RS0</td><td>0</td><td>AM</td><td>1</td><td>1</td></tr>
</table><p>
	I.e. in prefix1 the lowest two bits are always one and bit 2 (value 4) is always zero, but all of the other five 
	bits have a special meaning.</p>
<table class="bittable">
<tr><th colspan="8">prefix2</th></tr>
<tr><th>bit 7</th><th>bit 6</th><th>bit 5</th><th>bit 4</th><th>bit 3</th><th>bit 2</th><th>bit 1</th><th>bit 0</th></tr>
<tr><th>128</th><th>64</th><th>32</th><th>16</th><th>8</th><th>4</th><th>2</th><th>1</th></tr>
<tr><td>UM</td><td>LE1</td><td>LE0</td><td>NF</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
</table><p>
	For prefix2 the low four bit are fixed, the other bits are used as prefix.
</p><p>
	The following table explains the prefix bits.
</p>
<table class="optable">
<tr><th>AM</th><th>Adressing Modes</th></tr>
<tr><td>0</td><td>normal addressing modes (8 / 16 bit)</td></tr>
<tr><td>1</td><td>extended addressing modes (32 / 64 bit)</td></tr>
<tr><th>LE</th><th>Load extension</th></tr>
<tr><td>0/0</td><td>Do not extend values to full register width when loading a value with RS width; operations use RS width - default for all AC-related operations.</td></tr>
<tr><td>0/1</td><td>Sign-extend values to full register width when loading a value with RS width; operations use full width</td></tr>
<tr><td>1/0</td><td>Zero-extend values to full register width when loading a value with RS width; operations use full width - default for XR/YR-related operations.</td></tr>
<tr><td>1/1</td><td>One-extend values to full register width when loading a value with RS width; operations use full width</td></tr>
<tr><th>RS1/RS0</th><th>Register Size</th></tr>
<tr><td>0/0</td><td>8 bit register</td></tr>
<tr><td>0/1</td><td>16 bit register</td></tr>
<tr><td>1/0</td><td>32 bit register</td></tr>
<tr><td>1/1</td><td>64 bit register</td></tr>
<tr><th>OF1/OF0</th><th>Offset Register</th></tr>
<tr><td>0/0</td><td>No offset added to address</td></tr>
<tr><td>0/1</td><td>Add Program Counter (PC) to address</td></tr>
<tr><td>1/0</td><td>Add Stack Pointer (SP) to address</td></tr>
<tr><td>1/1</td><td>Add Base Offset Register (BR) to address</td></tr>
<tr><th>UM</th><th>User mode selector</th></tr>
<tr><td>0</td><td>Current mode environment (user space/hypervisor mode)</td></tr>
<tr><td>1</td><td>User mode environment, privileged operation; Stack Pointer for OF=10 is also User Space stack pointer </td></tr>
<tr><th>NF</th><th>No Flags selector</th></tr>
<tr><td>0</td><td>Flags are updated on each (relevant) operation according to standard 6502 rules</td></tr>
<tr><td>1</td><td>Flags are not updated.</td></tr>
</table><p>
	These prefix opcodes modify the following opcodes in various aspects. The following opcodes
	are taken from the original 8 bit opcodes. I.e. there could be a new opcode
	</p><pre>
	LDA.L #$12345678
	</pre><p>to load the accumulator with a long (32 bit) value, that is implemented as
	</p><pre>
	23 A9 78 56 34 12
	</pre><p>. Here 23 is the prefix with RS=%10, i.e. 32 bit registers, and A9 is the original
	LDA immediate opcode - only the parameter is now 4 byte (32 bit) not 1 byte anymore.
	</p><p>
	Please note that when all variable prefix bits are zero, the original 6502 operation is executed.
	</p><p>
	Please also note that the order of the prefix bytes is well defined. prefix1 must be before prefix2,
	which is before the actual opcode. This way the prefix1 codes can be reused in the actual prefixed opcode.
	This would not be the case if prefix2 was before prefix1, because then it would not be distinguishable
	of the byte following prefix2 is a prefix1 or a reused opcode.
	</p><p>
	The LE flags only apply to opcodes that read an operand from memory, but not to read-modify-write opcodes.
	(It does not apply to store operations (which could have been done switching memory and register sides), but
	as the processor is available in different full-size register width, the software would expect to have a specific
	width, binding the software to a specific width)
	</p><p>
	The NF flag does not apply to compare opcodes - their only purpose is to set the flags...
	</p><p>
	The following table describes which prefix bit is applicable to which opcode:
	</p>


<table class="optable"><tr><th>LSB-&gt;<br />MSB</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr>
<tr><th>0</th><td>BRK </td><td>ORA (zp,X)<br />NF,RS,UM,OF,LE,AM</td><td class="c65k">LDA zp,Y<br />NF,RS,UM,OF,LE,AM</td><td class="prefix">ORA [[zp,X]]<br />NF,RS,UM,OF,LE,AM=1</td><td class="cmos">TSB zp<br />NF,RS,UM,OF,AM</td><td>ORA zp<br />NF,RS,UM,OF,LE,AM</td><td>ASL zp<br />NF,RS,UM,OF,AM</td><td class="prefix">JMP [[abs]]<br />UM,OF,AM=1</td><td>PHP </td><td>ORA #byte<br />NF,RS,LE</td><td>ASL <br />NF,RS</td><td class="prefix">prefix2</td><td class="cmos">TSB abs<br />NF,RS,UM,OF,AM</td><td>ORA abs<br />NF,RS,UM,OF,LE,AM</td><td>ASL abs<br />NF,RS,UM,OF,AM</td><td class="prefix">EXT</td></tr>
<tr><th>1</th><td>BPL rel<br />RS</td><td>ORA (zp),Y<br />NF,RS,UM,OF,LE,AM</td><td class="cmos">ORA (zp)<br />NF,RS,UM,OF,LE,AM</td><td class="prefix">ORA [[zp]],Y<br />NF,RS,UM,OF,LE,AM=1</td><td class="cmos">TRB zp<br />NF,RS,UM,OF,AM</td><td>ORA zp,X<br />NF,RS,UM,OF,LE,AM</td><td>ASL zp,X<br />NF,RS,UM,OF,AM</td><td class="prefix">ORA [[zp]]<br />NF,RS,UM,OF,LE,AM=1</td><td>CLC </td><td>ORA abs,Y<br />NF,RS,UM,OF,LE,AM</td><td class="cmos">INC <br />NF,RS</td><td class="prefix">prefix2</td><td class="cmos">TRB abs<br />NF,RS,UM,OF,AM</td><td>ORA abs,X<br />NF,RS,UM,OF,LE,AM</td><td>ASL abs,X<br />NF,RS,UM,OF,AM</td><td class="c65k">ASL abs,Y<br />NF,RS,UM,OF,AM</td></tr>
<tr><th>2</th><td>JSR abs<br />RS,UM,OF,AM</td><td>AND (zp,X)<br />NF,RS,UM,OF,LE,AM</td><td class="c65k">STA zp,Y<br />RS,UM,OF,AM</td><td class="prefix">AND [[zp,X]]<br />NF,RS,UM,OF,LE,AM=1</td><td>BIT zp<br />NF,RS,UM,OF,LE,AM</td><td>AND zp<br />NF,RS,UM,OF,LE,AM</td><td>ROL zp<br />NF,RS,UM,OF,AM</td><td class="prefix">JMP [[abs,X]]<br />UM,OF,AM=1</td><td>PLP </td><td>AND #byte<br />NF,RS,LE</td><td>ROL <br />NF,RS</td><td class="prefix">prefix2</td><td>BIT abs<br />NF,RS,UM,OF,LE,AM</td><td>AND abs<br />NF,RS,UM,OF,LE,AM</td><td>ROL abs<br />NF,RS,UM,OF,AM</td><td class="prefix">SYS</td></tr>
<tr><th>3</th><td>BMI rel<br />RS</td><td>AND (zp),Y<br />NF,RS,UM,OF,LE,AM</td><td class="cmos">AND (zp)<br />NF,RS,UM,OF,LE,AM</td><td class="prefix">AND [[zp]],Y<br />NF,RS,UM,OF,LE,AM=1</td><td class="cmos">BIT zp,X<br />NF,RS,UM,OF,LE,AM</td><td>AND zp,X<br />NF,RS,UM,OF,LE,AM</td><td>ROL zp,X<br />NF,RS,UM,OF,AM</td><td class="prefix">AND [[zp]]<br />NF,RS,UM,OF,LE,AM=1</td><td>SEC </td><td>AND abs,Y<br />NF,RS,UM,OF,LE,AM</td><td class="cmos">DEC <br />NF,RS</td><td class="prefix">prefix2</td><td class="cmos">BIT abs,X<br />NF,RS,UM,OF,LE,AM</td><td>AND abs,X<br />NF,RS,UM,OF,LE,AM</td><td>ROL abs,X<br />NF,RS,UM,OF,AM</td><td class="c65k">ROL abs,Y<br />NF,RS,UM,OF,AM</td></tr>
<tr><th>4</th><td>RTI </td><td>EOR (zp,X)<br />NF,RS,UM,OF,LE,AM</td><td class="c65k">LDA (abs),Y<br />NF,RS,UM,OF,LE,AM</td><td class="prefix">EOR [[zp,X]]<br />NF,RS,UM,OF,LE,AM=1</td><td class="c65k">BSR relwide<br />RS,AM</td><td>EOR zp<br />NF,RS,UM,OF,LE,AM</td><td>LSR zp<br />NF,RS,UM,OF,AM</td><td class="prefix">LDA [[abs]],Y<br />NF,RS,UM,OF,LE,AM=1</td><td>PHA <br />RS,UM</td><td>EOR #byte<br />NF,RS,LE</td><td>LSR <br />NF,RS</td><td class="prefix">prefix2</td><td>JMP abs<br />UM,OF,AM</td><td>EOR abs<br />NF,RS,UM,OF,LE,AM</td><td>LSR abs<br />NF,RS,UM,OF,AM</td><td class="prefix">QUICK</td></tr>
<tr><th>5</th><td>BVC rel<br />RS</td><td>EOR (zp),Y<br />NF,RS,UM,OF,LE,AM</td><td class="cmos">EOR (zp)<br />NF,RS,UM,OF,LE,AM</td><td class="prefix">EOR [[zp]],Y<br />NF,RS,UM,OF,LE,AM=1</td><td class="unused"></td><td>EOR zp,X<br />NF,RS,UM,OF,LE,AM</td><td>LSR zp,X<br />NF,RS,UM,OF,AM</td><td class="prefix">EOR [[zp]]<br />NF,RS,UM,OF,LE,AM=1</td><td>CLI </td><td>EOR abs,Y<br />NF,RS,UM,OF,LE,AM</td><td class="cmos">PHY <br />RS,UM</td><td class="prefix">prefix2</td><td class="unused"></td><td>EOR abs,X<br />NF,RS,UM,OF,LE,AM</td><td>LSR abs,X<br />NF,RS,UM,OF,AM</td><td class="c65k">LSR abs,Y<br />NF,RS,UM,OF,AM</td></tr>
<tr><th>6</th><td>RTS <br />RS</td><td>ADC (zp,X)<br />NF,RS,UM,OF,LE,AM</td><td class="c65k">LDA (abs,X)<br />NF,RS,UM,OF,LE,AM</td><td class="prefix">ADC [[zp,X]]<br />NF,RS,UM,OF,LE,AM=1</td><td class="cmos">STZ zp<br />RS,UM,OF,AM</td><td>ADC zp<br />NF,RS,UM,OF,LE,AM</td><td>ROR zp<br />NF,RS,UM,OF,AM</td><td class="prefix">LDA [[abs,X]]<br />NF,RS,UM,OF,LE,AM=1</td><td>PLA <br />NF,RS,UM,LE</td><td>ADC #byte<br />NF,RS,LE</td><td>ROR <br />NF,RS</td><td class="prefix">prefix2</td><td>JMP (abs)<br />UM,OF,AM</td><td>ADC abs<br />NF,RS,UM,OF,LE,AM</td><td>ROR abs<br />NF,RS,UM,OF,AM</td><td class="prefix">reserved prefix</td></tr>
<tr><th>7</th><td>BVS rel<br />RS</td><td>ADC (zp),Y<br />NF,RS,UM,OF,LE,AM</td><td class="cmos">ADC (zp)<br />NF,RS,UM,OF,LE,AM</td><td class="prefix">ADC [[zp]],Y<br />NF,RS,UM,OF,LE,AM=1</td><td class="cmos">STZ zp,X<br />RS,UM,OF,AM</td><td>ADC zp,X<br />NF,RS,UM,OF,LE,AM</td><td>ROR zp,X<br />NF,RS,UM,OF,AM</td><td class="prefix">ADC [[zp]]<br />NF,RS,UM,OF,LE,AM=1</td><td>SEI </td><td>ADC abs,Y<br />NF,RS,UM,OF,LE,AM</td><td class="cmos">PLY <br />NF,RS,UM,LE</td><td class="prefix">prefix2</td><td class="cmos">JMP (abs,X)<br />UM,OF,AM</td><td>ADC abs,X<br />NF,RS,UM,OF,LE,AM</td><td>ROR abs,X<br />NF,RS,UM,OF,AM</td><td class="c65k">ROR abs,Y<br />NF,RS,UM,OF,AM</td></tr>
<tr><th>8</th><td class="cmos">BRA rel<br />RS</td><td>STA (zp,X)<br />RS,UM,OF,AM</td><td class="c65k">BSR rel<br />RS,AM</td><td class="prefix">STA [[zp,X]]<br />RS,UM,OF,AM=1</td><td>STY zp<br />RS,UM,OF,AM</td><td>STA zp<br />RS,UM,OF,AM</td><td>STX zp<br />RS,UM,OF,AM</td><td class="prefix">JSR [[abs]]<br />RS,UM,OF,AM=1</td><td>DEY <br />NF,RS</td><td class="cmos">BIT #byte<br />NF,RS,LE</td><td>TXA <br />NF,RS,LE</td><td class="prefix">prefix2</td><td>STY abs<br />RS,UM,OF,AM</td><td>STA abs<br />RS,UM,OF,AM</td><td>STX abs<br />RS,UM,OF,AM</td><td class="prefix">reserved prefix</td></tr>
<tr><th>9</th><td>BCC rel<br />RS</td><td>STA (zp),Y<br />RS,UM,OF,AM</td><td class="cmos">STA (zp)<br />RS,UM,OF,AM</td><td class="prefix">STA [[zp]],Y<br />RS,UM,OF,AM=1</td><td>STY zp,X<br />RS,UM,OF,AM</td><td>STA zp,X<br />RS,UM,OF,AM</td><td>STX zp,Y<br />RS,UM,OF,AM</td><td class="prefix">STA [[zp]]<br />RS,UM,OF,AM=1</td><td>TYA <br />NF,RS,LE</td><td>STA abs,Y<br />RS,UM,OF,AM</td><td>TXS <br />RS,UM,LE</td><td class="prefix">prefix2</td><td class="cmos">STZ abs<br />RS,UM,OF,AM</td><td>STA abs,X<br />RS,UM,OF,AM</td><td class="cmos">STZ abs,X<br />RS,UM,OF,AM</td><td class="c65k">STY abs,X<br />RS,UM,OF,AM</td></tr>
<tr><th>A</th><td>LDY #byte<br />NF,RS,LE</td><td>LDA (zp,X)<br />NF,RS,UM,OF,LE,AM</td><td>LDX #byte<br />NF,RS,LE</td><td class="prefix">LDA [[zp,X]]<br />NF,RS,UM,OF,LE,AM=1</td><td>LDY zp<br />NF,RS,UM,OF,LE,AM</td><td>LDA zp<br />NF,RS,UM,OF,LE,AM</td><td>LDX zp<br />NF,RS,UM,OF,LE,AM</td><td class="prefix">JSR [[abs,X]]<br />RS,UM,OF,AM=1</td><td>TAY <br />NF,RS,LE</td><td>LDA #byte<br />NF,RS,LE</td><td>TAX <br />NF,RS,LE</td><td class="prefix">prefix2</td><td>LDY abs<br />NF,RS,UM,OF,LE,AM</td><td>LDA abs<br />NF,RS,UM,OF,LE,AM</td><td>LDX abs<br />NF,RS,UM,OF,LE,AM</td><td class="prefix">reserved prefix</td></tr>
<tr><th>B</th><td>BCS rel<br />RS</td><td>LDA (zp),Y<br />NF,RS,UM,OF,LE,AM</td><td class="cmos">LDA (zp)<br />NF,RS,UM,OF,LE,AM</td><td class="prefix">LDA [[zp]],Y<br />NF,RS,UM,OF,LE,AM=1</td><td>LDY zp,X<br />NF,RS,UM,OF,LE,AM</td><td>LDA zp,X<br />NF,RS,UM,OF,LE,AM</td><td>LDX zp,Y<br />NF,RS,UM,OF,LE,AM</td><td class="prefix">LDA [[zp]]<br />NF,RS,UM,OF,LE,AM=1</td><td>CLV </td><td>LDA abs,Y<br />NF,RS,UM,OF,LE,AM</td><td>TSX <br />NF,RS,UM,LE</td><td class="prefix">prefix2</td><td>LDY abs,X<br />NF,RS,UM,OF,LE,AM</td><td>LDA abs,X<br />NF,RS,UM,OF,LE,AM</td><td>LDX abs,Y<br />NF,RS,UM,OF,LE,AM</td><td class="c65k">STX abs,Y<br />RS,UM,OF,AM</td></tr>
<tr><th>C</th><td>CPY #byte<br />RS,LE</td><td>CMP (zp,X)<br />RS,UM,OF,LE,AM</td><td class="c65k">STA (abs),Y<br />RS,UM,OF,AM</td><td class="prefix">CMP [[zp,X]]<br />RS,UM,OF,LE,AM=1</td><td>CPY zp<br />RS,UM,OF,LE,AM</td><td>CMP zp<br />RS,UM,OF,LE,AM</td><td>DEC zp<br />NF,RS,UM,OF,AM</td><td class="prefix">STA [[abs]],Y<br />RS,UM,OF,AM=1</td><td>INY <br />NF,RS</td><td>CMP #byte<br />RS,LE</td><td>DEX <br />NF,RS</td><td class="prefix">prefix2</td><td>CPY abs<br />RS,UM,OF,LE,AM</td><td>CMP abs<br />RS,UM,OF,LE,AM</td><td>DEC abs<br />NF,RS,UM,OF,AM</td><td class="prefix">reserved prefix</td></tr>
<tr><th>D</th><td>BNE rel<br />RS</td><td>CMP (zp),Y<br />RS,UM,OF,LE,AM</td><td class="cmos">CMP (zp)<br />RS,UM,OF,LE,AM</td><td class="prefix">CMP [[zp]],Y<br />RS,UM,OF,LE,AM=1</td><td class="unused"></td><td>CMP zp,X<br />RS,UM,OF,LE,AM</td><td>DEC zp,X<br />NF,RS,UM,OF,AM</td><td class="prefix">CMP [[zp]]<br />RS,UM,OF,LE,AM=1</td><td>CLD </td><td>CMP abs,Y<br />RS,UM,OF,LE,AM</td><td class="cmos">PHX <br />RS,UM</td><td class="prefix">prefix2</td><td class="c65k">JSR (abs)<br />RS,UM,OF,AM</td><td>CMP abs,X<br />RS,UM,OF,LE,AM</td><td>DEC abs,X<br />NF,RS,UM,OF,AM</td><td class="c65k">DEC abs,Y<br />NF,RS,UM,OF,AM</td></tr>
<tr><th>E</th><td>CPX #byte<br />RS,LE</td><td>SBC (zp,X)<br />NF,RS,UM,OF,LE,AM</td><td class="c65k">STA (abs,X)<br />RS,UM,OF,AM</td><td class="prefix">SBC [[zp,X]]<br />NF,RS,UM,OF,LE,AM=1</td><td>CPX zp<br />RS,UM,OF,LE,AM</td><td>SBC zp<br />NF,RS,UM,OF,LE,AM</td><td>INC zp<br />NF,RS,UM,OF,AM</td><td class="prefix">STA [[abs,X]]<br />RS,UM,OF,AM=1</td><td>INX <br />NF,RS</td><td>SBC #byte<br />NF,RS,LE</td><td>NOP </td><td class="prefix">prefix2</td><td>CPX abs<br />RS,UM,OF,LE,AM</td><td>SBC abs<br />NF,RS,UM,OF,LE,AM</td><td>INC abs<br />NF,RS,UM,OF,AM</td><td class="prefix">reserved prefix</td></tr>
<tr><th>F</th><td>BEQ rel<br />RS</td><td>SBC (zp),Y<br />NF,RS,UM,OF,LE,AM</td><td class="cmos">SBC (zp)<br />NF,RS,UM,OF,LE,AM</td><td class="prefix">SBC [[zp]],Y<br />NF,RS,UM,OF,LE,AM=1</td><td class="c65k">TRP #byte</td><td>SBC zp,X<br />NF,RS,UM,OF,LE,AM</td><td>INC zp,X<br />NF,RS,UM,OF,AM</td><td class="prefix">SBC [[zp]]<br />NF,RS,UM,OF,LE,AM=1</td><td>SED </td><td>SBC abs,Y<br />NF,RS,UM,OF,LE,AM</td><td class="cmos">PLX <br />NF,RS,UM,LE</td><td class="prefix">prefix2</td><td class="c65k">JSR (abs,X)<br />RS,UM,OF,AM</td><td>SBC abs,X<br />NF,RS,UM,OF,LE,AM</td><td>INC abs,X<br />NF,RS,UM,OF,AM</td><td class="c65k">INC abs,Y<br />NF,RS,UM,OF,AM</td></tr>
</table>


	<p>
	The grey fields note opcodes that do not use any prefix bits.
	</p><p>
	Note that the Register size option for the RTS and JSR opcodes determine the size of the 
	return address as put on the stack (with the 8 bit register size option also mapping to the
	16 bit address width).
	</p><p>
	The Register size option for the branch opcodes determines the size of the relative address
	offset. For the BSR opcode this is in conflict with the size options for the address on 
	the stack. Therefore BSR is handled similar to JSR, in that RS determines the size of the
	return address on the stack, and AM modifies the relative offset from "rel" to "rellong"
	resp. from "relwide" to "relquad".
	</p><p>
	Note that the TRAP opcode is marked as using no prefix bits, but still written down in that
	table. This is for future extensions, when RS may be used to allow more than 256 trap codes.
	</p><p>
	The green cells are duplicate opcodes. These take the place of prefix1 <!--resp. some opcodes that
	do not use prefix flags (like CLC)--> and require at least one prefix bit set (AM in the current cases).
	These duplicate opcodes allow to extend an indirect opcode, more specifically to have more options
	for the size of the address stored at the indirect location. For a description see below.
	</p><p>
	The following sections describe the different options in mode detail:
	</p>
	<h3>Addressing Modes</h3>
	<p>The addressing modes bit AM allows to extend the existing addressing modes from zeropage (8 bit) and
	absolute (16 bit) to long (32 bit) and longlong (64 bit). The following table shows the
	modifications when AM is set.</p>
<table class="optable">
<tr><th>Original Addressing Mode</th><th>New Addressing Mode</th><th>Comment</th></tr>
<tr><td>zp</td><td>long</td><td>use a long (32 bit) address instead of a zeropage address</td></tr>
<tr><td>zp,X</td><td>long,X</td><td>use a long (32 bit) address instead of a zeropage address</td></tr>
<tr><td>zp,Y</td><td>long,Y</td><td>use a long (32 bit) address instead of a zeropage address</td></tr>
<tr><td>abs</td><td>longlong</td><td>use a longlong (64 bit) address instead of an absolute address</td></tr>
<tr><td>abs,X</td><td>longlong,X</td><td>use a longlong (64 bit) address instead of an absolute address</td></tr>
<tr><td>abs,Y</td><td>longlong,Y</td><td>use a longlong (64 bit) address instead of an absolute address</td></tr>
<tr><td>(zp)</td><td>[zp]</td><td>from the given zeropage location, read a long address instead of an absolute address</td></tr>
<tr><td>(zp),Y</td><td>[zp],Y</td><td>from the given zeropage location, read a long address instead of an absolute address, then add YR</td></tr>
<tr><td>(zp,X)</td><td>[zp,X]</td><td>from the given zeropage location (plus XR as given by the addressing mode), read a long address instead of an absolute address</td></tr>
<tr><td>(abs)</td><td>[abs]</td><td>from the given absolute location, read a long address instead of an absolute address</td></tr>
<tr><td>(abs),Y</td><td>[abs],Y</td><td>from the given absolute location, read a long address instead of an absolute address, then add YR</td></tr>
<tr><td>(abs,X)</td><td>[abs,X]</td><td>from the given absolute location (plus XR as given by the addressing mode), read a long address instead of an absolute address</td></tr>
<tr><td class="dup">(zp)</td><td>[[zp]]</td><td>from the given zeropage location, read a quad (longlong)  address instead of an absolute address</td></tr>
<tr><td class="dup">(zp),Y</td><td>[[zp]],Y</td><td>from the given zeropage location, read a quad (longlong) address instead of an absolute address, then add YR</td></tr>
<tr><td class="dup">(zp,X)</td><td>[[zp,X]]</td><td>from the given zeropage location (plus XR as given by the addressing mode), read a quad (longlong) address instead of an absolute address</td></tr>
<tr><td class="dup">(abs)</td><td>[[abs]]</td><td>from the given absolute location, read a quad (longlong) address instead of an absolute address</td></tr>
<tr><td class="dup">(abs),Y</td><td>[[abs]],Y</td><td>from the given absolute location, read a quad (longlong) address instead of an absolute address, then add YR</td></tr>
<tr><td class="dup">(abs,X)</td><td>[[abs,X]]</td><td>from the given absolute location (plus XR as given by the addressing mode), read a quad (longlong) address instead of an absolute address</td></tr>
<tr><td>imm</td><td>imm</td><td>unchanged</td></tr>
<tr><td>implied</td><td>implied</td><td>unchanged</td></tr>
<tr><td>rel</td><td>rellong</td><td>extend the relative offset from an 8 bit to a 32 bit value</td></tr>
<tr><td>relwide</td><td>relquad</td><td>extend the relative offset from a 16 bit to a 64 bit value</td></tr>
</table><p>
	Normally not all addressing modes would be supported with direct addressing mode replacements. 
	The quad (longlong) indirect addressing modes
	are not reached. Thus the indirect opcodes are mirrored, and extended from long to quad (longlong) indirect 
	addressing modes.
	Row LSB 1 is mirrored thus to row LSB 3, as well as row LSB 2 is mirrored to LSB 7.
	These values are marked with a green background in the table. The LSB 3 and 7 rows then change from
	indirect addressing modes to quad (longlong) indirect addressing modes.
	</p><p>
	Also note that there a are no indirect addressing modes that take a long or quad (longlong) value as indirect address.
	</p><p>
	TODO: JMP and JSR opcodes?
	</p>
	<h3>Offset</h3>
	<p>
	The offset prefix bits allows to add an address offset to the effective address of the operand.
	Four options are available:
	</p><table class="optable">
	<tr><th>OF1/0</th><th>Register</th><th>Register Name</th><th>Syntax</th><th>Examples</th></tr>
	<tr><td>00</td><td>-</td><td>no register value added</td><td>-</td><td>LDA $1234</td></tr>
	<tr><td>01</td><td>PC</td><td>Program Counter</td><td>Address prefix P,</td><td>LDA P,$1234; LDA (P,$12),Y</td></tr>
	<tr><td>10</td><td>SR</td><td>Stack Pointer</td><td>Address prefix S,</td><td>LDA S,$1234; LDA [S,$23,X]</td></tr>
	<tr><td>11</td><td>BR</td><td>Base Register</td><td>Address prefix B,</td><td>LDA B,$1234; LDA B,$12,X</td></tr>
	</table><p>
	For (non-indirect) zeropage/absolute and indexed addressing modes to compute the effective address
	the standard addressing mode effective address is computed, then the register value is added to get the
	final effective address.
	</p><p>
	For the indirect addressing mode that situation is more complex. The offset register value is added
	to the zeropage or absolute address given in the opcode, to compute the indirect address.
	For indexed with XR addressing modes XR is added to this address to get the real indirect address.
	Then the effective address is read from the computed indirect address, for indexed with YR then 
	the value of YR is added to the address read, to get the real effective address. Here the offset
	is not added again.
	</p><p>
	Note that the size of the address read from the indirect address is defined by the addressing mode
	alone (which is also determined by the AM prefix bit).
	</p>
	<h3>Register Size</h3>
	<p>
	The maximum register size depends on the used processor option. Each operation has a possibly smaller width.
	The Register size prefix defines the operation width. I.e. this determines the number of bytes to read from
	memory (from the effective address), the number of bytes to store to memory, or the number bytes to use
	from resp. store in a register.
	</p><p>
	The different width prefixes are written as postfixes to the opcode:
	</p>
	<table class="optable">
	<tr><th>RS1/0</th><th>width</th><th>Postfix</th><th>Example</th></tr>
	<tr><td>00</td><td>8</td><td></td><td>LDA #$12</td></tr>
	<tr><td>01</td><td>16</td><td>.W</td><td>LDA.W #$1234</td></tr>
	<tr><td>10</td><td>32</td><td>.L</td><td>LDA.L #$12345678</td></tr>
	<tr><td>11</td><td>64</td><td>.Q</td><td>LDA.Q #$123456789ABCDEF0</td></tr>
	</table><p>
	Please note that 8 bit width has no postfix.
	</p><p>
	TODO: rename to "OS" = "Operation size" or "OW" = "Operation width"?
	</p>
	<h3>Load Extension</h3>
	<p>
	The registers have a defined width - depending on processor option - of 16, 32 or 64 bit. Operations can be
	from 8 to 64 bit. 
	There are some use cases where some adaption of a value to the register size is practical. For example if 
	an 8-bit value is used on a 32-bit operation - like adding <code>#8</code> to an address register.
	</p><p>
	For this purpose the LE bits define how a value loaded from memory (or from another register in the case of the 
	Txy opcodes) is extended to full register size. Four options are available:</p>
	<table class="optable">
	<tr><th>LE1/0</th><th>Extension type</th><th>Postfix</th><th>Example</th><th>Description</th></tr>
	<tr><td rowspan="2">00</td><td rowspan="2">no extension</td><td></td><td>ADC #$92</td>
		<td>Adds $92 to AC in 8 bit operation, leaves upper bits untouched.
		Default for non-load/transfer operations.</td></tr>
	<tr><td>.E</td><td>LDY.E #$92</td><td>Loads $92 into YR, leaves upper bits untouched.</td></tr>
	<tr><td>01</td><td>sign-extension</td><td>.S</td><td>ADC.S #$92</td><td>Because the sign of $92 is 1, this 
		adds $ffffffffffffff92 to AC with a 64 bit operation, truncated to actual processor width.</td></tr>
	<tr><td rowspan="2">10</td><td rowspan="2">zero-extension</td><td>.0</td><td>ADC.0 #$92</td><td>Extends with zeros and
		adds $0000000000000092 to AC in a 64 bit operation, truncated to actual AC width. 	
		</td></tr>
	<tr><td></td><td>LDY #$92</td><td>Extends with zeros and
		loads $0000000000000092 into a 64 bit YR, truncated to actual processor width.
		Default for loads and transfer operations</td></tr>
	<tr><td>11</td><td>ones-extension</td><td>.1</td><td>ADC.1 #$92</td><td>Extends with ones and
		adds $ffffffffffffff92 to AC in a 64 bit operation, truncated to actual processor width.</td></tr>
	</table>
	<p>
	When the result of an operation is written to a memory location or register, the data is written
	in the same width as the operation.
	</p><p>
	Using this extension - i.e. having a value of not 00 - modifies the meaning of the RS prefix. RS then actually 
	defines the width of the memory location to be read. The actual operation happens after loading the value,
	and it happens at full width. 
	For operations other than loads, the flags are set appropriately from the 
	full width operation result value. For loads (LDA, LDX, LDY) and transfers (TAX, ...), however, 
	the flags are set from the RS-width value that is read from memory (note: if you need flags from
	the full width value, use BIT A, but in general you should know the outcome of the extension of a load opcode).
	</p><p>
	There is another difference between loads/transfers and other operations. Loads and transfers do a zero-extension
	by default, while other opcodes do not extend. To change the load/transfer default behaviour, use an explicit LE prefix
	of 00. The assembler should take care to create the correct prefix when using another prefix bit in prefix2.
	For example doing a LDA.U should automatically be set to LDA.U0.
	</p><p>
	This somewhat inconsistent behaviour between loads/stores and others implements a "least surprise" strategy 
	for loads. X and Y are always used full-width in address calculation. Doing an LDY #0 would not clear all bits
	and depending what previously executed code left in those bits this leads to unexpected behaviour. 
	Even with the extension, however, the flags need to be set from the width that has been read - in general 8 bits,
	to be compatible with 6502 code.
	</p><p>
	So when loading a register, the upper bits are filled with zero by default - but flags are set
	from the original width (as defined by RS). To load AC with the lower bits only, explicitely
	set the prefix with LE0=LE1=0 (using the postfix .E). This would normally denote the original 6502 
	behaviour and could thus be left out, but not in this case as the default - for loads/transfers - is not the 
	6502 behaviour, yet compatible.
    	</p>
	<h3>User Mode selector</h3>
	<p>
	Normally the opcode uses the current processor mode - user or hypervisor - to compute the correct address.
	For the supervisor mode there is an option, however, to use an address from user mode as operand.
	This is what the User Mode selector bit (UM) is for.
	</p><p>
	When the User Mode selector is set, the operand following the opcode is read from the current (hypervisor mode)
	memory environment (as defined by the matchcode). Then the processor temporarily switches to user mode, 
	using the user mode matchcode and usermode stack pointer. For non-indirect addressing modes then the operand
	is written to or read from the computed address. For indirect addressing modes the indirect address is
	read from user mode, then the actual operand is read from or written to user mode as well.
	</p><p>
	Note that this bit is a privileged operation - unavailable if no hypervisor mode option is present, and 
	trapping into an abort if executed in user mode.
	</p><p>
	With the user mode selector such operations as PHA or PLX etc can be easily redirected to the user space
	stack.
	</p>
	<h3><a name="ovquick" id="ovquick">Quick Opcodes</a></h3><p>These opcodes are defined by the "QUICK prefix" byte, being followed by an additional opcode byte.
	These opcodes may still even be modified by the prefix1 and prefix2 opcodes though!
	</p><p>
	The QUICK opcodes provide a way to "quickly" do repetitive operations which require multiple opcodes on the 
	6502 - like INY with an increment larger than one for example.
	</p><p>
	The following table describes the opcodes:</p>
<table class="optable">
<tr><th>LSB-&gt;<br />MSB\</th><th>0</th>	<th>1</th>		<th>2</th>		<th>3</th>		<th>4</th>		<th>5</th>		<th>6</th>		<th>7</th>		<th>8</th>		<th>9</th>		<th>A</th>		<th>B</th>		<th>C</th>		<th>D</th>		<th>E</th>	<th>F</th></tr>
<tr><th>0</th>		<td>INY #1</td>		<td>INX #1</td>		<td>INC A #1</td>	<td>ROL A #1</td>	<td>ASL A #1</td>	<td>RDL A #1</td>	<td>INC #1, (E)</td>	<td>ROL #1, (E)</td>	<td>RDL #1 (E)</td>	<td>ASL #1, (E)</td>	<td>SLX #1</td>		<td>SLY #1</td>		<td>ASR A #1</td>	<td>INC #1, zp</td>		<td>ROL #1, zp</td>	<td>ASL #1, zp</td></tr>
<tr><th>1</th>		<td>INY #2</td>		<td>INX #2</td>		<td>INC A #2</td>	<td>ROL A #2</td>	<td>ASL A #2</td>	<td>RDL A #2</td>	<td>INC #2, (E)</td>	<td>ROL #2, (E)</td>	<td>RDL #2 (E)</td>	<td>ASL #2, (E)</td>	<td>SLX #2</td>		<td>SLY #2</td>		<td>ASR A #2</td>	<td>INC #1, zp</td>		<td>ROL #2, zp</td>	<td>ASL #2, zp</td></tr>
<tr><th>2</th>		<td>INY #3</td>		<td>INX #3</td>		<td>INC A #3</td>	<td>ROL A #3</td>	<td>ASL A #3</td>	<td>RDL A #3</td>	<td>INC #3, (E)</td>	<td>ROL #3, (E)</td>	<td>RDL #3 (E)</td>	<td>ASL #3, (E)</td>	<td>SLX #3</td>		<td>SLY #3</td>		<td>ASR A #3</td>	<td>INC #1, zp</td>		<td>ROL #3, zp</td>	<td>ASL #3, zp</td></tr>
<tr><th>3</th>		<td>INY #4</td>		<td>INX #4</td>		<td>INC A #4</td>	<td>ROL A #4</td>	<td>ASL A #4</td>	<td>RDL A #4</td>	<td>INC #4, (E)</td>	<td>ROL #4, (E)</td>	<td>RDL #4 (E)</td>	<td>ASL #4, (E)</td>	<td>SLX #4</td>		<td>SLY #4</td>		<td>ASR A #4</td>	<td>INC #1, zp</td>		<td>ROL #4, zp</td>	<td>ASL #4, zp</td></tr>
<tr><th>4</th>		<td>INY #5</td>		<td>INX #5</td>		<td>INC A #5</td>	<td>ROL A #5</td>	<td>ASL A #5</td>	<td>RDL A #5</td>	<td>INC #5, (E)</td>	<td>ROL #5, (E)</td>	<td>RDL #5 (E)</td>	<td>ASL #5, (E)</td>	<td>SLX #5</td>		<td>SLY #5</td>		<td>ASR A #5</td>	<td>INC #1, zp</td>		<td>ROL #5, zp</td>	<td>ASL #5, zp</td></tr>
<tr><th>5</th>		<td>INY #6</td>		<td>INX #6</td>		<td>INC A #6</td>	<td>ROL A #6</td>	<td>ASL A #6</td>	<td>RDL A #6</td>	<td>INC #6, (E)</td>	<td>ROL #6, (E)</td>	<td>RDL #6 (E)</td>	<td>ASL #6, (E)</td>	<td>SLX #6</td>		<td>SLY #6</td>		<td>ASR A #6</td>	<td>INC #1, zp</td>		<td>ROL #6, zp</td>	<td>ASL #6, zp</td></tr>
<tr><th>6</th>		<td>INY #7</td>		<td>INX #7</td>		<td>INC A #7</td>	<td>ROL A #7</td>	<td>ASL A #7</td>	<td>RDL A #7</td>	<td>INC #7, (E)</td>	<td>ROL #7, (E)</td>	<td>RDL #7 (E)</td>	<td>ASL #7, (E)</td>	<td>SLX #7</td>		<td>SLY #7</td>		<td>ASR A #7</td>	<td>INC #1, zp</td>		<td>ROL #7, zp</td>	<td>ASL #7, zp</td></tr>
<tr><th>7</th>		<td>INY #8</td>		<td>INX #8</td>		<td>INC A #8</td>	<td>ROL A #8</td>	<td>ASL A #8</td>	<td>RDL A #8</td>	<td>INC #8, (E)</td>	<td>ROL #8, (E)</td>	<td>RDL #8 (E)</td>	<td>ASL #8, (E)</td>	<td>SLX #8</td>		<td>SLY #8</td>		<td>ASR A #8</td>	<td>INC #1, zp</td>		<td>ROL #8, zp</td>	<td>ASL #8, zp</td></tr>
<tr><th>8</th>		<td>DEY #1</td>		<td>DEX #1</td>		<td>DEC A #1</td>	<td>ROR A #1</td>	<td>LSR A #1</td>	<td>RDR A #1</td>	<td>DEC #1, (E)</td>	<td>ROR #1, (E)</td>	<td>RDR #1 (E)</td>	<td>LSR #1, (E)</td>	<td>SRX #1</td>		<td>SRY #1</td>		<td>ASR #1, (E)</td>	<td>DEC #1, zp</td>		<td>ROR #1, zp</td>	<td>LSR #1, zp</td></tr>
<tr><th>9</th>		<td>DEY #2</td>		<td>DEX #2</td>		<td>DEC A #2</td>	<td>ROR A #2</td>	<td>LSR A #2</td>	<td>RDR A #2</td>	<td>DEC #2, (E)</td>	<td>ROR #2, (E)</td>	<td>RDR #2 (E)</td>	<td>LSR #2, (E)</td>	<td>SRX #2</td>		<td>SRY #2</td>		<td>ASR #2, (E)</td>	<td>DEC #1, zp</td>		<td>ROR #2, zp</td>	<td>LSR #2, zp</td></tr>
<tr><th>A</th>		<td>DEY #3</td>		<td>DEX #3</td>		<td>DEC A #3</td>	<td>ROR A #3</td>	<td>LSR A #3</td>	<td>RDR A #3</td>	<td>DEC #3, (E)</td>	<td>ROR #3, (E)</td>	<td>RDR #3 (E)</td>	<td>LSR #3, (E)</td>	<td>SRX #3</td>		<td>SRY #3</td>		<td>ASR #3, (E)</td>	<td>DEC #1, zp</td>		<td>ROR #3, zp</td>	<td>LSR #3, zp</td></tr>
<tr><th>B</th>		<td>DEY #4</td>		<td>DEX #4</td>		<td>DEC A #4</td>	<td>ROR A #4</td>	<td>LSR A #4</td>	<td>RDR A #4</td>	<td>DEC #4, (E)</td>	<td>ROR #4, (E)</td>	<td>RDR #4 (E)</td>	<td>LSR #4, (E)</td>	<td>SRX #4</td>		<td>SRY #4</td>		<td>ASR #4, (E)</td>	<td>DEC #1, zp</td>		<td>ROR #4, zp</td>	<td>LSR #4, zp</td></tr>
<tr><th>C</th>		<td>DEY #5</td>		<td>DEX #5</td>		<td>DEC A #5</td>	<td>ROR A #5</td>	<td>LSR A #5</td>	<td>RDR A #5</td>	<td>DEC #5, (E)</td>	<td>ROR #5, (E)</td>	<td>RDR #5 (E)</td>	<td>LSR #5, (E)</td>	<td>SRX #5</td>		<td>SRY #5</td>		<td>ASR #5, (E)</td>	<td>DEC #1, zp</td>		<td>ROR #5, zp</td>	<td>LSR #5, zp</td></tr>
<tr><th>D</th>		<td>DEY #6</td>		<td>DEX #6</td>		<td>DEC A #6</td>	<td>ROR A #6</td>	<td>LSR A #6</td>	<td>RDR A #6</td>	<td>DEC #6, (E)</td>	<td>ROR #6, (E)</td>	<td>RDR #6 (E)</td>	<td>LSR #6, (E)</td>	<td>SRX #6</td>		<td>SRY #6</td>		<td>ASR #6, (E)</td>	<td>DEC #1, zp</td>		<td>ROR #6, zp</td>	<td>LSR #6, zp</td></tr>
<tr><th>E</th>		<td>DEY #7</td>		<td>DEX #7</td>		<td>DEC A #7</td>	<td>ROR A #7</td>	<td>LSR A #7</td>	<td>RDR A #7</td>	<td>DEC #7, (E)</td>	<td>ROR #7, (E)</td>	<td>RDR #7 (E)</td>	<td>LSR #7, (E)</td>	<td>SRX #7</td>		<td>SRY #7</td>		<td>ASR #7, (E)</td>	<td>DEC #1, zp</td>		<td>ROR #7, zp</td>	<td>LSR #7, zp</td></tr>
<tr><th>F</th>		<td>DEY #8</td>		<td>DEX #8</td>		<td>DEC A #8</td>	<td>ROR A #8</td>	<td>LSR A #8</td>	<td>RDR A #8</td>	<td>DEC #8, (E)</td>	<td>ROR #8, (E)</td>	<td>RDR #8 (E)</td>	<td>LSR #8, (E)</td>	<td>SRX #8</td>		<td>SRY #8</td>		<td>ASR #8, (E)</td>	<td>DEC #1, zp</td>		<td>ROR #8, zp</td>	<td>LSR #8, zp</td></tr>
</table>
	<p>Here is the description of the new opcodes:</p>
	<ul>
	<li>ASR	- Arithmetic Shift Right - shift right and shift in the sign of the original value from the highest bit</li>
	<li>RDR - Rotate Direct Right - shift right, but without using the carry flag (only setting it)</li>
	<li>RDL - Rotate Direct Left - shift left, but without using the carry flag (only setting it)</li>
	<li>SLX - shift left X by 1 to 8 bit, similar to ASL</li>
	<li>SRX - right left X by 1 to 8 bit, similar to ASL</li>
	<li>SLY - shift left Y by 1 to 8 bit, similar to LSR</li>
	<li>SRY - right left Y by 1 to 8 bit, similar to LSR</li>
	</ul>
	<p>Note that the zp, and (E) addressing modes can be modified by the UM prefix bit, Y,X and AC related opcodes
	can be modified by the RS prefix. LE is not applicable as these opcodes are read-modify-write operations.
	All opcodes can be modified by the NF prefix.
	</p>
  	<p>These have been deprecated as they are redundant to ADE/SBE/ADB/SBB:</p>
	<ul>
	<li>INE - increment E register by values 1 to 8</li>
	<li>DEE - decrement E register by values 1 to 8</li>
	<li>INB - increment B register by values 1 to 8</li>
	<li>DEB - increment B register by values 1 to 8</li>
	</ul>
  	<h3><a name="ovfp" id="ovfp">EXT opcodes</a></h3><p>These opcodes extend the opcode space with rarely used, but still useful general purpose
	opcodes.
	</p>



<table class="optable"><tr><th>LSB-&gt;<br />MSB</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr>
<tr><th>0</th><td class="unused"></td><td class="unused"></td><td>LEA zp,Y<br />NF,UM,OF,AM</td><td class="unused"></td><td>MVN </td><td class="unused"></td><td>ASR zp<br />NF,RS,UM,OF,AM</td><td class="unused"></td><td>PHE <br />UM</td><td>ORA (E)<br />NF,RS,UM,LE</td><td>ASR <br />NF,RS</td><td class="unused"></td><td>TSB (E)<br />NF,RS,UM</td><td>ASL (E)<br />NF,RS,UM</td><td>ASR abs<br />NF,RS,UM,OF,AM</td><td class="unused"></td></tr>
<tr><th>1</th><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td>MVP </td><td class="unused"></td><td>ASR zp,X<br />NF,RS,UM,OF,AM</td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td>TRB (E)<br />NF,RS,UM</td><td>ASR (E)<br />NF,RS,UM</td><td>ASR abs,X<br />NF,RS,UM,OF,AM</td><td>ASR abs,Y<br />NF,RS,UM,OF,AM</td></tr>
<tr><th>2</th><td>JSR (E)<br />RS,UM</td><td class="unused"></td><td>PEA zp,Y<br />UM,OF,AM</td><td class="unused"></td><td>FIL <br />RS</td><td>ADE #byte<br />NF,RS,LE</td><td>RDL zp<br />NF,RS,UM,OF,AM</td><td class="unused"></td><td>PLE <br />NF,UM</td><td>AND (E)<br />NF,RS,UM,LE</td><td>RDL <br />NF,RS</td><td class="unused"></td><td class="unused"></td><td>ROL (E)<br />NF,RS,UM</td><td>RDL abs<br />NF,RS,UM,OF,AM</td><td class="unused"></td></tr>
<tr><th>3</th><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td>BIT <br />NF,RS</td><td>ADE <br />NF,RS</td><td>RDL zp,X<br />NF,RS,UM,OF,AM</td><td class="unused"></td><td class="unused"></td><td>LDE #byte<br />NF,RS,LE</td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td>RDL (E)<br />NF,RS,UM</td><td>RDL abs,X<br />NF,RS,UM,OF,AM</td><td>RDL abs,Y<br />NF,RS,UM,OF,AM</td></tr>
<tr><th>4</th><td class="unused"></td><td class="unused"></td><td>LEA (abs),Y<br />NF,UM,OF,AM</td><td class="unused"></td><td>LEA relwide<br />NF,UM,OF,AM</td><td>ADS #byte<br />NF,RS,LE</td><td class="unused"></td><td class="unused"></td><td>PHB <br />UM</td><td>EOR (E)<br />NF,RS,UM,LE</td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td>LSR (E)<br />NF,RS,UM</td><td class="unused"></td><td class="unused"></td></tr>
<tr><th>5</th><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td>PEA relwide<br />UM,OF,AM</td><td>ADS <br />NF,RS</td><td class="unused"></td><td class="unused"></td><td>PRB <br />NF,UM</td><td>LDB #byte<br />NF,RS,LE</td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td></tr>
<tr><th>6</th><td class="unused"></td><td class="unused"></td><td>LEA (abs,X)<br />NF,UM,OF,AM</td><td class="unused"></td><td>RMB <br />UM</td><td>ADB #byte<br />NF,RS,LE</td><td>RDR zp<br />NF,RS,UM,OF,AM</td><td class="unused"></td><td>PLB <br />NF,UM</td><td>ADC (E)<br />NF,RS,UM,LE</td><td>RDR <br />NF,RS</td><td class="unused"></td><td class="unused"></td><td>ROR (E)<br />NF,RS,UM</td><td>RDR abs<br />NF,RS,UM,OF,AM</td><td class="unused"></td></tr>
<tr><th>7</th><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td>WMB <br />UM</td><td>ADB <br />NF,RS</td><td>RDR zp,X<br />NF,RS,UM,OF,AM</td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td>RDR (E)<br />NF,RS,UM</td><td>RDR abs,X<br />NF,RS,UM,OF,AM</td><td>RDR abs,Y<br />NF,RS,UM,OF,AM</td></tr>
<tr><th>8</th><td>LEA rel<br />NF,UM,OF,AM</td><td>PEA (zp,X)<br />UM,OF,AM</td><td>PEA rel<br />UM,OF,AM</td><td class="unused"></td><td>SCA (E)<br />RS,UM</td><td>PEA zp<br />UM,OF,AM</td><td>LEA zp<br />NF,UM,OF,AM</td><td class="unused"></td><td>TAE <br />NF,RS,LE</td><td>BIT (E)<br />NF,RS,UM,LE</td><td>TYS <br />RS,UM,LE</td><td class="unused"></td><td>STY (E)<br />RS,UM</td><td>STA (E)<br />RS,UM</td><td>STX (E)<br />RS,UM</td><td class="unused"></td></tr>
<tr><th>9</th><td class="unused"></td><td>PEA (zp),Y<br />UM,OF,AM</td><td>PEA (zp)<br />UM,OF,AM</td><td class="unused"></td><td>LLA (E)<br />NF,RS,UM,LE</td><td>PEA zp,X<br />UM,OF,AM</td><td>LEA zp,X<br />NF,UM,OF,AM</td><td class="unused"></td><td>TEA <br />NF</td><td>PEA abs,Y<br />UM,OF,AM</td><td>SXY </td><td class="unused"></td><td>STZ (E)<br />RS,UM</td><td class="unused"></td><td>STZ abs,Y<br />RS,UM,OF,AM</td><td class="unused"></td></tr>
<tr><th>A</th><td>LDY (E)<br />NF,RS,UM,LE</td><td>LEA (zp,X)<br />NF,UM,OF,AM</td><td>LDX (E)<br />NF,RS,UM,LE</td><td class="unused"></td><td>INV <br />NF,RS,LE</td><td>SBE #byte<br />NF,RS,LE</td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td>LDA (E)<br />NF,RS,UM,LE</td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td>PEA abs<br />UM,OF,AM</td><td>LEA abs<br />NF,UM,OF,AM</td><td class="unused"></td></tr>
<tr><th>B</th><td class="unused"></td><td>LEA (zp),Y<br />NF,UM,OF,AM</td><td>LEA (zp)<br />NF,UM,OF,AM</td><td class="unused"></td><td>BCN <br />NF,RS</td><td>SBE <br />NF,RS</td><td class="unused"></td><td class="unused"></td><td>SEB </td><td>LEA abs,Y<br />NF,UM,OF,AM</td><td>SAX </td><td class="unused"></td><td>BCN (E)<br />NF,RS</td><td>PEA abs,X<br />UM,OF,AM</td><td>LEA abs,X<br />NF,UM,OF,AM</td><td class="unused"></td></tr>
<tr><th>C</th><td>CPY (E)<br />RS,UM,LE</td><td class="unused"></td><td>PEA (abs),Y<br />UM,OF,AM</td><td class="unused"></td><td>EXT <br />NF,RS,LE</td><td>SBS #byte<br />NF,RS,LE</td><td class="unused"></td><td class="unused"></td><td>TPA <br />NF</td><td>CMP (E)<br />RS,UM,LE</td><td>TSY <br />NF,RS,UM,LE</td><td class="unused"></td><td class="unused"></td><td>DEC (E)<br />NF,RS,UM</td><td class="unused"></td><td class="unused"></td></tr>
<tr><th>D</th><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td>SWP <br />NF,RS</td><td>SBS <br />NF,RS</td><td class="unused"></td><td class="unused"></td><td>SAE </td><td class="unused"></td><td>SAY </td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td></tr>
<tr><th>E</th><td>CPX (E)<br />RS,UM,LE</td><td class="unused"></td><td>PEA (abs,X)<br />UM,OF,AM</td><td class="unused"></td><td>RMB (E)<br />UM</td><td>SBB #byte<br />NF,RS,LE</td><td class="unused"></td><td class="unused"></td><td>TAB <br />NF,RS,LE</td><td>SBC (E)<br />NF,RS,UM,LE</td><td>TEB <br />NF,RS,LE</td><td class="unused"></td><td class="unused"></td><td>INC (E)<br />NF,RS,UM</td><td class="unused"></td><td class="unused"></td></tr>
<tr><th>F</th><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td>WMB (E)<br />UM</td><td>SBB <br />NF,RS</td><td class="unused"></td><td class="unused"></td><td>TBA <br />NF</td><td class="unused"></td><td>TBE <br />NF,RS,LE</td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td><td class="unused"></td></tr>
</table>

    
	<p>Note that including the prefix bytes an opcode may be four bytes long (prefix1, prefix2, EXT prefix, and opcode). 
	</p><p>
	Here are short explanations of the new opcodes:</p>

<ul>
<li>
ADB: Add value to B register</li>
<li>
ADE: Add value to E register</li>
<li>
ADS: Add value to stack pointer</li>
<li>
ASR: Arithmetic Shift Right - Similar to LSR, but shifts in the sign of the value, not zero</li>
<li>
BCN: Bit Count: counts 1-bits in AC or in given location, stores number of 1-bits back in AC</li>
<li>
EXT: Extend a value in AC from RS to the full size. Setting LE defines the type of extension.</li>
<li>
FIL: Fill a memory area of size AC at address XR with a value from YR</li>
<li>
INV: invert AC, i.e. set AC to the 2s-complement of AC</li>
<li>
LDB: Load B with an immediate value</li>
<li>
LDE: Load E with an immediate value</li>
<li>
LEA: Load Effective Address: compute the effective address and store it in the E (effective Address) register (always full width)</li>
<li>
LLA: Load linked AC - load the content from a memory location into accumulator, optimistic-locking the address for SCA</li>
<li>
MVN: Move block of data of size AC from XR to YR, count addresses down. All registers full size, interruptable</li>
<li>
MVP: Move block of data of size AC from XR to YR, count addresses down. All registers full size, interruptable</li>
<li>
PEA: Push Effective Address: compute the effective address and push it onto the stack (always full width)</li>
<li>
PHB: Push B onto stack (full width)</li>
<li>
PHE: Push E onto stack (always full width)</li>
<li>
PLB: Pull E from stack (full width)</li>
<li>
PLE: Pull E from stack (full width)</li>
<li>
PRB: Push and Replace Base register: Push base offset register to the stack, then transfer accumulator to the base register</li>
<li>
RDL: Rotate Direct Left - similar to ROL, but do not shift in carry, but the highest bit of the original value</li>
<li>
RMB: Read memory barrier: invalidates cache content (globally, or for a specific, given location)</li>
<li>
SAE: Swap AC with E register. Always done full width, no flags set.</li>
<li>
SAX: Swap AC with X register. Always done full width, no flags set.</li>
<li>
SAY: Swap AC with Y register. Always done full width, no flags set.</li>
<li>
SBB: Substract value from B register</li>
<li>
SBE: Add value to E register</li>
<li>
SBS: Substract value from stack pointer</li>
<li>
SCA: Store conditional - store the contents of AC into a memory location, if location has not been accessed since 
			LLA with same address (and no other LLA in same thread)</li>
<li>
SEB: Swap E register with B register. Always done full width, no flags set.</li>
<li>
STZ: Store zero into a memory location</li>
<li>
SWP: swap upper and lower part nibble / byte / word / long word of a byte / word / long / quad (longlong) operand in Accumulator</li>
<li>
SXY: Swap X with Y register. Always done full width, no flags set.</li>
<li>
TAB: Transfer AC to B register</li>
<li>
TAE: Transfer AC to E register</li>
<li>
TBA: Transfer base register B to Accumulator</li>
<li>
TBE: Transfer content of B register into E register.</li>
<li>
TEA: Transfer E register to Accumulator</li>
<li>
TEB: Transfer E to B register.</li>
<li>
TPA: Transfer Program counter to Accumulator</li>
<li>
TRB: Test and Reset Bit - AND the memory location with the accumulator, and set the Z flag from the result, then CLEAR all bits in the
				memory location that are set in the accumulator.</li>
<li>
TSB: Test and Set Bit - AND the memory location with the accumulator, and set the Z flag from the result, then SET all bits in the
				memory location that are set in the accumulator.</li>
<li>
TSY: Transfer stack pointer to Y</li>
<li>
TYS: Transfer Y to stack pointer</li>
<li>
WMB: Write memory barrier: flushes dirty caches (globally, or for a specific, given location)</li>
</ul>


	<p>Note that these have already been deprecated:</p>
	<ul>
	<li>PKA - peek stack: read value from stack into AC without modifying the stack pointer - replaced with the standard LDA S,$01</li>
	<li>PKX - peek stack: read value from stack into X without modifying the stack pointer - replaced with the standard LDX S,$01</li>
	<li>PKY - peek stack: read value from stack into Y without modifying the stack pointer - replaced with the standard LDY S,$01</li>
	<li>CLX, CLY - clear X, Y: replaced with standard LDX #$00, with same byte count now that X/Y loads are zero-extended</li>
	<li>CUT - cut the register from full size to RS, extending the upper bits (from the RS sized bits) using LE - same as EXT!</li>
	<li>CLA - clear accumulator (full width only) - replace with LDA #0, see CLX/CLY</li>
	</ul>
	<p>TODO: Mult/Div opcodes</p>
	<h3><a name="ovsys" id="ovsys">SYS opcodes</a></h3><p>This section gives an overview over the system opcodes that handle system
	configuration registers etc. These opcodes are all privileged.
	</p>
<table class="optable">
<tr><th>LSB-&gt;<br />MSB\</th><th>0</th><th>1</th>	<th>2</th>	<th>3</th>	<th>4</th>			<th>5</th>			<th>6</th>	<th>7</th>	<th>8</th>	<th>9</th>	<th>A</th>	<th>B</th>	<th>C</th>		<th>D</th>	<th>E</th>	<th>F</th></tr>
<tr><th>0</th>		<td></td>	<td>LCR imm</td><td></td>	<td></td>	<td>SENV zp</td>		<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>
<tr><th>1</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td>SENV zp, (E)</td>		<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>	
<tr><th>2</th>		<td></td>	<td>SCR imm</td><td></td>	<td></td>	<td></td>			<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>
<tr><th>3</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>			<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>
<tr><th>4</th>		<td></td>	<td>BCR imm</td><td></td>	<td></td> 	<td>SMMU</td>			<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td>JPU abs<br />OF,AM</td><td></td>	<td></td>	<td></td></tr>
<tr><th>5</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>			<td>CLEIM</td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>
<tr><th>6</th>		<td>RTU</td>	<td></td>	<td></td>	<td></td>	<td></td>			<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td>JPU (abs)<br />OF,AM</td><td></td>	<td></td>	<td></td></tr>
<tr><th>7</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td>FILU</td>			<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>
<tr><th>8</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>			<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>
<tr><th>9</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td>MVNTU</td>			<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>
<tr><th>A</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>			<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>
<tr><th>B</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td>MVPFU</td>			<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>
<tr><th>C</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>			<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>
<tr><th>D</th>		<td></td>	<td>WAI</td>	<td></td>	<td></td>	<td>MVNTU</td>			<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>
<tr><th>E</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>			<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>
<tr><th>F</th>		<td></td>	<td>STP</td>	<td></td>	<td></td>	<td>MVPTU</td>			<td></td>			<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>		<td></td>	<td></td>	<td></td></tr>
</table><p>Here is a short explanation of the new opcodes</p>
	<ul>
	<li>LCR - Load value from configuration register into AC. The immediate value gives the register number.</li>
	<li>SCR - Store value from AC to configuration register. The immediate value gives the register number.</li>
	<li>BCR - BIT value from AC with configuration register. The immediate value gives the register number.</li>
	<li>JPU - Jump to user space. Read parameter, then go from hypervisor to user mode, 
			then read the effective address from the
			user mode address space (for abs indirect mode) and execute the jump</li>
	<li>RTU - return to user space from a Trap opcode: go to user mode, pull return address from user mode
			stack and execute RTS</li>
	<li>SENV - the byte operand determines the environment number, first variant: AC, XR and YR determine the 
			address mask, address value and address offset registers. Second variant: the byte operand
			determines the environment number, E gives the memory address of the address mask, value and offset</li>
	<li>CLEIM - Clear EIM: load EIM bits from IMR bits; start interrupt if ISR bits have higher interrupt than EIM</li>
	<li>SMMU - Set the MMU base configuration address (to be defined)</li>
	<li>MVNTU - MVN but target is in user space</li>
	<li>MVNFU - MVN but source is in user space</li>
	<li>MVPTU - MVP but target is in user space</li>
	<li>MVPFU - MVP but source is in user space</li>
	<li>FILU - Fill user space area (i.e. use user mode match code)</li>
	<li>STP - Stop current core until reset (core 0) resp. enabling via core control register.</li>
	<li>WAI - Wait for interrupt - stops execution of current core until next interrupt</li>
	</ul><p>
	Note: these have been deprecated:</p>
	<ul>
	<li>TAI - transfer accumulator to interrupt base register (deprecated, replaced by LCR/SCR)</li>
	<li>TIA - transfer interrupt base register to accumulator (deprecated, replaced by LCR/SCR)</li>
	<li>TAT - transfer accumulator to trap vector base register (deprecated, replaced by LCR/SCR)</li>
	<li>TTA - transfer trap vector base register to accumulator (deprecated, replaced by LCR/SCR)</li>
	<li>TAU - transfer accumulator to user space stack pointer -- deprecated, replaced by TXS.U and TXS.U</li>
	<li>TUA - transfer user space stack pointer to accumulator -- deprecated, replaced by TXS.U and TXS.U</li>
	<li>SHM - Set Hypervisor Match register: Store accumulator into hypervisor mode match register (deprecated, replaced by LCR/SCR)</li>
	<li>SUM - Set User mode Match register: Store accumulator into user mode match register (deprecated, replaced by LCR/SCR)</li>
	<li>LHM - Load Hypervisor Match register: Load accumulator from hypervisor mode match register (deprecated, replaced by LCR/SCR)</li>
	<li>LUM - Load User mode Match register: Load accumulator from user mode match register (deprecated, replaced by LCR/SCR)</li>
	<li>LDA SR - Load AC from status register (can do 8 or 16 bit) (deprecated, replaced by LCR/SCR)</li>
	<li>LDA ISR - Load AC from interrupt status register (can do 8 bit) (deprecated, replaced by LCR/SCR)</li>
	<li>BIT ISR - Test interrupt status register (can do 8 bit) (deprecated, replaced by BCR)</li>
	<li>AND/ORA/EOR/BIT SR - operations on the status register (can do 8, 16, or 24 (zero-extended 32) bit) (no replacement)</li>
	</ul>
	<p>
	The configuration value registers are basically constant values that the program can query from the
	processor. These values can then be used by the program to identify the processor, resp. adapt
	itself to the processor features present.
	The following processor configuration registers are defined (note narrow values are always zero-extended):</p>
<table border="1">
<tr><th>Register#</th><th>rw/ro</th><th>global/per core</th><th>Name</th><th>Width</th><th>Value</th></tr>
<tr><td>$00</td><td>ro</td><td>global</td><td>VENDOR</td><td>16 bit</td><td>Defines the vendor of the processor.
			Currently defined are:
			<table><tr><td>$AF</td><td>A. Fachat</td></tr></table></td></tr>
<tr><td>$01</td><td>ro</td><td>per core</td><td>MC_MYCORE</td><td>W bit</td><td>Number of the core executing the load</td></tr>
<tr><td>$02</td><td>ro</td><td>global</td><td>MC_NCORE</td><td>W bit</td><td>Number of cores</td></tr>
<tr><td>$03</td><td>ro</td><td>global</td><td>MC_ACTCORE</td><td>W bit</td><td>Bitmask of active cores, can be set to start cores and cleared to stop them (except the own core)</td></tr>

<tr><td>$10</td><td>ro</td><td>per core</td><td>ST_SR</td><td>16 bit</td><td>Status register</td></tr>
<tr><td>$11</td><td>rw</td><td>global</td><td>ST_IMR</td><td>8 bit</td><td>interrupt mask register</td></tr>
<tr><td>$12</td><td>ro</td><td>global</td><td>ST_ISR</td><td>8 bit</td><td>interrupt status register</td></tr>
<tr><td>$13</td><td>ro</td><td>global</td><td>ST_EIM</td><td>8 bit</td><td>effective interrupt mask register</td></tr>
<tr><td>$14</td><td>ro</td><td>per core</td><td>ST_SP</td><td>8 bit</td><td>stack pointer (hypervisor)</td></tr>
<tr><td>$15</td><td>ro</td><td>per core</td><td>ST_USP</td><td>8 bit</td><td>stack pointer (user mode)</td></tr>
<tr><td>$16</td><td>rw</td><td>per core</td><td>ST_MH</td><td>8 bit</td><td>match code (hypervisor)</td></tr>
<tr><td>$17</td><td>rw</td><td>per core</td><td>ST_MU</td><td>8 bit</td><td>match code (user mode)</td></tr>

<tr><td>$20</td><td>rw</td><td>global</td><td>ST_IV</td><td>W bit</td><td>Interrupt vector base register</td></tr>
<tr><td>$21</td><td>rw</td><td>global</td><td>ST_AV</td><td>W bit</td><td>Abort vector base register</td></tr>
<tr><td>$22</td><td>rw</td><td>global</td><td>ST_TV</td><td>W bit</td><td>Trap vector base register</td></tr>

<tr><td>$30</td><td>ro</td><td>global</td><td>MM_CONT</td><td>8 bit</td><td>Number of memory management containers</td></tr>
</table>
    	<h3><a name="ovfp" id="ovfp">FP opcodes</a></h3><p>
	Note: this section still needs to be worked out.
    	</p><h3><a name="ovmmu" id="ovmmu">Blitter opcodes</a></h3><p>
	Note: this section still needs to be worked out. It is not clear if the blitter opcodes
	could be a not implemented column in the SYS opcodes table. Blitter opcodes would be 
	privileged.
    	</p></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="sys" id="sys">System Environment</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><p>
	This section describes the general system environment
    </p><h3><a name="reset" id="reset">Reset</a></h3><p>
	Upon Reset the processor fetches a two-byte Reset vector from "-4".
	In a 16 bit processor option this translates to the original 6502's
	$FFFC reset vector.
	</p><p>
	In a system with a larger address bus, the address is sign-extended, i.e.
	the vector is either pulled from $FFFFFFFC or $FFFFFFFFFFFFFFFC.
	</p><p>
	The two-byte vector read from that address is then again sign-extended to
	compute the effective address to jump to.
	</p><p>
	Any address translation features if available are disabled on reset. I.e. the computed
	address(es) computed here are physical addresses. 
	</p><p>
	If a supervisor mode feature is available, the processor goes into supervisor mode.
	</p><p>
	Upon Reset the following vectors are used:
	</p>
	<table class="optable">
	<tr><th>Address:</th><th>Vector</th></tr>
	<tr><td>$FFFFFFFFFFFFFFFE/F</td><td>BRK/IRQ</td></tr>
	<tr><td>$FFFFFFFFFFFFFFFC/D</td><td>RESET</td></tr>
	<tr><td>$FFFFFFFFFFFFFFFA/B</td><td>NMI</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF8/9</td><td>ABORT</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF6/7</td><td>TRAP</td></tr>
	</table>
	<p>The IRQ vector folds all interrupts into one vector, the interrupt condition can be read from the
	EIM.</p>
	<p>Note that there is no way to determine the ABORT condition when not using the 
	abort vector table. The trap condition can be determined by reading the 
	program counter from the stack and reading the operand byte from there - but
	this is much more complicated than using the trap vector table (also this only
	works with a fixed width trap operand!)</p>
      <h3><a name="int" id="int">Interrupts</a></h3><p>
	The processor can have a number of interrupt lines. For each of the
	interrupt lines a separate interrupt vector can be used. I.e. interrupts
	are numbered, and the number is used as index in a table of interrupt vectors.
	The interrupt vectors are fetched from an address that is determined
	by the interrupt base register, IV.
	</p><p>
	The interrupt base register determines the address of a 256 byte 
	aligned block with interrupt vectors, i.e. the register's lowest 8 bit are unused.
	The interrupt vectors are counted up from the bottom of the block.
	</p><p>
	The interrupt vectors are (currently) always two byte, i.e. define only 
	a 16 bit address. The vector addresses are thus augmented with the 
	upper bytes of the interrupt vector register. I.e. the interrupt
	routines must be within the 64k space defined by the interrupt vector base
	register. If more space is needed, long jumps must be used.
	</p><p>
	Note: the lowest 8 bit of the vector base register are reserved and must be zero.
	In later versions these could be used to configure the vector size.
	</p><p>
	Upon reset the register is not used, instead the standard 6502 single interrupt
	vector is used at $FFFFFFFFFFFFFFFE. Only when the interrupt vector base register
	is set for the first time, the base register becomes active.
	</p>
	<table class="optable">
	<tr><th>Interrupt base:</th><th>$FFFFFFFFFFFFFF00</th></tr>
	<tr><td>$FFFFFFFFFFFFFF0E/F</td><td>Interrupt 7 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFF0C/D</td><td>Interrupt 6 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFF0A/B</td><td>Interrupt 5 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFF08/9</td><td>Interrupt 4 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFF06/7</td><td>Interrupt 3 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFF04/5</td><td>Interrupt 2 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFF02/3</td><td>Interrupt 1 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFF00/1</td><td>Interrupt 0 vector (NMI)</td></tr>
	</table>
	<p>
	The abort vector table works the same way as the interrupt vector base register.
	The abort vectors are assigned from top down though.
	</p>
	<table class="optable">
	<tr><th>Abort base:</th><th>$FFFFFFFFFFFFFF00</th></tr>
	<tr><td>$FFFFFFFFFFFFFFFE/F</td><td>BRK vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFFC/D</td><td>Reset vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFFA/B</td><td>Abort NOMEM</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF8/9</td><td>Abort WPROT</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF6/7</td><td>Abort NOEXEC</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF4/5</td><td>Abort PRIVRTI</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF2/3</td><td>Abort PRIVOP</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF0/1</td><td>Abort MAXTRAP</td></tr>
	<tr><td>$FFFFFFFFFFFFFFEE/F</td><td>Abort PRIMEM</td></tr>
	</table>
	<p>The following table describes the abort conditions:</p>
    <table border="1">
<tr><th>Name</th><th>Explanation</th></tr>
<tr><td>NOMEM</td><td>No memory mapping available for address</td></tr>
<tr><td>WPROT</td><td>Write attempt into read-only memory</td></tr>
<tr><td>NOEXEC</td><td>Opcode fetch on a no-execute memory area</td></tr>
<tr><td>PRIVRTI</td><td>Attempt to set the hypervisor bit from stack via RTI for example</td></tr>
<tr><td>PRIVOP</td><td>Attempt to execute a privileged operation</td></tr>
<tr><td>MAXTRAP</td><td>Attempt to execute a TRAP opcode with a trap number above the allowed maximum value</td></tr>
<tr><td>PRIVMEM</td><td>User mode access on memory available only on hypervisor mode</td></tr>
    </table>
      <h3><a name="trap" id="trap">Trap handling</a></h3><p>
	The 65k has a TRAP opcode that allows to trap from a program into supervisor mode
	(if available), resp. into a system program via a given trap vector.
	The current version allows for a maximum of 255 trap vectors, as the trap operand is byte-wide.
      </p><p>
	The TMV register determines the maximum number of trap vectors allowed. Default after reset is zero,
	which means no trap vectors allowed. If a trap vector number used is lower than
	the TMV register value, the trap is allowed. Otherwise a MAXTRAP abort is initiated.
      </p><p>
	The trap handling is similar to the interrupt handling. There is a trap vector base
	register similar to the interrupt base register. Here the lowest nine bit of the
	trap vector base register are reserved and must be zero. Trap vectors are always
	two byte, the address is in the same 64k bank as the vectors.
      </p><p>
	As there are 256 trap vectors, with 2 byte vectors the trap table is 
	512 byte. For 2 byte vectors all but the lowest 9 bit from the register are
	used. This way the used
	part of the register can simply be ORd with the shifted trap number to compute
	the effective vector address.
      </p>
	<table class="optable">
	<tr><th>Trap vector base:</th><th>$FFFFFFFFFFFFFE00</th></tr>
	<tr><td>$FFFFFFFFFFFFFFFE/F</td><td>TRAP #$FF</td></tr>
	<tr><td>...</td><td>...</td></tr>
	<tr><td>$FFFFFFFFFFFFFE00/1</td><td>TRAP #$00</td></tr>
	</table>
      <h3><a name="intproc" id="intproc">Interrupt and Trap Procedure</a></h3><p>
	What happens when an interrupt or a trap occurs? The interrupt procedure is very similar to the
	original 6502 interrupt.
      </p><p>
	First the program counter is written to the stack. 
	As the program counter can be wider than the original 6502's program counter, the value
	written on the stack can be variable width. I.e. if the address is a "canonical address" - 
	the uppermost 33 resp. 49 bits are all ones, or all zeros (i.e. sign-extended 
	32 resp. 16 bit address values) the value written on the stack can be shortened.
      </p><p>
	After the address the extended status register is written to the stack. I.e. the 
	high status byte.
	The high status byte contains two address width bits that allow the RTI opcode to determine
	the width of the stored return address.
      </p><p>
	In case of an interrupt then the low status byte (that mirrors the original 6502 status register)
	is written to the stack. This is not done on TRAP, as the return from TRAP should not overwrite
	returned status values - TRAP always uses the extended stack frame. 
	Bit5 of the status byte, however, is set to 0. When pulling this
	from the stack this indicates the extended stack frame. 
	Note that this is a slight incompatibility with original 6502 code - although in an obscure edge case!
      </p><p>
	After that the processor goes into hypervisor mode (concerning matchcode and stack pointer).
	Then the respective address vector is fetched and jumped to.
      </p><p>
	This results in the situation that the TRAP exception stack frame as well as the
	interrupt exception stack frame are stored on the user mode stack (if execution happens
	during user mode).
	The previous hypervisor status bit is stored in the CPU extended status register (so RTI knows
	from where to pull the exception stack frame. This also makes stacked interrupts work! 
      </p><p>
	This procedure means that similar to the 6502 no other registers are stored on the stack, 
	this must be done by the interrupt routine.
      </p><h3><a name="intret" id="intret">Interrupt and Trap Return</a></h3><p>
	For the return from a TRAP, there is the RTU opcode, Return to User space. It determines the
	previous hypervisor state bit (from the current extended status byte) and determines from that
	from which enviroment (user mode or hypervisor mode stack pointer / match code) to pull the exception stack frame.
	This is also the target environment after the opcode execution.
	It then pulls the extended status byte from this stack. If the target environment is hypervisor, then the 
	previous hypervisor mode bit in the CPU is set from the value on the stack. If not, this bit is cleared.
	It determines the stack frame size from the extended status byte, pulls the return address and jumps there.
      </p><p>
	Note that to not have a possible security leak the "previous" hypervisor mode bit must not be modifiable
	from user space! It is set when entering a TRAP or interrupt vector, which are the only ways of
	entering the hypervisor mode, so hypervisor always has a valid value. When restoring the previous 
	hypervisor mode bit from the stack frame with an RTU or RTI opcode, it is only set when the stack frame is
	read from hypervisor mode.
      </p><p>
	For the return from an interrupt, there is the RTI opcode. It first determines the environment
	to pull the execption stack frame from as in the RTU opcode.
	It then pulls the status byte from this stack and restores it. If bit 5 is zero, it pulls the extended stack frame
	similar to the the TRAP opcode. It bit 5 is one, it goes into 6502 compatibility mode - pulls a two
	byte return address from the stack. In this case the hypervisor flags are not modified. 
	The address that has been read is then sign-extended to full address width.
	It then jumps to the return address.
      </p><p>
	If an RTI opcode is executed from user space, the previous hypervisor bit is cleared no matter what is
	read from the stack. When it tries to restore an extended stack with a hypervisor bit set, then
	a privilege exception is executed.
      </p><h3><a name="jpu" id="jpu">Jump to User Mode</a></h3><p>
	To go to a user space program - as set up by the user mode matchcode and user mode 
	stack pointer - the JPU opcode is used. It reads the operand address (from hypervisor mode),
	then clears the hypervisor bit. After that it either jumps to the operand address in
	user mode (absolute jump), or it reads the effective address from user mode (indirect jump)
	and jumps there.
      </p><p>
	To emulate the behaviour of the original 6502, you would do a</p>
	<pre>
	JPU ($FFFC)
	</pre>
      <h3><a name="irqfw" id="irqfw">Forward an interrupt to user mode</a></h3><p>
	If you want to forward an interrupt to a user mode program, you can on one side forward the interrupt
	by using the user mode interrupt selector control bits. But this only works while in user mode.
	When in hypervisor mode, the standard interrupt procedure is initiated. To also forward this interrupt
	the following sequence has to take place:
	</p>
	<ol>
	<li>Save the registers from the hypervisor mode (in hypervisor mode, so user mode cannot modify them
		on the stack)</li>
	<li>Change the environment to the one to forward the interrupt to</li>
	<li>push an extended status byte with the hypervisor bit set onto user space stack</li>
	<li>push a standard status byte with bit5 cleared - extended stack frame marker - onto user space stack</li>
	<li>JMP.U ($FFFE)</li>
	<li>When user space executes an RTI, it finds the hypervisor bit set. This triggers 
		a privilege exception that goes to a defined entry point into the hypervisor mode</li>
	<li>Check that the RTI comes from an actual interrupt forward</li>
	<li>Clear user mode stack</li>
	<li>From the privilege exception, restore the hypervisor mode registers and execute an RTI
		in hypervisor to end the standard interrupt procedure.</li>
	</ol>
      </div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="mem" id="mem">Memory Management</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><p>
	This section describes the memory management features of the 65k. Those features are
	optional. They are decoupled from the main core by the means of "match codes".
    </p><h3><a name="match" id="match">Match code</a></h3><p>
	The match code is an 8 bit value set by the core, for every memory access.
	It is used by the MMU to select which translation should be used to translate from
	effective to physical address.
      </p><h3><a name="cont" id="cont">Container</a></h3><p>
	Container are an optional feature together with the hypervisor mode.
	A container confines the processor into a defined address area. This is done by ANDing the
	effective address of the opcode with a bit mask, then comparing it with an address value.
	When the masked address equals the address value, the container address matches.
	Then a fixed offset is ORd with the
	result, to get the "confined address". The smallest memory area that can be confined is
	256 byte.
      </p><p>
	The MMU has a number of such container definitions. Each definition is matched against
	the current effective address coming from the CPU. As the matchable memory area is 
	at least 256 byte, the lowest 8 bit in the mask and address value are used to match the matchcode:
	the 8 bit matchcode is ANDed with the lowest 8 mask bits, then compared to the 
	lowest 8 offset bits. If they are equal, then the container definition matches.
      </p><p>
	If multiple containers are matching the address and match code, then the container
	definition with the lowest number is effective.
	If no container matches (e.g. upon reset) then the effective address becomes the confined
	address without any translation.
      </p><p>
	In addition to mask and offset the container definition has an extra byte in the
	low 8 bit of the address offset that determines memory mapping metadata: </p>
	<table border="1">
	<tr><th>Bit</th><th>Name</th><th>Function</th></tr>
	<tr><td>0</td><td>VALID</td><td>If set, the address mapping is valid. If the container
				becomes effective, but the valid bit is not set, a Bus error condition
				occurs</td></tr>
	<tr><td>1</td><td>HYPERVISOR</td><td>If set, the address mapping is only available in hypevisor
				mode. If hypervisor mode is off, this mapping never matches</td></tr>
	<tr><td>2</td><td>READONLY</td><td>If set, the memory area mapped here is read-only, writes are ignored if TRAPWRITE 
				is not set</td></tr>
	<tr><td>3</td><td>TRAPWRITE</td><td>If set, and READONLY is set, then a bus error condition occurs on writes</td></tr>
	<tr><td>4</td><td>NOEXECUTE</td><td>If set, a bus error condition occurs when the processor
				tries to read an opcode from this mapping</td></tr>
	<tr><td>5</td><td>TRANSIENT</td><td>If set, the memory address cannot be cached</td></tr>
	<tr><td>6/7</td><td>WIDTH</td><td>Memory access width. 00=8 bit, 01=16 bit, 10=32 bit, 11=64 bit. 
			If the width selected here is wider than the physical width, the upper bits are ignored on writes
			and zero on reads.</td></tr>
	</table>
      <p>
	A memory management setup to emulate a Commodore PET would for example look like (in a 32 bit option) the
	table below, where the matchcode $12 is assumed to be the PET's matchcode, the system's I/O is at $E0000000,
	Video memory at $D0000000 and normal bus is 16 bit. The "PET emulator" memory is at $100000000.
	</p>
      <table border="1">
	<tr><th>Container#</th><th>Addr/Matchcode Mask</th><th>Addr/Matchcode value</th><th>Addr Offset/Container Control</th></tr>
	<tr><td>0</td><td>$FFFFFF/$FF</td><td>$0000E8/$12 (256 byte at $0000E800)</td><td>$E00000/%00110001 (8 Bit, TRANSIENT, NOEXECUTE, VALID)</td></tr>
	<tr><td>1</td><td>$FFFFF0/$FF</td><td>$000080/$12 (4kB at $00008000)</td><td>$D00000/%01110001 (16 Bit, TRANSIENT, NOEXECUTE, VALID)</td></tr>
	<tr><td>2</td><td>$FFFF80/$FF</td><td>$000000/$12 (32kB at $00000000)</td><td>$100000/%01000001 (16 Bit, VALID)</td></tr>
	<tr><td>3</td><td>$FFFF80/$FF</td><td>$000080/$12 (32kB at $00008000)</td><td>$100000/%01000101 (16 Bit, READONLY, VALID)</td></tr>
      </table><p>
	Using a matchcode mask of $FE instead of $FF in the first mapping would for example allow to share the
	mapping of container #0 between matchcode $12 and $13. This allows for shared memory segments.
      </p><p>
	Also note that the matching memory areas overlap. Here the preference rule says the one with the lower container
	number is effective. 
      </p><p>
	The table shows that this type of mapping has some restrictions, it is not possible to arbitrarily map memory 
	areas around, but it can still be used flexibly. The effective addresses for this approach are all 
	starting at zero - you could for example emulate an 8k-only 6504 - but the address offset then
	translates the address to the correct physical address space.
      </p><p>
	Note: this section must be further worked over. There is no way to define a write-through cache (e.g. video memory
	could be written (slowly) to a video board, but mirrored and cached in fast memory. On the other hand is this
	situation very common? Writes to read-only memory could always trap, so TRAPWRITE would not be needed.
	Are there two WIDTH bits required? Would not one bit be enough to indicate 8 bit access. This would
	suffice for compatibility. Also it would allow to have the default to "native" width - in the current
	proposal above the processor must know which memory access width it actually uses to write the correct
	width value.
      </p><h3><a name="mmu" id="mmu">Paged Memory Management Unit (MMU)</a></h3><p>
	TBD
      </p></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="smp" id="smp">Multiprocessing</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><p>
	The 65k will support multiprocessing. With the LLA and SCA it supports load-linked and store-conditional
	multiprocessor-safe synchronization primitives. 
	Note that the usual read-modify write operations (ROR, ROL, LSR, ASL, ASR, RDR, RDL, INC, DEC, TSB, TRB, SLY, SRY, SLX, SRX) 
	are in general not multiprocessor-safe. They may be multicore-safe (two cores on one processor).
      </p></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="compat" id="compat">6502 Software Compatibility Notes</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><p>
	Here are some notes on compatibility with the 6502.
      </p><h3><a name="compatstack" id="compatstack">Stack Frame</a></h3><p>
	  The 65k has, on purpose, an extended interrupt functionality. Thus it needs an extended stack frame
	  to store the additional information, as described above. Yet there is 6502 compatibility included:
	</p>
	<table border="1">
	<tr><th colspan="3">Stack Frames</th></tr>
	<tr><th>Address</th><th>6502</th><th>65k</th></tr>
	<tr><th>S+10</th><td rowspan="3"></td><td>ADDR byte 7</td></tr>
	<tr><th>S+5..9</th>                <td>ADDR byte 2..6</td></tr>
	<tr><th>S+4</th>                <td>ADDR byte 1</td></tr>
	<tr><th>S+3</th><td>ADDR byte 1</td><td>ADDR byte 0</td></tr>
	<tr><th>S+2</th><td>ADDR byte 0</td><td>Extended Status Byte</td></tr>
	<tr><th>S+1</th><td>Status register (bit5=1)</td><td>Status Register (bit5=0)</td></tr>
	</table>
	<p>
	  As you can see it is the status register bit 5 that determines whether an extended 
	  stack frame is used or not. In a 6502 it is always 1. 
	  As a result, if some 6502 software creates an artificial stack frame with bit5 cleared,
	  it will trigger the use of an extended stack frame and crash.
	</p>
      	<h3><a name="compatpointer" id="compatpointer">Interrupt Pointer</a></h3><p>
	  As the 65k has an extended interrupt functionality, the number - and size - of the 6502 interrupt
	  pointer does not suffice anymore for an efficient operation.
	</p>
	<p>
	  For compatibility reasons the CPU starts with a restricted set of 6502-compatible interrupt vectors
	  as described above. Only when the Interrupt Base Register is set, the extended, per interrupt
	  jump vectors are used.
	</p><p>
	  In addition, as long as the Interrupt Base Register is not set, the interrupt routine is using the
	  6502-compatible stack frame as interrupt stack frame. I.e. Status register bit5 is kept as one, and
	  only two bytes of the address are stored (which are sign-extended on RTI though). Also the 
	  hypervisor bits are not set on interrupt in this case.
	</p>
      	<h3><a name="compattiming" id="compattiming">Timing</a></h3><p>
	  The 65k will NOT be timing compatible with the 6502.
	</p><p>
	  Although one might think of using an 8-bit accumulator and the typical 6502 pipelining to extend
	  the original 6502, this is not the goal of this design.
	  The goal is to venture into wider address and data bus sizes, and also use wider accumulators,
	  to effectively use the available features of today's programmable logic.
	  So this makes it very unlikely, if not impossible, that a timing-compatible 65k will ever exist.
	</p>
      	</div></div><hr />
<p>Return to <a href="../index.html">Homepage</a></p>

  </div></div><div id="footer"> </div></div><script type="text/javascript">myUp="../";</script><script type="text/javascript" src="../scripts-all.js"></script><script type="text/javascript" src="../jquery.socialshareprivacy.js"></script><script type="text/javascript">
          jQuery(document).ready(function($){
                  if($('#socialshareprivacy').length != 0){
                            $('#socialshareprivacy').socialSharePrivacy();
                  }
          });
  </script></body></html> 

