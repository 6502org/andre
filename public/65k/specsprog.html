<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Andr&#xE9;  Fachat" />

<meta name="description" content="6502 16bit 32bit expansion" />
<meta name="keywords" content="6502 16bit 32bit expansion" />
<link rev="made" href="mailto:afachat@gmx.de" />
<link rel="stylesheet" title="Default" type="text/css" href="../style-min.css" /><link rel="alternate stylesheet" title="Advanced" type="text/css" href="../advanced.css" /><link rel="stylesheet" type="text/css" href="optable.css" />
<title>The 65k Project - Implementation Specs</title></head>
<body><div id="mainbox"><a name="top" id="top"></a><div id="leftcol"><div id="menu" class="top"><div class="tophead">navigate</div><div id="filter"><form action="#"><table id="filterbox"><tr><td><input alt="menu filter" size="8" name="filter" value="filter" type="text" /></td><td><div id="cancel" class="i_cancel"> </div></td></tr></table><table id="expcol"><tr><td><div id="expand" class="i_expand"> </div></td><td><div id="collapse" class="i_collapse"> </div></td></tr></table></form></div>
<div id="mtree">
<a id="m_homepage" href="../index.html">Homepage</a>
<ul class="menu0" >
<li class="separator">Commodore</li>
<li class="dir" id="m_petindex"><div class="i_dir">&nbsp;</div><a href="../petindex/index.html">CBM PETindex</a>
</li>
<li class="dir" id="m_cbmhw"><div class="i_dir">&nbsp;</div><a href="../cbmhw/index.html">CBM hardware and mods</a>
</li>
<li class="separator">Hardware</li>
<li class="dir" id="m_65k"><div class="i_dir">&nbsp;</div><a href="../65k/index.html">The 65k Project</a>
<ul class="menu1" >
<li><div class="i_file">&nbsp;</div><a href="features.html">Features</a></li>
<li class="separator">Specification</li>
<li><div class="i_file">&nbsp;</div><a href="specsprog.html" class="mcurrent">Programming Model</a></li>
<li class="separator">Implementation</li>
<li><div class="i_file">&nbsp;</div><a href="arch.html">Architecture Overview</a></li>
<li><div class="i_file">&nbsp;</div><a href="tests.html">Test setup</a></li>
</ul>
</li>
<li class="dir" id="m_csa"><div class="i_dir">&nbsp;</div><a href="../csa/index.html">CS/A65 Caspaer and Gecko computer</a>
</li>
<li class="dir" id="m_adv65"><div class="i_dir">&nbsp;</div><a href="../adv65/index.html">Advanced 6502</a>
</li>
<li class="dir" id="m_hwinfo"><div class="i_dir">&nbsp;</div><a href="../hwinfo/index.html">ICs and Standards Info</a>
</li>
<li class="dir" id="m_mischw"><div class="i_dir">&nbsp;</div><a href="../mischw/index.html">Other hardware (e.g. tools)</a>
</li>
<li class="separator">Software</li>
<li><div class="i_file">&nbsp;</div><a href="../osa/index.html">GeckOS operating system</a>
</li>
<li><div class="i_file">&nbsp;</div><a href="../lib6502/index.html">Lib6502 standard</a>
</li>
<li><div class="i_file">&nbsp;</div><a href="../o65/index.html">O65 file format</a>
</li>
<li><div class="i_file">&nbsp;</div><a href="../misc/index.html">Misc software</a>
</li>
<li class="separator">Knowledge Bits</li>
<li class="dir" id="m_icapos"><div class="i_dir">&nbsp;</div><a href="../icapos/index.html">Computer/OS Architecture</a>
</li>
<li class="dir" id="m_icaphw"><div class="i_dir">&nbsp;</div><a href="../icaphw/index.html">6502 Hardware Bits</a>
</li>
<li class="separator">Misc</li>
<li><div class="i_file">&nbsp;</div><a href="../contact.html">Contact</a></li>
<li><div class="i_file">&nbsp;</div><a href="../sneak.html">Sneak preview</a></li>
<li><div class="i_file">&nbsp;</div><a href="../design.html">Web design</a></li>
</ul>

</div>
		</div><div class="top" id="browser"><div class="tophead">browser</div><div>
			Site has been tested with a number of browsers and systems. Javascript required for advanced menu, but degrades gracefully without Javascript. IE6 not fully supported anymore!
			</div></div></div><div id="rightcol"><div class="top" id="google"><div class="tophead">search</div><div><form method="get" action="http://www.google.com/search" target="_blank"><input alt="search parameters" type="text" name="q" size="10" maxlength="255" value="" /><input class="advbutton" type="submit" value="Search my site" /><br />(Google, in new window)
	                        <input type="hidden" name="sitesearch" value="www.6502.org/users/andre" /></form></div></div><div class="top" id="twitter"><div class="tophead">follow</div><div>
		            Follow my 8-bit tweets on<br /><a target="_blank" href="http://search.twitter.com/search?q=&amp;ands=&amp;phrase=&amp;ors=&amp;nots=&amp;tag=8bit&amp;lang=all&amp;from=afachat&amp;to=&amp;ref=&amp;near=&amp;within=15&amp;units=mi&amp;since=&amp;until=&amp;rpp=15">Twitter</a><br /> (In new window)
		</div></div><div class="top" id="forum"><div class="tophead">discuss</div><div><p>Discuss my site on <a class="extlink" target="_blank" href="http://forum.6502.org/viewtopic.php?t=956">this 6502.org forum thread</a></p><p>(Forum registration required to post)</p></div></div><div class="top" id="hot"><div class="tophead">Hot!</div><div>
<p>Dive into the retro feeling and build yourself a <a href="../cbmhw/ryofat40/index.html">Commodore PET replica</a></p>
<p>Need more speed? Speed up your 6502 computer with this <a href="../adv65/pet816/index.html">10&nbsp;MHz 6502 CPU replacement board</a></p>
<p>Interested in electronics design? Look at the <a href="../icaphw/design.html">design lesson</a> I got from Bil Herd, the hardware designer of the C128</p>

		</div></div></div><div id="midcol"><div class="top" id="ie6warn">
You are using an old MS Internet Explorer as browser. This version is not supported anymore. Please use a 
more modern browser, like Internet Explorer 8 or later, 
<a target="_blank" class="extlink" href="http://www.firefox.com">Firefox</a>,
<a target="_blank" class="extlink" href="http://www.google.com/chrome">Google Chrome</a>, or
<a target="_blank" class="extlink" href="http://www.opera.com">Opera</a>.
</div><div class="top" id="content"><div id="minmax"></div>
<div id="breadcrumbs">
<a href="../index.html">Homepage</a>
&gt;&gt;  <a href="index.html">The 65k Project
</a>&gt;&gt;  Programming Model</div>
<h1>The 65k Project - Implementation Specs</h1><p class="copyright">(C)
2010- André  Fachat</p> 
<div class="overview"><p>
	This page describes the implementation specs for my 65k line of processors.
	For a reasoning why a feature is implemented as it is, see the <a href="features.html">Features discussion</a>
	page.
	</p><p>
	The 65k will be available in different "sizes" - mainly in terms of register widths.
	For example options for 16 bit, 32 bit, and even 64 bit registers are defined.
	The first section will thus describe the options available.
	</p><p>
	The second section will then give an overview on the opcodes and their addressing modes
	The third section describes reset, interrupt and other special behaviour.
	</p><p>
	Note that these tables are currently preliminary. Final goal is to generate this part of the
	documentation from the same source that generates the VHDL control tables.
  </p></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="news" id="news">News:</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><ul class="news"><li><div> </div><small>2010-10-03</small>
	Started this page
    </li></ul></div></div><div id="toc" class="h2"><div class="h2h"><div class="h2t"> </div><h2>Table of content</h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><ul><li><a href="#preface">Preface</a></li><li style="list-style-type:none;"><ul><li><a href="#lic">License</a></li><li><a href="#disc">Disclaimer</a></li><li><a href="#cont">Contributors</a></li><li><a href="#chg">Changes</a></li></ul></li><li><a href="#opts">65k Options</a></li><li style="list-style-type:none;"><ul><li><a href="#optswidth">Register Widths Options</a></li><li><a href="#optssuper">Supervisor Mode Option</a></li><li><a href="#optsmmu">MMU Option</a></li></ul></li><li><a href="#regs">Register Set</a></li><li><a href="#overview">65k Opcode and Addressing Mode Overview</a></li><li style="list-style-type:none;"><ul><li><a href="#ovops">Opcodes Overview</a></li><li><a href="#ovadmd">Addressing Modes Overview</a></li><li><a href="#ovpref">Prefix Overview</a></li><li><a href="#ovquick">Quick Opcodes</a></li><li><a href="#ovfp">EXT opcodes</a></li><li><a href="#ovfp">FP opcodes</a></li><li><a href="#ovmmu">Blitter opcodes</a></li><li><a href="#ovsys">SYS opcodes</a></li></ul></li><li><a href="#sys">System Environment</a></li><li style="list-style-type:none;"><ul><li><a href="#reset">Reset</a></li><li><a href="#int">Interrupts</a></li><li><a href="#trap">Trap handling</a></li><li><a href="#intproc">Interrupt and Trap Procedure</a></li><li><a href="#cont">Container</a></li><li><a href="#seg">Segmentation</a></li></ul></li></ul></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="preface" id="preface">Preface</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><h3><a name="lic" id="lic">License</a></h3><p>
        This content is licensed under the Creative Commons Attribution Share-Alike license, CC-BY-SA version 3.0.
    </p><p>
        Note this "content" includes this web page, but does not include the 6502.org header
        and the left and right web page columns.  Click on the "Maximize" link to see
        the contents covered by this license.
    </p><ul><li><a href="http://creativecommons.org/licenses/by-sa/3.0/legalcode" target="_blank" class="extlink">CC-BY-SA legal code</a> </li><li><a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_blank" class="extlink">CC-BY-SA license deed (short form)</a> </li></ul><h3><a name="disc" id="disc">Disclaimer</a></h3><p>
        The content comes with no warranty at all!
        There is no guarantee and no promise that this specification is correct, consistent, will actually work,
        or will ever be implemented at all.
    </p><p>
        Subject to change without notice!
    </p><h3><a name="cont" id="cont">Contributors</a></h3><ul>
        <li>André  Fachat - initial author: <a href="http://www.6502.org/users/andre">8bit Homepage</a></li>
    </ul><h3><a name="chg" id="chg">Changes</a></h3><p>This section describes the changes to the document:</p>
      <table border="1">
        <tr><th>Date</th><th>Author</th><th>Changes</th></tr>
        <!--tr><td>2010-10-03</td><td>Andr&eacute; Fachat</td><td>First working draft</td></tr-->
      </table>
    </div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="opts" id="opts">65k Options</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><p>This section describes the different versions of the 65k processor
	</p>
     <h3><a name="optswidth" id="optswidth">Register Widths Options</a></h3><p>
	The 65k will be available in different "register widths". Register here means all address registers
	(stack pointer (SP), program counter (PC), base offset register (BR)), but also all data registers (AC, XR, YR).
	This does not include the status register for example. For details see the register model below.
	Address and Data registers will always have the same width to accomodate for address offsets computed
	in data registers.
	</p><p>
	The following options are available:</p>
	<ul>
	<li>16 bit - a small extension to the original 6502 programming model, the PC stays 16 bit as 
		it already is in the 6502.</li>
	<li>32 bit - all data and address registers extended to 32 bit</li>
	<li>64 bit - all data and address registers extended to 64 bit</li>
	</ul><p>
	The original register width for most of the registers is a byte. To use the registers with more than
	8 bit a prefix opcode to the existing 8 bit opcodes is used. 2 bit of the prefix opcode are
	reserved for operation width, which allows to address registers as 8, 16, 32 or 64 bit.
    	</p><h3><a name="optssuper" id="optssuper">Supervisor Mode Option</a></h3><p>
	The 65k will optionally provide a supervisor mode. When using a supervisor mode, critical instructions -
	those that modify system state - become privileged and are thus only allowed in supervisor mode.
	Supervisor mode allows to separate user space programs from kernel space, and protects the kernel from
	unwanted modifications from user space.
    	</p><h3><a name="optsmmu" id="optsmmu">MMU Option</a></h3><p>
	The 65k will optionally provide an MMU to translate virtual addresses (opcode effective addresses) into
	physical addresses. When the MMU is not included, virtual addresses are directly taken as physical addresses.
    	</p></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="regs" id="regs">Register Set</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><p>
	The register set is very similar to the 6502, with only a few extensions...
	As there are different options for register widths, "W" describes the width
	option, i.e. either 16, 32 or 64 bit.
    </p>
    <table border="1">
	<tr><th>Register</th><th>Name</th><th>6502</th><th>65k</th><th>Comment</th></tr>
	<tr><td>A</td><td>Accumulator</td><td>8 bit</td><td>W bit</td><td>Operations can be done in 8, 16, 32, 64 bit (up to W)</td></tr>
	<tr><td>X</td><td>X register</td><td>8 bit</td><td>W bit</td><td>Operations can be done in 8, 16, 32, 64 bit (up to W)</td></tr>
	<tr><td>Y</td><td>Y register</td><td>8 bit</td><td>W bit</td><td>Operations can be done in 8, 16, 32, 64 bit (up to W)</td></tr>
	<tr><td>S</td><td>Stack pointer</td><td>8 bit, with high byte set to 1</td><td>W bit</td><td></td></tr>
	<tr><td>ST</td><td>Status Register</td><td>8 bit, with bit 5 set to 1</td><td>16 bit</td><td>TBD</td></tr>
	<tr><td>PC</td><td>Program Counter</td><td>16 bit</td><td>W bit</td><td></td></tr>
	<tr><td>E</td><td>Effective Address Register</td><td>-</td><td>W bit</td><td>Stores effective address for opcodes</td></tr>
	<tr><td>B</td><td>Base Offset Register</td><td>-</td><td>W bit</td><td>Address offset for addressing modes</td></tr>
	<tr><th colspan="5">System Management Registers</th></tr>
	<tr><td>I</td><td>Interrupt base register</td><td>-</td><td>W bit</td><td>Base address for interrupt vectors</td></tr>
	<tr><td>T</td><td>Trap vector base register</td><td>-</td><td>W bit</td><td>Base address for trap vectors</td></tr>
    </table>
    </div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="overview" id="overview">65k Opcode and Addressing Mode Overview</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><p>
	This section describes in an overview the opcodes and addressing modes of the 65k.
	</p>
     <h3><a name="ovops" id="ovops">Opcodes Overview</a></h3>
<table class="optable">
<tr><th>LSB-&gt;<br />MSB\</th><th>0</th>		<th>1</th>		<th>2</th>			<th>3</th>			<th>4</th>			<th>5</th>		<th>6</th>		<th>7</th>				<th>8</th>		<th>9</th>			<th>A</th>			<th>B</th>			<th>C</th>			<th>D</th>		<th>E</th>			<th>F</th></tr>
<tr><th>0</th>		<td>BRK</td>			<td>ORA (zp,X)</td>	<td class="c65k">LDA zp,Y</td><td class="prefix">prefix1</td>	<td class="cmos">TSB zp</td>	<td>ORA zp</td>		<td>ASL zp</td>		<td class="prefix">prefix1</td>		<td>PHP</td>		<td>ORA imm</td>		<td>ASL A</td>			<td class="prefix">prefix2</td>	<td class="cmos">TSB abs</td>	<td>ORA abs</td>	<td>ASL abs</td>		<td class="c65k">PLB</td></tr>
<tr><th>1</th>		<td>BPL rel</td>		<td>ORA (zp),Y</td>	<td class="cmos">ORA (zp)</td>	<td class="prefix">prefix1</td>	<td class="cmos">TRB zp</td>	<td>ORA zp,X</td>	<td>ASL zp,X</td>	<td class="prefix">prefix1</td>		<td>CLC</td>		<td>ORA abs,y</td>		<td class="cmos">INC A</td>	<td class="prefix">prefix2</td>	<td class="cmos">TRB abs</td>	<td>ORA abs,X</td>	<td>ASL abs,X</td>		<td class="c65k">PHB</td></tr>	
<tr><th>2</th>		<td>JSR abs</td>		<td>AND (zp,X)</td>	<td class="c65k">STA zp,Y</td><td class="prefix">prefix1</td>	<td>BIT zp</td>			<td>AND zp</td>		<td>ROL zp</td>		<td class="prefix">prefix1</td>		<td>PLP</td>		<td>AND imm</td>		<td>ROL A</td>			<td class="prefix">prefix2</td>	<td>BIT abs</td>		<td>AND abs</td>	<td>ROL abs</td>		<td class="c65k">SAB</td></tr>
<tr><th>3</th>		<td>BMI rel</td>		<td>AND (zp),Y</td>	<td class="cmos">AND (zp)</td>	<td class="prefix">prefix1</td>	<td class="cmos">BIT zp,X</td>	<td>AND zp,X</td>	<td>ROL zp,X</td>	<td class="prefix">prefix1</td>		<td>SEC</td>		<td>AND abs,Y</td>		<td class="cmos">DEC A</td>	<td class="prefix">prefix2</td>	<td class="cmos">BIT abs,X</td>	<td>AND abs,X</td>	<td>ROL abs,X</td>		<td class="c65k">PRB</td></tr>
<tr><th>4</th>		<td>RTI</td>			<td>EOR (zp,X)</td>	<td class="c65k">LDA (abs),Y</td><td class="prefix">prefix1</td><td class="c65k">FP prefix</td><td>EOR zp</td>		<td>LSR zp</td>		<td class="prefix">prefix1</td>		<td>PHA</td>		<td>EOR imm</td>		<td>LSR imm</td>		<td class="prefix">prefix2</td>	<td>JMP abs</td>		<td>EOR abs</td>	<td>LSR abs</td>		<td class="c65k">SAX</td></tr>
<tr><th>5</th>		<td>BVC rel</td>		<td>EOR (zp),Y</td>	<td class="cmos">EOR (zp)</td>	<td class="prefix">prefix1</td>	<td class="c65k">SYS prefix</td><td>EOR zp,X</td>	<td>LSR zp,X</td>	<td class="prefix">prefix1</td>		<td>CLI</td>		<td>EOR abs,Y</td>		<td class="cmos">PHY</td>	<td class="prefix">prefix2</td>	<td class="c65k">Blitter prefix</td><td>EOR abs,X</td>	<td>LSR abs,X</td>		<td class="c65k">SAY</td></tr>
<tr><th>6</th>		<td>RTS</td>			<td>ADC (zp,X)</td>	<td class="c65k">LDA (abs,X)</td><td class="prefix">prefix1</td><td class="cmos">STZ zp</td>	<td>ADC zp</td>		<td>ROR zp</td>		<td class="prefix">prefix1</td>		<td>PLA</td>		<td>ADC imm</td>		<td>ROR A</td>			<td class="prefix">prefix2</td>	<td>JMP (abs)</td>		<td>ADC abs</td>	<td>ROR abs</td>		<td class="c65k">SXY</td></tr>
<tr><th>7</th>		<td>BVS rel</td>		<td>ADC (zp),Y</td>	<td class="cmos">ADC (zp)</td>	<td class="prefix">prefix1</td>	<td class="cmos">STZ zp,X</td>	<td>ADC zp,X</td>	<td>ROR zp,X</td>	<td class="prefix">prefix1</td>		<td>SEI</td>		<td>ADC abs,Y</td>		<td class="cmos">PLY</td>	<td class="prefix">prefix2</td>	<td class="cmos">JMP (abs,X)</td><td>ADC abs,X</td>	<td>ROR abs,X</td>		<td class="c65k">NOP zp</td></tr>
<tr><th>8</th>		<td class="cmos">BRA rel</td>	<td>STA (zp,X)</td>	<td class="c65k">BSR rel</td>	<td class="prefix">prefix1</td>	<td>STY zp</td>			<td>STA zp</td>		<td>STX zp</td>		<td class="prefix">prefix1</td>		<td>DEY</td>		<td class="cmos">BIT imm</td>	<td>TXA</td>			<td class="prefix">prefix2</td>	<td>STY abs</td>		<td>STA abs</td>	<td>STX abs</td>		<td class="c65k">NOP abs</td></tr>
<tr><th>9</th>		<td>BCC rel</td>		<td>STA (zp),Y</td>	<td class="cmos">STA (zp)</td>	<td class="prefix">prefix1</td>	<td>STY zp,X</td>		<td>STA zp,X</td>	<td>STX zp,Y</td>	<td class="prefix">prefix1</td>		<td>TYA</td>		<td>STA abs,Y</td>		<td>TXS</td>			<td class="prefix">prefix2</td>	<td class="cmos">STZ abs</td>	<td>STA abs,X</td>	<td class="cmos">STZ abs,X</td>	<td class="c65k">TPA</td></tr>
<tr><th>A</th>		<td>LDY imm</td>		<td>LDA (zp,X)</td>	<td>LDX imm</td>		<td class="prefix">prefix1</td>	<td>LDY zp</td>			<td>LDA zp</td>		<td>LDX zp</td>		<td class="prefix">prefix1</td>		<td>TAY</td>		<td>LDA imm</td>		<td>TAX</td>			<td class="prefix">prefix2</td>	<td>LDY abs</td>		<td>LDA abs</td>	<td>LDX abs</td>		<td class="c65k">SWP</td></tr>
<tr><th>B</th>		<td>BCS rel</td>		<td>LDA (zp),Y</td>	<td class="cmos">LDA (zp)</td>	<td class="prefix">prefix1</td>	<td>LDY zp,X</td>		<td>LDA zp,X</td>	<td>LDX zp,Y</td>	<td class="prefix">prefix1</td>		<td>CLV</td>		<td>LDA abs,Y</td>		<td>TSX</td>			<td class="prefix">prefix2</td>	<td>LDY abs,X</td>		<td>LDA abs,X</td>	<td>LDX abs,Y</td>		<td class="c65k">CLX</td></tr>
<tr><th>C</th>		<td>CPY imm</td>		<td>CMP (zp,X)</td>	<td class="c65k">STA (abs),Y</td><td class="prefix">prefix1</td><td>CPY zp</td>			<td>CMP zp</td>		<td>DEC zp</td>		<td class="prefix">prefix1</td>		<td>INY</td>		<td>CMP imm</td>		<td>DEX</td>			<td class="prefix">prefix2</td>	<td>CPY abs</td>		<td>CMP abs</td>	<td>DEC abs</td>		<td class="c65k">CLY</td></tr>
<tr><th>D</th>		<td>BNE rel</td>		<td>CMP (zp),Y</td>	<td class="cmos">CMP (zp)</td>	<td class="prefix">prefix1</td>	<td class="c65k">QUICK prefix</td><td>CMP zp,X</td>	<td>DEC zp,X</td>	<td class="prefix">prefix1</td>		<td>CLD</td>		<td>CMP abs,Y</td>		<td class="cmos">PHX</td>	<td class="prefix">prefix2</td>	<td class="c65k">JSR (abs)</td>	<td>CMP abs,X</td>	<td>DEC abs,X</td>		<td class="unused"></td></tr>
<tr><th>E</th>		<td>CPX imm</td>		<td>SBC (zp,X)</td>	<td class="c65k">STA (abs,X)</td><td class="prefix">prefix1</td><td>CPX zp</td>			<td>SBC zp</td>		<td>INC zp</td>		<td class="prefix">prefix1</td>		<td>INX</td>		<td>SBC imm</td>		<td>NOP</td>			<td class="prefix">prefix2</td>	<td>CPX abs</td>		<td>SBC abs</td>	<td>INX abs</td>		<td class="c65k">CLA</td></tr>
<tr><th>F</th>		<td>BEQ rel</td>		<td>SBC (zp),Y</td>	<td class="cmos">SBC (zp)</td>	<td class="prefix">prefix1</td>	<td class="c65k">TRAP</td>	<td>SBC zp,X</td>	<td>INC zp,X</td>	<td class="prefix">prefix1</td>		<td>SED</td>		<td>SBC abs,Y</td>		<td class="cmos">PLX</td>	<td class="prefix">prefix2</td>	<td class="c65k">JSR (abs,X)</td><td>SBC abs,X</td>	<td>INC abs,X</td>		<td class="c65k">EXT prefix</td></tr>
</table><p>Legend:</p>
<table class="optable">
<tr><td>NMOS Opcodes</td><td class="cmos">CMOS Opcodes</td><td class="c65k">New 65k opcodes</td><td class="prefix">65k Prefix codes</td><td class="unused">Unused/Reserved</td></tr>
</table>
	<p>
	Some of the opcodes are named prefix1 and prefix2, for those see below. 
	Others are named like "QUICK prefix" or "EXT prefix".
	These opcodes provide a way to extend the opcode list by having a second opcode byte follow the prefix. Thus there 
	could be 256 additional "QUICK" opcodes, and 256 additional "MMU opcodes" and so on. These opcode pages are
	described below.
	</p><p>
	Here is a short description of the new opcodes:
	</p>
	<ul>
	<li>BSR - branch subroutine</li>
	<li>TPA - Transfer Program counter to Accumulator [1]</li>
	<li>SWP - swap upper and lower part nibble / byte / word / long word of a byte / word / long / longlong operand
		in Accumulator</li>
	<li>PLB - PulL Base register: pull the base offset register from the stack</li>
	<li>PHB - PusH Base register: push the base offset register to the stack</li>
	<li>SAB - Swap Accumulator and Base register [1]</li>
	<li>PRB - Push and Replace Base register: Push base offset register to the stack, then transfer accumulator to
		the base register</li>
	<li>SAX - Swap Accumulator and X register [1]</li>
	<li>SAY - Swap Accumulator and Y register [1]</li>
	<li>SXY - Swap X register and Y register [1]</li>
	<li>NOP zp - two-byte NOP (resp. 5 byte with AM prefix set)</li>
	<li>NOP abs - three-byte NOP (resp. 9 byte with AM prefix set)</li>
	<li>CLX - clear X register</li>
	<li>CLY - clear Y register</li>
	<li>CLA - clear accumulator</li>
	</ul><p>Notes:</p>
	<ol>
	<li>When the value to be written to the register is larger than the maximum value as determined by an RS prefix
		(if applicable), the overflow bit V is set</li>
	</ol>
    	<h3><a name="ovadmd" id="ovadmd">Addressing Modes Overview</a></h3><p>
	This section describes an overview on the addressing modes of the 65k processor. An addressing mode determines
	effective address of an operand (no matter what size the operand is). The addressing modes are 
	described in detail below.
	</p>
<table class="optable">
<tr><th>Addressing Mode</th><th>Name</th>					<th>Comment</th></tr>
<tr><td>-</td>		<td>Implied</td>					<td>Implied by the operation</td></tr>
<tr><td>A</td>		<td>Accumulator</td>					<td>Accumulator</td></tr>
<tr><td>imm</td>	<td>Immediate</td>					<td>Immediate</td></tr>
<tr><td>zp</td>		<td>Zeropage</td>					<td>Zeropage address</td></tr>
<tr><td>zp,X</td>	<td>Zeropage indexed with X</td>			<td>Zeropage address, plus content of XR</td></tr>
<tr><td>zp,Y</td>	<td>Zeropage indexed with Y</td>			<td>Zeropage address, plus content of YR</td></tr>
<tr><td>abs</td>	<td>Absolute 16 bit</td>				<td>16 bit address</td></tr>
<tr><td>abs,X</td>	<td>Absolute 16 bit indexed with X</td>		<td>16 bit address, plus content of XR</td></tr>
<tr><td>abs,Y</td>	<td>Absolute 16 bit indexed with Y</td>		<td>16 bit address, plus content of YR</td></tr>
<tr><td>long</td>	<td>Long 32 bit</td>				<td>32 bit address</td></tr>
<tr><td>long,X</td>	<td>Long 32 bit indexed with X</td>		<td>32 bit address, plus content of XR</td></tr>
<tr><td>long,Y</td>	<td>Long 32 bit indexed with Y</td>		<td>32 bit address, plus content of YR</td></tr>
<tr><td>longlong</td>	<td>Longlong 64 bit</td>				<td>64 bit address</td></tr>
<tr><td>longlong,X</td>	<td>Longlong 64 bit indexed with X</td>		<td>64 bit address, plus content of XR</td></tr>
<tr><td>longlong,Y</td>	<td>Longlong 64 bit indexed with Y</td>		<td>64 bit address, plus content of YR</td></tr>
<tr><td>(zp)</td>	<td>Zeropage indirect 16 bit</td>			<td>Load effective 16 bit address from zeropage location given</td></tr>
<tr><td>(zp),Y</td>	<td>Zeropage indirect indexed with Y 16 bit</td>	<td>Load effective 16 bit address from zeropage location given, then add content of YR</td></tr>
<tr><td>(zp,X)</td>	<td>Zeropage indexed with X indirect 16 bit</td>	<td>Load effective 16 bit address from zeropage location given plus content of XR</td></tr>
<tr><td>(abs)</td>	<td>Absolute indirect 16 bit</td>			<td>Load effective 16 bit address from absolute location given</td></tr>
<tr><td>(abs),Y</td>	<td>Absolute indirect indexed with Y 16 bit</td>	<td>Load effective 16 bit address from absolute location given, then add content of YR</td></tr>
<tr><td>(abs,X)</td>	<td>Absolute indexed with X indirect 16 bit</td>	<td>Load effective 16 bit address from absolute location given plus content of XR</td></tr>
<tr><td>[zp]</td>	<td>Zeropage indirect 32 bit</td>			<td>Load effective 32 bit address from zeropage location given</td></tr>
<tr><td>[zp],Y</td>	<td>Zeropage indirect indexed with Y 32 bit</td>	<td>Load effective 32 bit address from zeropage location given, then add content of YR</td></tr>
<tr><td>[zp,X]</td>	<td>Zeropage indexed with X indirect 32 bit</td>	<td>Load effective 32 bit address from zeropage location given plus content of XR</td></tr>
<tr><td>[abs]</td>	<td>Absolute indirect 32 bit</td>			<td>Load effective 32 bit address from absolute location given</td></tr>
<tr><td>[abs],Y</td>	<td>Absolute indirect indexed with Y 32 bit</td>	<td>Load effective 32 bit address from absolute location given, then add content of YR</td></tr>
<tr><td>[abs,X]</td>	<td>Absolute indexed with X indirect 32 bit</td>	<td>Load effective 32 bit address from absolute location given plus content of XR</td></tr>
<tr><td>[[zp]]</td>	<td>Zeropage indirect 64 bit</td>			<td>Load effective 64 bit address from zeropage location given</td></tr>
<tr><td>[[zp]],Y</td>	<td>Zeropage indirect indexed with Y 64 bit</td>	<td>Load effective 64 bit address from zeropage location given, then add content of YR</td></tr>
<tr><td>[[zp,X]]</td>	<td>Zeropage indexed with X indirect 64 bit</td>	<td>Load effective 64 bit address from zeropage location given plus content of XR</td></tr>
<tr><td>[[abs]]</td>	<td>Absolute indirect 64 bit</td>			<td>Load effective 64 bit address from absolute location given</td></tr>
<tr><td>[[abs]],Y</td>	<td>Absolute indirect indexed with Y 64 bit</td>	<td>Load effective 64 bit address from absolute location given, then add content of YR</td></tr>
<tr><td>[[abs,X]]</td>	<td>Absolute indexed with X indirect 64 bit</td>	<td>Load effective 64 bit address from absolute location given plus content of XR</td></tr>
<tr><td>rel</td>	<td>Relative address -128 to 127</td>			<td></td></tr>
<tr><td>relwide</td>	<td>Relative address -32768 to 32767</td>		<td></td></tr>
<tr><td>rellong</td>	<td>Relative address -2^32 to 2^32-1</td>		<td></td></tr>
<tr><td>rellonglong</td><td>Relative address -2^64 to 2^64-1</td>		<td></td></tr>
<tr><td>(E)</td>	<td>Indirect-E</td>					<td>Take the effective operand address from the E register</td></tr>
</table><p>
	You will note that not all of these addressing modes are shown in the above table. Here the prefix codes come into play.
    	</p><h3><a name="ovpref" id="ovpref">Prefix Overview</a></h3><p>
	In the opcode map there are 32 codes designated as "prefix1" and 16 codes designated as "prefix2". These opcodes are no operations in themselves, but
	modify the following operation. The prefix has these values:</p>
<table class="bittable">
<tr><th colspan="8">prefix1</th></tr>
<tr><th>bit 7</th><th>bit 6</th><th>bit 5</th><th>bit 4</th><th>bit 3</th><th>bit 2</th><th>bit 1</th><th>bit 0</th></tr>
<tr><th>128</th><th>64</th><th>32</th><th>16</th><th>8</th><th>4</th><th>2</th><th>1</th></tr>
<tr><td>OF1</td><td>OF0</td><td>RS1</td><td>RS0</td><td>0</td><td>AM</td><td>1</td><td>1</td></tr>
</table><p>
	I.e. in prefix1 the lowest two bits are always one and bit 2 (value 4) is always zero, but all of the other five 
	bits have a special meaning.</p>
<table class="bittable">
<tr><th colspan="8">prefix2</th></tr>
<tr><th>bit 7</th><th>bit 6</th><th>bit 5</th><th>bit 4</th><th>bit 3</th><th>bit 2</th><th>bit 1</th><th>bit 0</th></tr>
<tr><th>128</th><th>64</th><th>32</th><th>16</th><th>8</th><th>4</th><th>2</th><th>1</th></tr>
<tr><td>reserved</td><td>reserved</td><td>reserved</td><td>ZE</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
</table><p>
	For prefix2 the low four bit are fixed, bit 5 is the ZE bit, the other bits are reserved.
</p><p>
	The following table explains the prefix bits.
</p>
<table class="optable">
<tr><th>AM</th><th>Adressing Modes</th></tr>
<tr><td>0</td><td>normal addressing modes (8 / 16 bit)</td></tr>
<tr><td>1</td><td>extended addressing modes (32 / 64 bit)</td></tr>
<tr><th>ZE</th><th>Zero extension</th></tr>
<tr><td>0</td><td>Zero-extend values to full register width when writing to a register</td></tr>
<tr><td>1</td><td>Do not extend values to full register width when writing to a register</td></tr>
<tr><th>RS1/RS0</th><th>Register Size</th></tr>
<tr><td>0/0</td><td>8 bit register</td></tr>
<tr><td>0/1</td><td>16 bit register</td></tr>
<tr><td>1/0</td><td>32 bit register</td></tr>
<tr><td>1/1</td><td>64 bit register</td></tr>
<tr><th>OF1/OF0</th><th>Offset Register</th></tr>
<tr><td>0/0</td><td>No offset added to address</td></tr>
<tr><td>0/1</td><td>Add Program Counter (PC) to address</td></tr>
<tr><td>1/0</td><td>Add Stack Pointer (SP) to address</td></tr>
<tr><td>1/1</td><td>Add Base Offset Register (BR) to address</td></tr>
</table><p>
	These prefix opcodes modify the following opcodes in various aspects. The following opcodes
	are taken from the original 8 bit opcodes. I.e. there could be a new opcode
	</p><pre>
	LDA.L #$12345678
	</pre><p>to load the accumulator with a long (32 bit) value, that is implemented as
	</p><pre>
	23 A9 78 56 34 12
	</pre><p>. Here 23 is the prefix with RS=%10, i.e. 32 bit registers, and A9 is the original
	LDA immediate opcode - only the parameter is now 4 byte (32 bit) not 1 byte anymore.
	</p><p>
	Please note that when all variable prefix bits are zero, the original 6502 operation is executed.
	</p><p>
	Please also note that the order of the prefix bytes is well defined. prefix1 must be before prefix2,
	which is before the actual opcode. This way the prefix1 codes can be reused in the actual prefixed opcode.
	This would not be the case if prefix2 was before prefix1, because then it would not be distinguishable
	of the byte following prefix2 is a prefix1 or a reused opcode.
	</p><p>
	The following table describes which prefix bit is applicable to which opcode:
	</p>
<table class="optable">
<tr><th>LSB-&gt;<br />MSB\</th><th>0</th>		<th>1</th>				<th>2</th>				<th>3</th>					<th>4</th>				<th>5</th>				<th>6</th>				<th>7</th>						<th>8</th>			<th>9</th>				<th>A</th>			<th>B</th>		<th>C</th>				<th>D</th>				<th>E</th>				<th>F</th></tr>
<tr><th>0</th>		<td class="unused"></td>	<td>ORA (zp,X)<br />AM,OF,RS,ZE</td>	<td>LDA zp,Y<br />AM,OF,RS,ZE</td>	<td class="dup">ORA (zp,X)<br />AM,OF,RS,ZE</td>	<td>TSB zp<br />AM,OF,RS</td>		<td>ORA zp<br />AM,OF,RS,ZE</td>		<td>ASL zp<br />AM,OF,RS,ZE</td>		<td class="dup"></td>					<td class="unused"></td>	<td>ORA imm<br />RS,ZE</td>		<td>ASL A<br />RS,ZE</td>	<td class="x"></td>	<td>TSB abs<br />AM,OF,RS,ZE</td>	<td>ORA abs<br />AM,OF,RS,ZE</td>	<td>ASL abs<br />AM,OF,RS</td>		<td>PLB<br />RS,ZE</td></tr>
<tr><th>1</th>		<td>BPL rel<br />RS</td>		<td>ORA (zp),Y<br />AM,OF,RS,ZE</td>	<td>ORA (zp)<br />AM,OF,RS,ZE</td>	<td class="dup">ORA (zp),Y<br />AM,OF,RS,ZE</td>	<td>TRB zp<br />AM,OF,RS</td>		<td>ORA zp,X<br />AM,OF,RS,ZE</td>	<td>ASL zp,X<br />AM,OF,RS,ZE</td>	<td class="dup">ORA (zp)<br />AM,OF,RS,ZE</td>		<td class="unused"></td>	<td>ORA abs,y<br />AM,OF,RS,ZE</td>	<td>INC A<br />RS,ZE</td>	<td class="x"></td>	<td>TRB abs<br />AM,OF,RS,ZE</td>	<td>ORA abs,X<br />AM,OF,RS,ZE</td>	<td>ASL abs,X<br />AM,OF,RS</td>		<td>PHB<br />RS</td></tr>	
<tr><th>2</th>		<td>JSR abs<br />AM,OF,RS</td>	<td>AND (zp,X)<br />AM,OF,RS,ZE</td>	<td>STA zp,Y<br />AM,OF,RS,ZE</td>	<td class="dup">AND (zp,X)<br />AM,OF,RS,ZE</td>	<td>BIT zp<br />AM,OF,RS</td>		<td>AND zp<br />AM,OF,RS,ZE</td>		<td>ROL zp<br />AM,OF,RS,ZE</td>		<td class="dup"></td>					<td class="unused"></td>	<td>AND imm<br />RS,ZE</td>		<td>ROL A<br />RS,ZE</td>	<td class="x"></td>	<td>BIT abs<br />AM,OF,RS,ZE</td>	<td>AND abs<br />AM,OF,RS,ZE</td>	<td>ROL abs<br />AM,OF,RS</td>		<td>SAB<br />RS,ZE</td></tr>
<tr><th>3</th>		<td>BMI rel<br />RS</td>		<td>AND (zp),Y<br />AM,OF,RS,ZE</td>	<td>AND (zp)<br />AM,OF,RS,ZE</td>	<td class="dup">AND (zp),Y<br />AM,OF,RS,ZE</td>	<td>BIT zp,X<br />AM,OF,RS</td>		<td>AND zp,X<br />AM,OF,RS,ZE</td>	<td>ROL zp,X<br />AM,OF,RS,ZE</td>	<td class="dup">AND (zp)<br />AM,OF,RS,ZE</td>		<td class="unused"></td>	<td>AND abs,Y<br />AM,OF,RS,ZE</td>	<td>DEC A<br />RS,ZE</td>	<td class="x"></td>	<td>BIT abs,X<br />AM,OF,RS,ZE</td>	<td>AND abs,X<br />AM,OF,RS,ZE</td>	<td>ROL abs,X<br />AM,OF,RS</td>		<td>PRB<br />RS,ZE</td></tr>
<tr><th>4</th>		<td class="unused"></td>	<td>EOR (zp,X)<br />AM,OF,RS,ZE</td>	<td>LDA (abs),Y<br />AM,OF,RS,ZE</td>	<td class="dup">EOR (zp,X)<br />AM,OF,RS,ZE</td>	<td class="dup">BSR rel<br />RS</td>	<td>EOR zp<br />AM,OF,RS,ZE</td>		<td>LSR zp<br />AM,OF,RS,ZE</td>		<td class="dup">LDA (abs),Y<br />AM,OF,RS,ZE</td>	<td>PHA<br />RS</td>		<td>EOR imm<br />RS,ZE</td>		<td>LSR imm<br />RS,ZE</td>	<td class="x"></td>	<td>JMP abs<br />AM</td>			<td>EOR abs<br />AM,OF,RS,ZE</td>	<td>LSR abs<br />AM,OF,RS</td>		<td>SAX<br />RS,ZE</td></tr>
<tr><th>5</th>		<td>BVC rel<br />RS</td>		<td>EOR (zp),Y<br />AM,OF,RS,ZE</td>	<td>EOR (zp)<br />AM,OF,RS,ZE</td>	<td class="dup">EOR (zp),Y<br />AM,OF,RS,ZE</td>	<td class="dup">BSR rel<br />RS</td>	<td>EOR zp,X<br />AM,OF,RS,ZE</td>	<td>LSR zp,X<br />AM,OF,RS,ZE</td>	<td class="dup">EOR (zp)<br />AM,OF,RS,ZE</td>		<td class="unused"></td>	<td>EOR abs,Y<br />AM,OF,RS,ZE</td>	<td>PHY<br />RS</td>		<td class="x"></td>	<td class="unused"></td>		<td>EOR abs,X<br />AM,OF,RS,ZE</td>	<td>LSR abs,X<br />AM,OF,RS</td>		<td>SAY<br />RS,ZE</td></tr>
<tr><th>6</th>		<td>RTS<br />AM,RS</td>		<td>ADC (zp,X)<br />AM,OF,RS,ZE</td>	<td>LDA (abs,X)<br />AM,OF,RS,ZE</td>	<td class="dup">ADC (zp,X)<br />AM,OF,RS,ZE</td>	<td>STZ zp<br />AM,OF,RS</td>		<td>ADC zp<br />AM,OF,RS,ZE</td>		<td>ROR zp<br />AM,OF,RS,ZE</td>		<td class="dup">LDA (abs,X)<br />AM,OF,RS,ZE</td>	<td>PLA<br />RS,ZE</td>		<td>ADC imm<br />RS,ZE</td>		<td>ROR A<br />RS,ZE</td>	<td class="x"></td>	<td>JMP (abs)<br />AM,OF</td>		<td>ADC abs<br />AM,OF,RS,ZE</td>	<td>ROR abs<br />AM,OF,RS</td>		<td>SXY<br />RS,ZE</td></tr>
<tr><th>7</th>		<td>BVS rel<br />RS</td>		<td>ADC (zp),Y<br />AM,OF,RS,ZE</td>	<td>ADC (zp)<br />AM,OF,RS,ZE</td>	<td class="dup">ADC (zp),Y<br />AM,OF,RS,ZE</td>	<td>STZ zp,X<br />AM,OF,RS</td>		<td>ADC zp,X<br />AM,OF,RS,ZE</td>	<td>ROR zp,X<br />AM,OF,RS,ZE</td>	<td class="dup">ADC (zp)<br />AM,OF,RS,ZE</td>		<td class="unused"></td>	<td>ADC abs,Y<br />AM,OF,RS,ZE</td>	<td>PLY<br />RS,ZE</td>		<td class="x"></td>	<td>JMP (abs,X)<br />AM,OF</td>		<td>ADC abs,X<br />AM,OF,RS,ZE</td>	<td>ROR abs,X<br />AM,OF,RS</td>		<td>NOP zp<br />AM</td></tr>
<tr><th>8</th>		<td>BRA rel<br />RS</td>		<td>STA (zp,X)<br />AM,OF,RS,ZE</td>	<td>BSR rel<br />RS</td>			<td class="dup">STA (zp,X)<br />AM,OF,RS,ZE</td>	<td>STY zp<br />AM,OF,RS</td>		<td>STA zp<br />AM,OF,RS,ZE</td>		<td>STX zp<br />AM,OF,RS</td>		<td class="dup"></td>					<td>DEY<br />RS,ZE</td>		<td>BIT imm<br />RS,ZE</td>		<td>TXA<br />RS,ZE</td>		<td class="x"></td>	<td>STY abs<br />AM,OF,RS</td>		<td>STA abs<br />AM,OF,RS</td>		<td>STX abs<br />AM,OF,RS</td>		<td>NOP abs<br />AM</td></tr>
<tr><th>9</th>		<td>BCC rel<br />RS</td>		<td>STA (zp),Y<br />AM,OF,RS,ZE</td>	<td>STA (zp)<br />AM,OF,RS,ZE</td>	<td class="dup">STA (zp),Y<br />AM,OF,RS,ZE</td>	<td>STY zp,X<br />AM,OF,RS</td>		<td>STA zp,X<br />AM,OF,RS,ZE</td>	<td>STX zp,Y<br />AM,OF,RS</td>		<td class="dup">STA (zp)<br />AM,OF,RS,ZE</td>		<td>TYA<br />RS,ZE</td>		<td>STA abs,Y<br />AM,OF,RS</td>		<td>TXS<br />RS,ZE</td>		<td class="x"></td>	<td>STZ abs<br />AM,OF,RS</td>		<td>STA abs,X<br />AM,OF,RS</td>		<td>STZ abs,X<br />AM,OF,RS</td>		<td>TPA<br />RS,ZE</td></tr>
<tr><th>A</th>		<td>LDY imm<br />RS,ZE</td>	<td>LDA (zp,X)<br />AM,OF,RS,ZE</td>	<td>LDX imm<br />RS</td>			<td class="dup">LDA (zp,X)<br />AM,OF,RS,ZE</td>	<td>LDY zp<br />AM,OF,RS,ZE</td>		<td>LDA zp<br />AM,OF,RS,ZE</td>		<td>LDX zp<br />AM,OF,RS,ZE</td>		<td class="dup"></td>					<td>TAY<br />RS,ZE</td>		<td>LDA imm<br />RS,ZE</td>		<td>TAX<br />RS,ZE</td>		<td class="x"></td>	<td>LDY abs<br />AM,OF,RS,ZE</td>	<td>LDA abs<br />AM,OF,RS,ZE</td>	<td>LDX abs<br />AM,OF,RS,ZE</td>	<td>SWP<br />RS,ZE</td></tr>
<tr><th>B</th>		<td>BCS rel<br />RS</td>		<td>LDA (zp),Y<br />AM,OF,RS,ZE</td>	<td>LDA (zp)<br />AM,OF,RS,ZE</td>	<td class="dup">LDA (zp),Y<br />AM,OF,RS,ZE</td>	<td>LDY zp,X<br />AM,OF,RS,ZE</td>	<td>LDA zp,X<br />AM,OF,RS,ZE</td>	<td>LDX zp,Y<br />AM,OF,RS,ZE</td>	<td class="dup">LDA (zp)<br />AM,OF,RS,ZE</td>		<td class="unused"></td>	<td>LDA abs,Y<br />AM,OF,RS,ZE</td>	<td>TSX</td>			<td class="x"></td>	<td>LDY abs,X<br />AM,OF,RS,ZE</td>	<td>LDA abs,X<br />AM,OF,RS,ZE</td>	<td>LDX abs,Y<br />AM,OF,RS,ZE</td>	<td>CLX<br />RS</td></tr>
<tr><th>C</th>		<td>CPY imm<br />RS</td>		<td>CMP (zp,X)<br />AM,OF,RS</td>	<td>STA (abs),Y<br />AM,OF,RS,ZE</td>	<td class="dup">CMP (zp,X)<br />AM,OF,RS</td>	<td>CPY zp<br />AM,OF,RS</td>		<td>CMP zp<br />AM,OF,RS</td>		<td>DEC zp<br />AM,OF,RS,ZE</td>		<td class="dup"></td>					<td>INY<br />RS,ZE</td>		<td>CMP imm<br />RS</td>			<td>DEX<br />RS,ZE</td>		<td class="x"></td>	<td>CPY abs<br />AM,OF,RS</td>		<td>CMP abs<br />AM,OF,RS</td>		<td>DEC abs<br />AM,OF,RS</td>		<td>CLY<br />RS</td></tr>
<tr><th>D</th>		<td>BNE rel<br />RS</td>		<td>CMP (zp),Y<br />AM,OF,RS</td>	<td>CMP (zp)<br />AM,OF,RS</td>		<td class="dup">CMP (zp),Y<br />AM,OF,RS</td>	<td class="unused"></td>		<td>CMP zp,X<br />AM,OF,RS</td>		<td>DEC zp,X<br />AM,OF,RS,ZE</td>	<td class="dup">CMP (zp)<br />AM,OF,RS</td>		<td class="unused"></td>	<td>CMP abs,Y<br />AM,OF,RS</td>		<td>PHX<br />RS</td>		<td class="x"></td>	<td>JSR (abs)<br />AM,OF,RS</td>		<td>CMP abs,X<br />AM,OF,RS</td>		<td>DEC abs,X<br />AM,OF,RS</td>		<td class="dup">JSR (abs)<br />AM,OF,RS</td></tr>
<tr><th>E</th>		<td>CPX imm<br />RS</td>		<td>SBC (zp,X)<br />AM,OF,RS,ZE</td>	<td>STA (abs,X)<br />AM,OF,RS,ZE</td>	<td class="dup">SBC (zp,X)<br />AM,OF,RS,ZE</td>	<td>CPX zp<br />AM,OF,RS</td>		<td>SBC zp<br />AM,OF,RS,ZE</td>		<td>INC zp<br />AM,OF,RS,ZE</td>		<td class="dup"></td>					<td>INX<br />RS,ZE</td>		<td>SBC imm<br />RS,ZE</td>		<td class="unused"></td>	<td class="x"></td>	<td>CPX abs<br />AM,OF,RS</td>		<td>SBC abs<br />AM,OF,RS,ZE</td>	<td>INC abs<br />AM,OF,RS</td>		<td>CLA<br />RS</td></tr>
<tr><th>F</th>		<td>BEQ rel<br />RS</td>		<td>SBC (zp),Y<br />AM,OF,RS,ZE</td>	<td>SBC (zp)<br />AM,OF,RS,ZE</td>	<td class="dup">SBC (zp),Y<br />AM,OF,RS,ZE</td>	<td class="unused">TRAP<br />RS</td>	<td>SBC zp,X<br />AM,OF,RS,ZE</td>	<td>INC zp,X<br />AM,OF,RS,ZE</td>	<td class="dup">SBC (zp)<br />AM,OF,RS,ZE</td>		<td class="unused"></td>	<td>SBC abs,Y<br />AM,OF,RS,ZE</td>	<td>PLX<br />RS,ZE</td>		<td class="x"></td>	<td>JSR (abs,X)<br />AM,OF,RS</td>	<td>SBC abs,X<br />AM,OF,RS,ZE</td>	<td>INC abs,X<br />AM,OF,RS</td>		<td class="dup">JSR (abs,X)<br />AM,OF,RS</td></tr>
</table>	<p>
	</p><p>
	Note that the Register size option for the RTS and JSR opcodes determine the size of the 
	return address as put on the stack (with the 8 bit register size option also mapping to the
	16 bit address width).
	</p><p>
	The Register size option for the branch opcodes determines the size of the relative address
	offset. For the BSR opcode this is in conflict with the size options for the address on 
	the stack. Therefore there are two duplicate opcodes for BSR, which all have a different
	size of the return address on the stack.
	</p><p>
	The following sections describe the different options in mode detail:
	</p>
	<h3>Addressing Modes</h3>
	<p>The addressing modes bit AM allows to extend the existing addressing modes from zeropage (8 bit) and
	absolute (16 bit) to long (32 bit) and longlong (64 bit). The following table shows the
	modifications when AM is set.</p>
<table class="optable">
<tr><th>Original Addressing Mode</th><th>New Addressing Mode</th><th>Comment</th></tr>
<tr><td>zp</td><td>long</td><td>use a long (32 bit) address instead of a zeropage address</td></tr>
<tr><td>zp,X</td><td>long,X</td><td>use a long (32 bit) address instead of a zeropage address</td></tr>
<tr><td>zp,Y</td><td>long,Y</td><td>use a long (32 bit) address instead of a zeropage address</td></tr>
<tr><td>abs</td><td>longlong</td><td>use a longlong (64 bit) address instead of an absolute address</td></tr>
<tr><td>abs,X</td><td>longlong,X</td><td>use a longlong (64 bit) address instead of an absolute address</td></tr>
<tr><td>abs,Y</td><td>longlong,Y</td><td>use a longlong (64 bit) address instead of an absolute address</td></tr>
<tr><td>(zp)</td><td>[zp]</td><td>from the given zeropage location, read a long address instead of an absolute address</td></tr>
<tr><td>(zp),Y</td><td>[zp],Y</td><td>from the given zeropage location, read a long address instead of an absolute address, then add YR</td></tr>
<tr><td>(zp,X)</td><td>[zp,X]</td><td>from the given zeropage location (plus XR as given by the addressing mode), read a long address instead of an absolute address</td></tr>
<tr><td>(abs)</td><td>[abs]</td><td>from the given absolute location, read a long address instead of an absolute address</td></tr>
<tr><td>(abs),Y</td><td>[abs],Y</td><td>from the given absolute location, read a long address instead of an absolute address, then add YR</td></tr>
<tr><td>(abs,X)</td><td>[abs,X]</td><td>from the given absolute location (plus XR as given by the addressing mode), read a long address instead of an absolute address</td></tr>
<tr><td class="dup">(zp)</td><td>[[zp]]</td><td>from the given zeropage location, read a long address instead of an absolute address</td></tr>
<tr><td class="dup">(zp),Y</td><td>[[zp]],Y</td><td>from the given zeropage location, read a longlong address instead of an absolute address, then add YR</td></tr>
<tr><td class="dup">(zp,X)</td><td>[[zp,X]]</td><td>from the given zeropage location (plus XR as given by the addressing mode), read a longlong address instead of an absolute address</td></tr>
<tr><td class="dup">(abs)</td><td>[[abs]]</td><td>from the given absolute location, read a longlong address instead of an absolute address</td></tr>
<tr><td class="dup">(abs),Y</td><td>[[abs]],Y</td><td>from the given absolute location, read a longlong address instead of an absolute address, then add YR</td></tr>
<tr><td class="dup">(abs,X)</td><td>[[abs,X]]</td><td>from the given absolute location (plus XR as given by the addressing mode), read a longlong address instead of an absolute address</td></tr>
<tr><td>imm</td><td>imm</td><td>unchanged</td></tr>
<tr><td>implied</td><td>implied</td><td>unchanged</td></tr>
<tr><td>rel</td><td>rel</td><td>unchanged</td></tr>
</table><p>
	Normally not all addressing modes would be supported with direct addressing mode replacements. 
	The longlong indirect addressing modes
	are not reached. Thus the indirect opcodes are mirrored, and extended from long to longlong indirect 
	addressing modes.
	Row LSB 1 is mirrored thus to row LSB 3, as well as row LSB 2 is mirrored to LSB 7.
	These values are marked with a green background in the table. The LSB 3 and 7 rows then change from
	indirect addressing modes to longlong indirect addressing modes.
	</p><p>
	Also note that there a are no indirect addressing modes that take a long or longlong value as indirect address.
	</p><p>
	TODO: JMP and JSR opcodes?
	</p>
	<h3>Offset</h3>
	<p>
	The offset prefix bits allows to add an address offset to the effective address of the operand.
	Four options are available:
	</p><table class="optable">
	<tr><th>OF1/0</th><th>Register</th><th>Register Name</th><th>Syntax</th><th>Examples</th></tr>
	<tr><td>00</td><td>-</td><td>no register value added</td><td>-</td><td>LDA $1234</td></tr>
	<tr><td>01</td><td>PC</td><td>Program Counter</td><td>Address prefix P,</td><td>LDA P,$1234; LDA (P,$12),Y</td></tr>
	<tr><td>10</td><td>SR</td><td>Stack Pointer</td><td>Address prefix S,</td><td>LDA S,$1234; LDA [S,$23,X]</td></tr>
	<tr><td>11</td><td>BR</td><td>Base Register</td><td>Address prefix B,</td><td>LDA B,$1234; LDA B,$12,X</td></tr>
	</table><p>
	For (non-indirect) zeropage/absolute and indexed addressing modes to compute the effective address
	the standard addressing mode effective address is computed, then the register value is added to get the
	final effective address.
	</p><p>
	For the indirect addressing mode that situation is more complex. The offset register value is added
	to the zeropage or absolute address given in the opcode, to compute the indirect address.
	For indexed with XR addressing modes XR is added to this address to get the real indirect address.
	Then the effective address is read from the computed indirect address, for indexed with YR then 
	the value of YR is added to the address read, to get the real effective address. Here the offset
	is not added again.
	</p><p>
	Note that the size of the address read from the indirect address is defined by the addressing mode
	alone (which is also determined by the AM prefix bit).
	</p>
	<h3>Register Size</h3>
	<p>
	The maximum register size depends on the used processor option. Each operation has a possibly smaller width.
	The Register size prefix defines the operation width. I.e. this determines the number of bytes to read from
	memory (from the effective address), the number of bytes to store to memory, or the number bytes to use
	from resp. store in a register.
	</p><p>
	The different width prefixes are written as postfixes to the opcode:
	</p>
	<table class="optable">
	<tr><th>RS1/0</th><th>width</th><th>Postfix</th><th>Example</th></tr>
	<tr><td>00</td><td>8</td><td></td><td>LDA #$12</td></tr>
	<tr><td>01</td><td>16</td><td>.W</td><td>LDA.W #$1234</td></tr>
	<tr><td>10</td><td>32</td><td>.L</td><td>LDA.L #$12345678</td></tr>
	<tr><td>11</td><td>64</td><td>.LL</td><td>LDA.LL #$123456789ABCDEF0</td></tr>
	</table><p>
	Please note that 8 bit width has no postfix.
	</p><p>
	TODO: rename to "OS" = "Operation size" or "OW" = "Operation width"?
	</p>
	<h3>Zero Extension</h3>
	<p>
	The registers have a defined width - depending on processor option - of 16, 32 or 64 bit. Operations can be
	from 8 to 64 bit. When the result of an operation is written to a memory location, the data is written
	in the same width as the operation. If the result of the operation is written to a register, the register
	is extended with zeros to full length.
	</p><p>
	For some operations the operation should only replace the lower part of the register, and keep the upper part
	of the register unmodified. This can be achieved with the ZE bit.
	</p><p>
	The ZE bit is denoted with a ".Z" bit - "no Zero extension" - to the opcode. Thus
	</p><pre>
	LDA.W #$1234
	LDA.Z #$56
	</pre><p>results in the value $1256 in the Accumulator.
    	</p>
	<h3><a name="ovquick" id="ovquick">Quick Opcodes</a></h3><p>These opcodes are defined by the "QUICK prefix" byte, being followed by an additional opcode byte.
	These opcodes may still even be modified by the prefix1 and prefix2 opcodes though!
	</p><p>
	The QUICK opcodes provide a way to "quickly" do repetitive operations which require multiple opcodes on the 
	6502 - like INY with an increment larger than one for example.
	</p><p>
	The following table describes the opcodes:</p>
<table class="optable">
<tr><th>LSB-&gt;<br />MSB\</th><th>0</th>	<th>1</th>		<th>2</th>		<th>3</th>		<th>4</th>		<th>5</th>		<th>6</th>		<th>7</th>		<th>8</th>		<th>9</th>		<th>A</th>		<th>B</th>		<th>C</th>	<th>D</th>	<th>E</th>	<th>F</th></tr>
<tr><th>0</th>		<td>INY #1</td>		<td>INX #1</td>		<td>INC A #1</td>	<td>ROL A #1</td>	<td>ASL A #1</td>	<td>INC #1, zp</td>	<td>ROL #1, zp</td>	<td>ASL #1, zp</td>	<td>INC #1, (E)</td>	<td>ROL #1, (E)</td>	<td>ASL #1, (E)</td>	<td>INE #1</td>		<td>INB #1</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>1</th>		<td>INY #2</td>		<td>INX #2</td>		<td>INC A #2</td>	<td>ROL A #2</td>	<td>ASL A #2</td>	<td>INC #2, zp</td>	<td>ROL #2, zp</td>	<td>ASL #2, zp</td>	<td>INC #2, (E)</td>	<td>ROL #2, (E)</td>	<td>ASL #2, (E)</td>	<td>INE #2</td>		<td>INB #2</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>2</th>		<td>INY #3</td>		<td>INX #3</td>		<td>INC A #3</td>	<td>ROL A #3</td>	<td>ASL A #3</td>	<td>INC #3, zp</td>	<td>ROL #3, zp</td>	<td>ASL #3, zp</td>	<td>INC #3, (E)</td>	<td>ROL #3, (E)</td>	<td>ASL #3, (E)</td>	<td>INE #3</td>		<td>INB #3</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>3</th>		<td>INY #4</td>		<td>INX #4</td>		<td>INC A #4</td>	<td>ROL A #4</td>	<td>ASL A #4</td>	<td>INC #4, zp</td>	<td>ROL #4, zp</td>	<td>ASL #4, zp</td>	<td>INC #4, (E)</td>	<td>ROL #4, (E)</td>	<td>ASL #4, (E)</td>	<td>INE #4</td>		<td>INB #4</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>4</th>		<td>INY #5</td>		<td>INX #5</td>		<td>INC A #5</td>	<td>ROL A #5</td>	<td>ASL A #5</td>	<td>INC #5, zp</td>	<td>ROL #5, zp</td>	<td>ASL #5, zp</td>	<td>INC #5, (E)</td>	<td>ROL #5, (E)</td>	<td>ASL #5, (E)</td>	<td>INE #5</td>		<td>INB #5</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>5</th>		<td>INY #6</td>		<td>INX #6</td>		<td>INC A #6</td>	<td>ROL A #6</td>	<td>ASL A #6</td>	<td>INC #6, zp</td>	<td>ROL #6, zp</td>	<td>ASL #6, zp</td>	<td>INC #6, (E)</td>	<td>ROL #6, (E)</td>	<td>ASL #6, (E)</td>	<td>INE #6</td>		<td>INB #6</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>6</th>		<td>INY #7</td>		<td>INX #7</td>		<td>INC A #7</td>	<td>ROL A #7</td>	<td>ASL A #7</td>	<td>INC #7, zp</td>	<td>ROL #7, zp</td>	<td>ASL #7, zp</td>	<td>INC #7, (E)</td>	<td>ROL #7, (E)</td>	<td>ASL #7, (E)</td>	<td>INE #7</td>		<td>INB #7</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>7</th>		<td>INY #8</td>		<td>INX #8</td>		<td>INC A #8</td>	<td>ROL A #8</td>	<td>ASL A #8</td>	<td>INC #8, zp</td>	<td>ROL #8, zp</td>	<td>ASL #8, zp</td>	<td>INC #8, (E)</td>	<td>ROL #8, (E)</td>	<td>ASL #8, (E)</td>	<td>INE #8</td>		<td>INB #8</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>8</th>		<td>DEY #1</td>		<td>DEX #1</td>		<td>DEC A #1</td>	<td>ROR A #1</td>	<td>LSR A #1</td>	<td>DEC #1, zp</td>	<td>ROR #1, zp</td>	<td>LSR #1, zp</td>	<td>DEC #1, (E)</td>	<td>ROR #1, (E)</td>	<td>LSR #1, (E)</td>	<td>DEE #1</td>		<td>DEB #1</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>9</th>		<td>DEY #2</td>		<td>DEX #2</td>		<td>DEC A #2</td>	<td>ROR A #2</td>	<td>LSR A #2</td>	<td>DEC #2, zp</td>	<td>ROR #2, zp</td>	<td>LSR #2, zp</td>	<td>DEC #2, (E)</td>	<td>ROR #2, (E)</td>	<td>LSR #2, (E)</td>	<td>DEE #2</td>		<td>DEB #2</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>A</th>		<td>DEY #3</td>		<td>DEX #3</td>		<td>DEC A #3</td>	<td>ROR A #3</td>	<td>LSR A #3</td>	<td>DEC #3, zp</td>	<td>ROR #3, zp</td>	<td>LSR #3, zp</td>	<td>DEC #3, (E)</td>	<td>ROR #3, (E)</td>	<td>LSR #3, (E)</td>	<td>DEE #3</td>		<td>DEB #3</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>B</th>		<td>DEY #4</td>		<td>DEX #4</td>		<td>DEC A #4</td>	<td>ROR A #4</td>	<td>LSR A #4</td>	<td>DEC #4, zp</td>	<td>ROR #4, zp</td>	<td>LSR #4, zp</td>	<td>DEC #4, (E)</td>	<td>ROR #4, (E)</td>	<td>LSR #4, (E)</td>	<td>DEE #4</td>		<td>DEB #4</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>C</th>		<td>DEY #5</td>		<td>DEX #5</td>		<td>DEC A #5</td>	<td>ROR A #5</td>	<td>LSR A #5</td>	<td>DEC #5, zp</td>	<td>ROR #5, zp</td>	<td>LSR #5, zp</td>	<td>DEC #5, (E)</td>	<td>ROR #5, (E)</td>	<td>LSR #5, (E)</td>	<td>DEE #5</td>		<td>DEB #5</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>D</th>		<td>DEY #6</td>		<td>DEX #6</td>		<td>DEC A #6</td>	<td>ROR A #6</td>	<td>LSR A #6</td>	<td>DEC #6, zp</td>	<td>ROR #6, zp</td>	<td>LSR #6, zp</td>	<td>DEC #6, (E)</td>	<td>ROR #6, (E)</td>	<td>LSR #6, (E)</td>	<td>DEE #6</td>		<td>DEB #6</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>E</th>		<td>DEY #7</td>		<td>DEX #7</td>		<td>DEC A #7</td>	<td>ROR A #7</td>	<td>LSR A #7</td>	<td>DEC #7, zp</td>	<td>ROR #7, zp</td>	<td>LSR #7, zp</td>	<td>DEC #7, (E)</td>	<td>ROR #7, (E)</td>	<td>LSR #7, (E)</td>	<td>DEE #7</td>		<td>DEB #7</td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>F</th>		<td>DEY #8</td>		<td>DEX #8</td>		<td>DEC A #8</td>	<td>ROR A #8</td>	<td>LSR A #8</td>	<td>DEC #8, zp</td>	<td>ROR #8, zp</td>	<td>LSR #8, zp</td>	<td>DEC #8, (E)</td>	<td>ROR #8, (E)</td>	<td>LSR #8, (E)</td>	<td>DEE #8</td>		<td>DEB #8</td>	<td></td>	<td></td>	<td></td></tr>
</table>
	<p>Here is the description of the new opcodes:</p>
	<ul>
	<li>INE - increment E register by values 1 to 8</li>
	<li>DEE - decrement E register by values 1 to 8</li>
	<li>INB - increment B register by values 1 to 8</li>
	<li>DEB - increment B register by values 1 to 8</li>
	</ul>
    	<h3><a name="ovfp" id="ovfp">EXT opcodes</a></h3><p>These opcodes extend the opcode space with rarely used, but still useful general purpose
	opcodes.
	</p>
<table class="optable">
<tr><th>LSB-&gt;<br />MSB\</th><th>0</th>	<th>1</th>			<th>2</th>			<th>3</th>	<th>4</th>			<th>5</th>			<th>6</th>		<th>7</th>	<th>8</th>	<th>9</th>			<th>A</th>		<th>B</th>	<th>C</th>			<th>D</th>			<th>E</th>		<th>F</th></tr>
<tr><th>0</th>		<td></td>		<td></td>			<td>LEA zp,Y<br />AM,OF</td>	<td></td>	<td>MVN</td>			<td></td>			<td></td>		<td></td>	<td></td>	<td>ORA (E)<br />RS,ZE</td>	<td>BCN<br />RS</td>	<td></td>	<td>TSB (E)<br />RS,ZE</td>	<td></td>			<td>BCN (E)<br />RS</td>	<td></td></tr>
<tr><th>1</th>		<td></td>		<td></td>			<td></td>			<td></td>	<td>MVP</td>			<td></td>			<td></td>		<td></td>	<td></td>	<td></td>			<td></td>		<td></td>	<td>TRB (E)<br />RS,ZE</td>	<td></td>			<td></td>		<td></td></tr>	
<tr><th>2</th>		<td>JSR (E)<br />RS</td>	<td></td>			<td>PEA zp,Y<br />AM,OF</td>	<td></td>	<td></td>			<td></td>			<td>ADE imm<br />RS,ZE</td><td></td>	<td></td>	<td>AND (E)<br />RS,ZE</td>	<td></td>		<td></td>	<td></td>			<td></td>			<td></td>		<td></td></tr>
<tr><th>3</th>		<td></td>		<td></td>			<td></td>			<td></td>	<td></td>			<td></td>			<td></td>		<td></td>	<td></td>	<td>LDE imm<br />RS,ZE</td>	<td></td>		<td></td>	<td></td>			<td></td>			<td></td>		<td></td></tr>
<tr><th>4</th>		<td></td>		<td></td>			<td>LEA (abs),Y<br />AM,OF</td>	<td></td> 	<td></td>			<td></td>			<td>ADS imm<br />RS,ZE</td><td></td>	<td></td>	<td>EOR (E)<br />RS,ZE</td>	<td></td>		<td></td>	<td>JMP (E)</td>		<td></td>			<td></td>		<td></td></tr>
<tr><th>5</th>		<td></td>		<td></td>			<td></td>			<td></td>	<td></td>			<td></td>			<td></td>		<td></td>	<td></td>	<td></td>			<td></td>		<td></td>	<td></td>			<td></td>			<td></td>		<td></td></tr>
<tr><th>6</th>		<td></td>		<td></td>			<td>LEA (abs,X)<br />AM,OF</td>	<td></td>	<td></td>			<td></td>			<td>ADB imm<br />RS,ZE</td><td></td>	<td></td>	<td>ORA (E)<br />RS,ZE</td>	<td></td>		<td></td>	<td></td>			<td></td>			<td></td>		<td></td></tr>
<tr><th>7</th>		<td></td>		<td></td>			<td></td>			<td></td>	<td></td>			<td></td>			<td></td>		<td></td>	<td></td>	<td></td>			<td></td>		<td></td>	<td></td>			<td></td>			<td></td>		<td></td></tr>
<tr><th>8</th>		<td>LEA rel<br />RS</td>	<td>PEA (zp,X)<br />AM,OF</td>	<td>PEA rel<br />RS</td>		<td></td>	<td>SCA (E)<br />RS</td>		<td>PEA zp<br />AM,OF</td>	<td></td>		<td></td>	<td></td>	<td>BIT (E)<br />RS,ZE</td>	<td>TEA</td>		<td></td>	<td></td>			<td>PEA abs<br />AM,OF</td>	<td></td>		<td></td></tr>
<tr><th>9</th>		<td></td>		<td>PEA (zp),Y<br />AM,OF</td>	<td>PEA (zp)<br />AM,OF</td>	<td></td>	<td>WMB</td>			<td>PEA zp,X<br />AM,OF</td>	<td>WMB (E)</td>	<td></td>	<td></td>	<td>PEA abs,Y<br />AM,OF</td>	<td>TYS</td>		<td></td>	<td>STZ (E)<br />RS</td>		<td>PEA abs,X<br />AM,OF</td>	<td></td>		<td></td></tr>
<tr><th>A</th>		<td>LDY (E)<br />RS,ZE</td><td>LEA (zp,X)<br />AM,OF</td>	<td>LDX (E)<br />RS,ZE</td>	<td></td>	<td>LLA (E)<br />RS,ZE</td>	<td>LEA zp<br />AM,OF</td>	<td>SBE imm<br />RS,ZE</td><td></td>	<td></td>	<td>LDA (E)<br />RS,ZE</td>	<td>TAE</td>		<td></td>	<td></td>			<td>LEA abs<br />AM,OF</td>	<td></td>		<td></td></tr>
<tr><th>B</th>		<td></td>		<td>LEA (zp),Y<br />AM,OF</td>	<td>LEA (zp)<br />AM,OF</td>	<td></td>	<td>RMB</td>			<td>LEA zp,X<br />AM,OF</td>	<td>RMB (E)</td>	<td></td>	<td></td>	<td>LEA abs,Y<br />AM,OF</td>	<td>TSY</td>		<td></td>	<td></td>			<td>LEA abs,X<br />AM,OF</td>	<td></td>		<td></td></tr>
<tr><th>C</th>		<td>CPY (E)<br />RS</td>	<td></td>			<td>PEA (abs),Y<br />AM,OF</td>	<td></td>	<td></td>			<td></td>			<td>SBS imm<br />RS,ZE</td><td></td>	<td></td>	<td>CMP (E)<br />RS,ZE</td>	<td></td>		<td></td>	<td></td>			<td></td>			<td></td>		<td></td></tr>
<tr><th>D</th>		<td></td>		<td></td>			<td></td>			<td></td>	<td></td>			<td></td>			<td></td>		<td></td>	<td></td>	<td></td>			<td>PHE</td>		<td></td>	<td></td>			<td></td>			<td></td>		<td></td></tr>
<tr><th>E</th>		<td>CPX (E)<br />RS</td>	<td></td>			<td>PEA (abs,X)<br />AM,OF</td>	<td></td>	<td></td>			<td></td>			<td>SBB imm<br />RS,ZE</td><td></td>	<td></td>	<td>SBC (E)<br />RS,ZE</td>	<td></td>		<td></td>	<td></td>			<td></td>			<td></td>		<td></td></tr>
<tr><th>F</th>		<td></td>		<td></td>			<td></td>			<td></td>	<td></td>			<td></td>			<td></td>		<td></td>	<td></td>	<td></td>			<td>PLE</td>		<td></td>	<td></td>			<td></td>			<td></td>		<td></td></tr>
</table>    
	<p>Note that including the prefix bytes an opcode may be three bytes long (prefix1, EXT prefix, and opcode). 
	Prefix2 is (currently) not used with EXT opcodes.
	</p><p>
	Here are short explanations of the new opcodes:</p>
	<ul>
	<li>LEA - Load Effective Address: compute the effective address and store it in the E (effective Address) register (always full width)</li>
	<li>LDE - Load value into E (effective address) register</li>
	<li>TAE - transfer Accumulator to E register</li>
	<li>TEA - transfer E register to Accumulator</li>
	<li>PEA - Push Effective Address: compute the effective address and push it on the stack [1]</li>
	<li>ADE - ADd to E register</li>
	<li>ADB - ADd to B register</li>
	<li>ADS - ADd to Stack pointer</li>
	<li>SBE - SuBstract from E register</li>
	<li>SBB - SuBstract from B register</li>
	<li>SBS - SuBstract from Stack pointer</li>
	<li>BCN - Bit Count: counts 1-bits in AC or in given location, stores number of 1-bits back in AC</li>
	<li>MVN - Move block of data of size AC from XR to YR, count addresses down. All registers full size, interruptable</li>
	<li>MVP - Move block of data of size AC from XR to YR, count addresses up. All registers full size, interruptable</li>
	<li>LLA - Load Linked AC, i.e. monitor given address for changes</li>
	<li>SCA - Store Conditional AC, succeeds only if address has not been externally modified. Sets overflow V bit on error</li>
	<li>RMB - Read memory barrier: invalidates cache content (globally, or for a specific, given location)</li>
	<li>WMB - Write memory barrier: flushes dirty caches (globally, or for a specific, given location)</li>
	</ul><p>Notes:</p>
	<ol>
	<li>The RS prefix determines the computation width of the effective address. 
		The value is always sign-extended, ZE prefix is not supported.
		The Overflow bit V is set 
		when the effective address is larger than what is possible with the given RS prefix</li>
	</ol>
	<p>TODO: Mult/Div opcodes; Interrupt base register opcodes</p>
	<h3><a name="ovfp" id="ovfp">FP opcodes</a></h3><p>
	Note: this section still needs to be worked out.
    	</p><h3><a name="ovmmu" id="ovmmu">Blitter opcodes</a></h3><p>
	Note: this section still needs to be worked out. It is not clear if the blitter opcodes
	could not be implemented column in the SYS opcodes table. Blitter opcodes would be 
	privileged.
    	</p><h3><a name="ovsys" id="ovsys">SYS opcodes</a></h3><p>This section gives an overview over the system opcodes that handle system
	configuration registers etc. These opcodes are all privileged.
	</p>
<table class="optable">
<tr><th>LSB-&gt;<br />MSB\</th><th>0</th><th>1</th>	<th>2</th>	<th>3</th>	<th>4</th>	<th>5</th>	<th>6</th>	<th>7</th>	<th>8</th>	<th>9</th>	<th>A</th>	<th>B</th>	<th>C</th>	<th>D</th>	<th>E</th>	<th>F</th></tr>
<tr><th>0</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td>TAI</td></tr>
<tr><th>1</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td>TIA</td></tr>	
<tr><th>2</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td>TAT</td></tr>
<tr><th>3</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td>TTA</td></tr>
<tr><th>4</th>		<td></td>	<td></td>	<td></td>	<td></td> 	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>5</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>6</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>7</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>8</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>9</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>A</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>B</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>C</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>D</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>E</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td></tr>
<tr><th>F</th>		<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td>	<td></td></tr>
</table><p>Here is a short explanation of the new opcodes</p>
	<ul>
	<li>TAI - transfer accumulator to interrupt base register</li>
	<li>TIA - transfer interrupt base register to accumulator</li>
	<li>TAT - transfer accumulator to trap vector base register</li>
	<li>TTA - transfer trap vector base register to accumulator</li>
	</ul>
    	</div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="sys" id="sys">System Environment</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><p>
	This section describes the general system environment
    </p><h3><a name="reset" id="reset">Reset</a></h3><p>
	Upon Reset the processor fetches a two-byte Reset vector from "-4".
	In a 16 bit processor option this translates to the original 6502's
	$FFFC reset vector.
	</p><p>
	In a system with a larger address bus, the address is sign-extended, i.e.
	the vector is either pulled from $FFFFFFFC or $FFFFFFFFFFFFFFFC.
	</p><p>
	The two-byte vector read from that address is then again sign-extended to
	compute the effective address to jump to.
	</p><p>
	Any address translation features if available are disabled on reset. I.e. the computed
	address(es) computed here are physical addresses. 
	</p><p>
	If a supervisor mode feature is available, the processor goes into supervisor mode.
      </p><h3><a name="int" id="int">Interrupts</a></h3><p>
	The processor can have a number of interrupt lines. For each of the
	interrupt lines a separate interrupt vector can be used. I.e. interrupts
	are numbered, and the number is used as index in a table of interrupt vectors.
	The interrupt vectors are fetched from an address that is determined
	by the interrupt base register, I.
	</p><p>
	The interrupt base register determines the address of a 256 byte 
	aligned block with interrupt vectors, i.e. the register's lowest 8 bit are unused.
	The interrupt vectors are counted down from the top of the block.
	I.e. the default Reset vector is an interrupt as well. The BRK opcode 
	fetches the uppermost interrupt vector.
	</p><p>
	These interrupt base register bits can be used as configuration.
	The two lowest bits determine the size of the interrupt vector.
	"0x" means abs (two byte), "10" means long (four byte), 
	"11" means longlong (eight byte) interrupt vector size.
	The interrupt number is shifted appropriately, by 1, 2, or 4 bit so that
	interrupt vectors form a list of consecutive values.
	</p><p>
	Upon reset the register is initialized to $FFFFFFFFFFFFFF00.
	The following table shows the different options:
	</p>
	<table class="optable">
	<tr><th>Default interrupt base:</th><th>$FFFFFFFFFFFFFF00</th></tr>
	<tr><td>$FFFFFFFFFFFFFFFE/F</td><td>BRK vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFFC/D</td><td>Reset vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFFA/B</td><td>Abort vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF8/9</td><td>Interrupt 0 vector (NMI)</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF6/7</td><td>Interrupt 1 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF4/5</td><td>Interrupt 2 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF2/3</td><td>Interrupt 3 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF0/1</td><td>Interrupt 4 vector</td></tr>
	<tr><th>Interrupt base:</th><th>$FFFFFFFFFFFFFF02</th></tr>
	<tr><td>$FFFFFFFFFFFFFFFC/D/E/F</td><td>BRK vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF8/9/A/B</td><td>Reset vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF4/5/6/7</td><td>Abort vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF0/1/2/3</td><td>Interrupt 0 vector (NMI)</td></tr>
	<tr><td>$FFFFFFFFFFFFFFEC/D/E/F</td><td>Interrupt 1 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFE8/9/A/B</td><td>Interrupt 2 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFE4/5/6/7</td><td>Interrupt 3 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFE0/1/2/3</td><td>Interrupt 4 vector</td></tr>
	<tr><th>Interrupt base:</th><th>$FFFFFFFFFFFFFF03</th></tr>
	<tr><td>$FFFFFFFFFFFFFFF8/9/A/B/C/D/E/F</td><td>BRK vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFF0/1/2/3/4/4/6/7</td><td>Reset vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFE8/9/A/B/C/D/E/F</td><td>Abort vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFE0/1/2/3/4/5/6/7</td><td>Interrupt 0 vector (NMI)</td></tr>
	<tr><td>$FFFFFFFFFFFFFFD8/9/A/B/C/D/E/F</td><td>Interrupt 1 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFD0/1/2/3/4/5/6/7</td><td>Interrupt 2 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFC8/9/A/B/C/D/E/F</td><td>Interrupt 3 vector</td></tr>
	<tr><td>$FFFFFFFFFFFFFFC0/1/2/3/4/5/6/7</td><td>Interrupt 4 vector</td></tr>
	<tr><th>Interrupt base:</th><th>$000000000000FF00</th></tr>
	<tr><td>$000000000000FFFE/F</td><td>BRK vector</td></tr>
	<tr><td>$000000000000FFFC/D</td><td>Reset vector</td></tr>
	<tr><td>$000000000000FFFA/B</td><td>Abort vector</td></tr>
	<tr><td>$000000000000FFF8/9</td><td>Interrupt 0 vector (NMI)</td></tr>
	<tr><td>$000000000000FFF6/7</td><td>Interrupt 1 vector</td></tr>
	<tr><td>$000000000000FFF4/5</td><td>Interrupt 2 vector</td></tr>
	<tr><td>$000000000000FFF2/3</td><td>Interrupt 3 vector</td></tr>
	<tr><td>$000000000000FFF0/1</td><td>Interrupt 4 vector</td></tr>
	</table>
	<p>Note: all unused bits must be set to zero</p>
      <h3><a name="trap" id="trap">Trap handling</a></h3><p>
	The 65k has a TRAP opcode that allows to trap from a program into supervisor mode
	(if available), resp. into a system program via a given trap vector.
	The current version allows for 256 trap vectors, as the trap operand is byte-wide.
      </p><p>
	The trap handling is similar to the interrupt handling. There is a trap vector base
	register similar to the interrupt base register. Again the lowest two bit of the
	trap vector base register determine the size of the vector used. 
      </p><p>
	As there are 256 trap vectors, with 2 byte vectors the trap table is 
	512 byte. With 4 byte vectors the trap table is 1024 bytes, and 2048 bytes
	for 8 byte vectors. Therefore the used bits from the trap vector base register
	differ. For 2 byte vectors all but the lowest 9 bit from the register are
	used, for 4 byte vectors all but the lowest 10 bit from the register are used
	and all but the lowest 11 bit from the vector are used. This way the used
	part of the register can simply be ORd with the shifted trap number to compute
	the effective vector address.
      </p><p>
	As a possible extension the bits 2/3 of the trap vector base register are reserved and
	must be set to zero. In later extensions they can be used to define larger tables for 
	more TRAP operands.
      </p>
	<table class="optable">
	<tr><th>Default trap vector base:</th><th>$FFFFFFFFFFFFFE00</th></tr>
	<tr><td>$FFFFFFFFFFFFFFFE/F</td><td>TRAP #$FF</td></tr>
	<tr><td>...</td><td>...</td></tr>
	<tr><td>$FFFFFFFFFFFFFFE0/1</td><td>TRAP #$00</td></tr>
	<tr><th>trap vector base:</th><th>$FFFFFFFFFFFFF803</th></tr>
	<tr><td>$FFFFFFFFFFFFFFF8/9/A/B/C/D/E/F</td><td>TRAP #$FF</td></tr>
	<tr><td>...</td><td>...</td></tr>
	<tr><td>$FFFFFFFFFFFFF800/1/2/3/4/5/6/7</td><td>TRAP #$00</td></tr>
	</table>
      <p>
	Note: all unused bits must be set to zero
      </p><h3><a name="intproc" id="intproc">Interrupt and Trap Procedure</a></h3><p>
	What happens when an interrupt or a trap occurs? The interrupt procedure is very similar to the
	original 6502 interrupt.
      </p><p>
	First the program counter is written to the stack. 
	As the program counter can be wider than the original 6502's program counter, the value
	written on the stack can be variable width. I.e. if the address is a "canonical address" - 
	the uppermost 33 resp. 49 bits are all ones, or all zeros (i.e. sign-extended 
	32 resp. 16 bit address values) the value written on the stack can be shortened.
      </p><p>
	After the address the extended status register is written to the stack. I.e. first the 
	high status byte, then the low status byte (that mirrors the original 6502 status register).
	The high status byte contains two address width bits that allow the RTI opcode to determine
	the width of the stored return address.
      </p><p>
	After that the respective address vector is fetched and jumped to.
      </p><p>
	This procedure means that similar to the 6502 no other registers are stored on the stack, 
	this must be done by the interrupt routine.
      </p><h3><a name="cont" id="cont">Container</a></h3><p>
	Container are an optional feature together with the hypervisor mode.
	A container confines the processor into a defined address area. This is done by ANDing the
	effective address of the opcode with a bit mask. Then a fixed offset is ORd with the
	result, to get the "confined address".
      </p>
      <h3>Container selection</h3>
      <p>
      </p><h3><a name="seg" id="seg">Segmentation</a></h3><p>
	Segments are an optional feature, but they are essential for virtualization. An "environment" is
	a kind of virtual address space. It is defined by an address range, and an offset. The address range is
	defined by a bit mask and a value. The actual address is ANDed with the mask, and if it the result is the same
	as the value, the environment address "matches".
      </p></div></div><hr />
<p>Return to <a href="../index.html">Homepage</a></p>

  </div></div><div id="footer"> </div></div><script type="text/javascript">myUp="../";</script><script type="text/javascript" src="../scripts-all.js"></script></body></html> 

