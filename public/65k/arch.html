<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
<meta name="author" content="Andr&eacute;  Fachat">

<meta name="description" content="6502 16bit 32bit expansion">
<meta name="keywords" content="6502 16bit 32bit expansion">
<link rev="made" href="mailto:afachat@gmx.de">
<link rel="stylesheet" title="Default" type="text/css" href="../style2-min.css"><link rel="alternate stylesheet" title="Advanced" type="text/css" href="../advanced.css">
<title>The 65k Project - Architecture Overview</title></head>
<body><div id="mainbox"><a name="top"></a><div id="topsearch"><form method="get" action="http://www.google.com/search" target="_blank" autocomplete="off"><input alt="search" name="q" size="10" maxlength="255" type="text"><input class="advbutton" value="Search site" type="submit"><div id="srchprov">(by Google)</div><input name="sitesearch" value="www.6502.org/users/andre" type="hidden"></form><div id="topfind"><div id="topprogress"></div></div></div><div id="menubox">


<div id="menu1" class="mclose">
<div id="twist1" class="twisty"></div>
<div class="hdrtxt"><a href="../index.html">Home&nbsp;&gt;</a></div>
<ul class="nav1">
<li>
<ul class="nav2">
<li class="navhdr"><a href="../index.html">Home</a></li>
<li><a href="../contact.html">Contact</a></li>
<li><a href="../design.html">Web design</a></li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Hardware</span></li>
<li><ul class="nav2" >
<li><a href="../65k/index.html">The 65k Project</a>
</li>
<li><a href="../csa/index.html">CS/A65</a>
</li>
<li><a href="../cbmhw/index.html">CBM mods</a>
</li>
<li><a href="../spi65b/index.html">SPI65B</a>
</li>
<li><a href="../mischw/index.html">Other hardware</a>
</li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Software</span></li>
<li><ul class="nav2" >
<li><a href="../osa/index.html">GeckOS</a>
</li>
<li><a href="../lib6502/index.html">lib6502 </a>
</li>
<li><a href="../o65/index.html">o65</a>
</li>
<li><a href="../usb65/index.html">usb65</a>
</li>
<li><a href="../xd2031/index.html">XD2031</a>
</li>
<li><a href="../misc/index.html">Misc</a>
</li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Library</span></li>
<li><ul class="nav2" >
<li><a href="../petindex/index.html">PETindex</a>
</li>
<li><a href="../adv65/index.html">Advanced 6502</a>
</li>
<li><a href="../hwinfo/index.html">ICs and Standards</a>
</li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Knowledge Bits</span></li>
<li><ul class="nav2" >
<li><a href="../icapos/index.html">Computer/OS Architecture</a>
</li>
<li><a href="../icaphw/index.html">6502 Hardware Bits</a>
</li>
</ul>
<div class="nend2"></div>
</li>
<div class="nend1"></div>
</ul>
</div>
<div id="menu2" class="mopen">
<div id="twist2" class="twisty"></div>
<div class="hdrtxt"><a href="index.html">The 65k Project&nbsp;&gt;</a></div>
<ul class="nav1">
<li>
<ul class="nav2">
<li class="navhdr"><a href="index.html">The 65k Project</a></li>
<li><a href="features.html">Feature Outline</a></li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Specification</span></li>
<li><ul class="nav2" >
<li><a href="specsprog.html">Programming Model</a></li>
<li><a href="future.html">Future Extensions</a></li>
<li><a href="af65002">&gt;65002</a></li>
<li><a href="designnotes.html">Design Notes</a></li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Tools</span></li>
<li><ul class="nav2" >
<li><a href="crossass.html">Cross-Assembler</a></li>
<li><a href="nativetools.html">Native Tools</a></li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Implementation</span></li>
<li><ul class="nav2" >
<li><a href="arch.html">General architecture</a></li>
<li><a href="af65002/index.html">af65002 </a>
</li>
<li><a href="tests.html">Test setup</a></li>
</ul>
<div class="nend2"></div>
</li>
<div class="nend1"></div>
</ul>
</div>
	</div><div id="midcol"><div class="top" id="content"><div id="minmax"></div>

<h1>The 65k Project - Architecture Overview</h1><p class="copyright">(C)
2010-2011 Andr&eacute;  Fachat</p> 
<div class="overview">
	<p>
	This page describes an overview on the 65k architecture.
	</p><p>
	</p>
  </div><div class="h2"><div class="h2h"><div class="h2t">&nbsp;</div><h2><a name="news">News:</a></h2></div><div class="h2c"><ul class="news"><li><div>&nbsp;</div><small>2010-10-23</small>
	Published this page
    </li><li><div>&nbsp;</div><small>2010-10-14</small>
	Started this page
    </li></ul></div></div><div id="toc" class="h2"><div class="h2h"><div class="h2t">&nbsp;</div><h2>Table of content</h2></div><div class="h2c"><ul><li><a href="#preface">Preface</a></li><li style="list-style-type:none;"><ul><li><a href="#lic">License</a></li><li><a href="#disc">Disclaimer</a></li><li><a href="#cont">Contributors</a></li><li><a href="#chg">Changes</a></li></ul></li><li><a href="#general">General Considerations</a></li><li style="list-style-type:none;"><ul><li><a href="#genrwseq">Read/Write Sequencers</a></li><li><a href="#smt">Simultaneous Multithreading</a></li><li><a href="#pipelining">Pipelining</a></li></ul></li><li><a href="#coreanalysis">Core Analysis</a></li><li style="list-style-type:none;"><ul><li><a href="#adanalysis">Addressing Mode Analysis</a></li><li><a href="#opanalysis">Opcode Data Path Analysis</a></li></ul></li></ul></div></div><div class="h2"><div class="h2h"><div class="h2t">&nbsp;</div><h2><a name="preface">Preface</a></h2></div><div class="h2c"><h3><a name="lic">License</a></h3><p>
        This content is licensed under the Creative Commons Attribution Share-Alike license, CC-BY-SA version 3.0.
    </p><p>
        Note this "content" includes this web page, but does not include the 6502.org header
        and the left and right web page columns.  Click on the "Maximize" link to see
        the contents covered by this license.
    </p><ul><li><a href="http://creativecommons.org/licenses/by-sa/3.0/legalcode" target="_blank" class="extlink">CC-BY-SA legal code</a> </li><li><a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_blank" class="extlink">CC-BY-SA license deed (short form)</a> </li></ul><h3><a name="disc">Disclaimer</a></h3><p>
        The content comes with no warranty at all!
        There is no guarantee and no promise that this specification is correct, consistent, will actually work,
        or will ever be implemented at all.
    </p><p>
        To my understanding the techniques described here have been used by various processors for decades already.
        Still there is no guarantee that a processor according to this spec would not be covered by some patents.
    </p><p>
        Subject to change without notice!
    </p><h3><a name="cont">Contributors</a></h3><ul>
        <li>Andr&eacute;  Fachat - initial author: <a href="http://www.6502.org/users/andre">8bit Homepage</a></li>
    </ul><h3><a name="chg">Changes</a></h3><p>This section describes the changes to the document:</p>
      <table border="1">
        <tr><th>Date</th><th>Author</th><th>Changes</th></tr>
        <tr><td>2010-10-25</td><td>Andr&eacute;  Fachat</td><td>Updated Core Architecture Diagram and Description</td></tr>
      </table>
    </div></div><div class="h2"><div class="h2h"><div class="h2t">&nbsp;</div><h2><a name="general">General Considerations</a></h2></div><div class="h2c">
      <p>
	This section describes general considerations for the processor design.
      </p>
    <h3><a name="genrwseq">Read/Write Sequencers</a></h3>
	<p>
	The processor has one problem: addresses are at byte level, bus and register
	widths are in general more than one byte wide - so misaligned accesses can happen:
	</p>
	<table border="1">
	<tr><th>Access Type</th><th>Bus width</th><th>Alignment</th><th>Comment</th></tr>
	<tr><td>Byte data read</td><td>any width</td><td>yes/no</td><td>The data can be read in any width from
									the bus, and the relevant byte be picked
									from it and given to the bus</td></tr>
	<tr><td>Byte data write</td><td>byte width</td><td>automatic</td><td>just write the byte</td></tr>
	<tr><td>Byte data write</td><td>word or larger width</td><td>yes/no</td><td>If the data can not be written
									as byte width but must use a larger width,
									the original data must be read, the relevant
									byte be modified, and the data word be 
									written back</td></tr>
	<tr><td>word or larger data read/write access</td><td>byte width</td><td>automatic</td>
									<td>The data access can just be executed
									one after the other</td></tr>
	<tr><td>word data read/write access</td><td>word width</td><td>aligned</td>
									<td>Just do the access</td></tr>
	<tr><td>word data read/write access</td><td>word width</td><td>misaligned</td>
									<td>The word access must be broken up into
									two byte accesses, and executed as 
									byte acces on a word bus as described above.
									</td></tr>
	<tr><td>...</td><td>...</td><td>...</td><td>...</td></tr>
	</table>
	<p>
	The table only shows a subset of possible combinations. To resolve this problem, specific 
	components are used, read and write sequencers. These components take a read or write request from the
	core and break them up into accesses that the external bus can execute.
	</p><p>
	If some address area is accessed as byte-wide I/O, and other parts of the address area as word-wide or wider
	memory, the processor must have multiple read and write sequencer, one per address width (or a sequencer
	that can handle multiple widths).
	</p><p>
	Doing misaligned accesses slows the processor down from its optimum speed. In general wider bus width
	is still faster than narrower bus widths.
	</p>
      <h3><a name="smt">Simultaneous Multithreading</a></h3>
	  <p>
	The 6502 - as well as the 65k - is very efficient concerning bus read/write cycles per opcode.
	If, however, a misaligned wide access is broken down into two or more smaller memory
	accesses, the core is waiting.
	  </p><p>
	In this case the core could switch to a separate set of registers, and execute 
	code for a second processor - what is called these days as SMT, simultaneous multithreading.
	  </p><p>
	But as the processor is very memory access efficient, a second thread may not have time
	for many memory accesses on its own. 
	  </p><p>
	This is a topic for a later version though anyway.
	  </p>
       	<h3><a name="pipelining">Pipelining</a></h3><p>
	Pipelining is a processor technique that divides the execution of an opcode into different
	stages like fetch, decoding, execution and store. Modern processors have pipelines up to 
	31 such stages (Pentium 4, Pentium D, see link). 
	</p><p>
	An advantage of pipelining is that more than
	one opcode can be executed in parallel. The first opcode could be writing back data, the next one
	executing, and next one being decoded and the last one being fetched. This way more functional
	units (fetch, decode, ...) can be used at any time, making the system more efficient. Even
	if each opcode requires more than one cycle, each cycle can start - and finish - an opcode,
	making the processor faster in terms of opcodes per cycle.
	</p><p>
	A disadvantage is that branches can invalidate all the work that has been done for the following
	cycles. Therefore branch prediction techniques have been developed to reduce the cost of 
	pipeline invalidation due to branches.
	</p><p>
	The 6502 already has a limited form of pipelining. The last cycle of any opcode actually is the fetch
	of the next opcode. That is also the reason why the 6502 is little-endian: the processor fetches
	two-byte operands with the low byte first. After the first fetch an index register is added to the
	low byte, while the high byte is being fetched. Then in the next cycle the carry is added to the high
	byte. In fact there is an optimization that eliminates the last cyle when no carry needs to be added
	to the high byte. 
	Here too branches lead to problems: When a branch is taken, the "official" end of the opcode is not reached
	and interrupt handling suspended until the end of the next opcode. 
	</p><p>
	The 65k architecture will in the current version implement pipelining similar to the 6502.
	  </p>
       	<ul><li><a href="http://en.wikipedia.org/wiki/Instruction_pipeline" target="_blank" class="extlink">Instruction Pipeline</a> </li><li><a href="http://en.wikipedia.org/wiki/Little-endian" target="_blank" class="extlink">Endianness</a> </li><li><a href="http://forum.6502.org/viewtopic.php?t=1634&amp;sid=5dae06f4d153431ee0c86b4cc2b01fa6" target="_blank" class="extlink">6502.org forum: A branch taken delays interrupt ...</a> </li></ul></div></div><div class="h2"><div class="h2h"><div class="h2t">&nbsp;</div><h2><a name="coreanalysis">Core Analysis</a></h2></div><div class="h2c"><p>
	This section analyses the requirements for the core architecture.
	</p>
     <h3><a name="adanalysis">Addressing Mode Analysis</a></h3>
	  <p>To define the necessary data paths in the core between registers, ALU and other components,
	here the addressing modes are analysed. As the internal register and data path widths is 
	always full width, arithmethic operations (adds) do not need to be broken up into 
	smaller chunks.
	The example used here is to load a value into the accumulator. They start with 
	the program counter on the address bus and the opcode parameter on the data bus.
	</p><p>
	Note that using a register and taking a new value into the same register can take place
	on the same clock cycle if registers are assumed (as opposed to transparent latches as in the
	original 6502). 
	</p><p>
	Also note that the initial parameter fetch comes as opcode parameter, thus from a different
	input bus, which has to be taken into account in the core design.
	</p>

	<h3>Immediate</h3>
	<p>The immediate addressing mode is easy...</p>
	<table border="1">
	<tr><th>Step</th><th>Transfer</th><th>Description</th></tr>
	<tr><td>1</td><td>Data bus -&gt; AC</td><td>The opcode parameter value fetched and on the data bus 
		is transferred into the register</td></tr>
	</table>

	<h3>Zeropage and Absolute</h3>
	<p>The zeropage and absolute - including the new long and quad - addressing modes
	have one indirection - the opcode parameter is an address used to fetch the actual value</p>
	<table border="1">
	<tr><th>Step</th><th>Transfer</th><th>Description</th></tr>
	<tr><td>1</td><td>Data bus -&gt; data bus input reg.</td><td>The opcode parameter value fetched and on the data bus 
		is transferred into the data bus input register (Note 1)</td></tr>
	<tr><td rowspan="2">2</td><td>Data bus input reg. -&gt; address bus</td><td>The data bus input 
		register is put onto the address bus</td></tr> 
	<tr><td>data bus -&gt; AC</td><td>The value read from the data bus is taken into the register</td></tr> 
	</table>

	<h3>Zeropage and Absolute Indexed</h3>
	<p>In this addressing mode an index register value is added to the address before reading the actual address.
	</p>
	<table border="1">
	<tr><th>Step</th><th>Transfer</th><th>Description</th></tr>
	<tr><td>1</td><td>Data bus -&gt; data bus input reg.</td><td>The opcode parameter value fetched and on the data bus 
		is transferred into the data bus input register</td></tr>
	<tr><td rowspan="3">2</td><td>Data bus input reg. -&gt; ALU A</td><td>The data bus input register value is put to ALU input A (Note 3)</td></tr> 
	<tr><td>index register -&gt; ALU B</td><td>The index register value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; temp</td><td>The ALU output is written to the temp register</td></tr> 
	<tr><th colspan="3">Step 3 is optional if B,S or P are added (prefix OF bits)</th></tr>
	<tr><td rowspan="3">3</td><td>temp -&gt; ALU A</td><td>The temporary register value is put to ALU input A</td></tr> 
	<tr><td>B,S or PC register -&gt; ALU B</td><td>The index register value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; temp</td><td>The ALU output is written to the temp register (Note 2)</td></tr> 
	<tr><th colspan="3"></th></tr>
	<tr><td rowspan="2">4</td><td>temp -&gt; address bus</td><td>The temporary register is put onto the address bus</td></tr> 
	<tr><td>data bus -&gt; AC</td><td>The value read from the data bus is taken into the register (via Pass5)</td></tr> 
	</table>

	<h3>Zeropage and Absolute Indexed Indirect</h3>
	<p>This is an extension to the previous addressing mode. The value read from the addressing mode above
	is interpreted as address to read the actual value from</p>
	<table border="1">
	<tr><th>Step</th><th>Transfer</th><th>Description</th></tr>
	<tr><td>1</td><td>Data bus -&gt; data bus input reg.</td><td>The opcode parameter value fetched and on the data bus 
		is transferred into the temporary (or the data in) register</td></tr>
	<tr><td rowspan="3">2</td><td>Data bus input reg. -&gt; ALU A</td><td>The data bus input register value is put to ALU input A</td></tr> 
	<tr><td>index register -&gt; ALU B</td><td>The index register value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; temp</td><td>The ALU output is written to the temp register</td></tr> 
	<tr><th colspan="3">Step 3 is optional if B,S or P are added (prefix OF bits)</th></tr>
	<tr><td rowspan="3">3</td><td>temp -&gt; ALU A</td><td>The temporary register value is put to ALU input A</td></tr> 
	<tr><td>B,S or PC register -&gt; ALU B</td><td>The index register value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; temp</td><td>The ALU output is written to the temp register (Note 2)</td></tr> 
	<tr><th colspan="3"></th></tr>
	<tr><td rowspan="2">4</td><td>temp -&gt; address bus</td><td>The temporary register is put onto the address bus</td></tr> 
	<tr><td>data bus -&gt; AC</td><td>The value read from the data bus is taken into the temp register</td></tr> 
	<tr><td rowspan="2">5</td><td>temp -&gt; address bus</td><td>The temporary register is put onto the address bus</td></tr> 
	<tr><td>data bus -&gt; AC</td><td>The value read from the data bus is taken into the register (via Pass5)</td></tr> 
	</table>


	<h3>Zeropage and Absolute Indirect Indexed</h3>
	<table border="1">
	<tr><th>Step</th><th>Transfer</th><th>Description</th></tr>
	<tr><td>1</td><td>Data bus -&gt; data bus input reg.</td><td>The opcode parameter value fetched and on the data bus 
		is transferred into the data bus input register</td></tr>
	<tr><th colspan="3">Step 2 is optional if B,S or P are added (prefix OF bits)</th></tr>
	<tr><td rowspan="3">2</td><td>data bus input reg. -&gt; ALU A</td><td>The temporary register value is put to ALU input A</td></tr> 
	<tr><td>B,S or PC register -&gt; ALU B</td><td>The index register value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; temp</td><td>The ALU output is written to the temp register (Note 2)</td></tr> 
	<tr><th colspan="3"></th></tr>
	<tr><td rowspan="2">3</td><td>temp/data bus input register -&gt; address bus</td><td>The 
		temporary register (resp. the data bus input register if step 2 is not taken) 
		is put onto the address bus (ALU passthrough)</td></tr> 
	<tr><td>data bus -&gt; AC</td><td>The value read from the data bus is taken into the temp register</td></tr> 
	<tr><td rowspan="3">4</td><td>temp -&gt; ALU A</td><td>The temporary register value is put to ALU input A</td></tr> 
	<tr><td>index register -&gt; ALU B</td><td>The index register value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; temp</td><td>The ALU output is written to the temp register</td></tr> 
	<tr><td rowspan="2">5</td><td>temp -&gt; address bus</td><td>The temporary register is put onto the address bus</td></tr> 
	<tr><td>data bus -&gt; AC</td><td>The value read from the data bus is taken into the register</td></tr> 
	</table>

	<h3>Relative</h3>
	<p>The relative addressing mode is for jumps only</p>
	<table border="1">
	<tr><th>Step</th><th>Transfer</th><th>Description</th></tr>
	<tr><td>1</td><td>Data bus -&gt; data bus input reg.</td><td>The opcode parameter value fetched and on the data bus 
		is transferred into the temporary (or the data in) register</td></tr>
	<tr><td rowspan="3">2</td><td>data bus input reg. -&gt; ALU A</td><td>The temporary register value is put to ALU input A</td></tr> 
	<tr><td>PC -&gt; ALU B</td><td>The Program counter value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; PC</td><td>The ALU output is written to the Program counter</td></tr> 
	</table>


	<h3>Notes</h3>
	<ol>
	<li>The value written to the temp register could directly be written to the address bus output register
	and to be put on the address bus in the next step, eliminating the need for the temp register here.</li>
	<li>The ALU output value could be directly written to the address bus. This, however, would add the
	ALU processing time to the setup time for the address bus, limiting the possible clock speeds.</li>
	<li>As the opcode operand is always read full width before actually adding the register value, 
	there can be no optimization by eliminating the high byte add. The processor always works as if there
	was a carry - and thus a 16 bit 65k with 8 bit data bus will actually be one cycle slower than the 6502
	if there is no carry</li>
	</ol>
       	<h3><a name="opanalysis">Opcode Data Path Analysis</a></h3>
	<p>In this section is an analysis of the different types of opcodes. </p>
	<h3>Load/Store</h3>
	<p>Opcodes: LDA, LDX, LDY, STA, STX, STY, STZ</p>
	<p>Load opcodes load a register with a value from memory. Store opcodes write data to a memory location.
	These opcodes work the same way as the bare addressing modes described above. Only for stores, not 
	just the address value is put on the bus, but also the register value.
	</p><p>
	Note: this poses a problem that during the zeropage and absolute addressing modes, during 
	parameter fetch the value read as parameter must be available as address on the data address bus, while 
	at the same time the register value has to be put onto the data bus. This has to be considered in the 
	core design.
	</p>
	<h3>Load Effective Address</h3>
	<p>The LEA opcode can actually work similar to the load opcodes as above, i.e. basically transferring the
	value of the address output register into E. But a cycle can be saved instead if the address value is
	directly stored in E instead of the address output register. This can be decided depending on implementation
	details.</p>
	<h3>Arithmetic Operations</h3>
	<p>Opcodes: ADC, SBC, CMP, ORA, AND, EOR, CPX, CPY, TSB, TRB, BIT, ADS, ADE, ADB, SBS, SBE, SBB</p>
	<p>These opcodes read an operand value, process it in the ALU, then store it in the AC (together with the
	relevant status bits). I.e. in the last addressing mode cycle as above, the value is read and stored
	in the temp register. In the following cycle, the temp register and the AC are put on the ALU A and B
	inputs respectively. The ALU output is passed on to the AC, which takes the value over at the 
	end of the cycle. In this very cycle the next opcode can be read using the opcode fetch circuitry - 
	as on the 6502.</p>
	<h3>Read-Modify-Write Operations</h3>
	<p>Opcodes: DEC, DEX, DEY, INC, INX, INY, ROL, ROR, ASL, LSR, SWP, BCN</p>
	<p>For the accumulator-addressing mode opcodes (ROL A, ROR A, LSR A, ASL A, SWP A, BCN A), it is simple. After opcode
	fetch and decode, the AC is given to the ALU and the result is transferred back to AC at the end of the
	cylce.</p>
	<p>For the other opcodes during the load cycle, the value is read into the temp register. During the 
	second cycle the ALU performs the operation, and stores the value in the data bus output driver, but
	does not perform a valid write. During the third cycle the data is actually written.
	In fact during the second cycle the next opcode fetch may actually already be performed (Note 1)
	</p>
	<h3>Register Transfer Operations</h3>
	<p>Opcodes: TAX, TXA, TAY, TYA, TXS, TSX, TPA, TSY, TYS, TEA, TAE, TBA, TAB</p>
	<p>These opcodes are simple. In the cylce after the opcode fetch the source register value is put
	on the internal bus, and transferred to the register input bus (using the pass gates), and stored
	in the register at the end of the cycle. During this transfer cycle the next opcode can be fetched.
	</p>
	<h3>Register Swap Operations</h3>
	<p>Opcodes: SAB, SAX, SAY, SXY, SAE, SAB</p>
	<p>These opcodes are more complicated. In the first cycle, AC is transferred into the temp register.
	In the second cycle the other (S/X/Y) register is transferred into AC. In the third cycle then the
	temp register is stored into the other register. (Note 2)
	</p>

	<h3>Status Register Operations</h3>
	<p>Opcodes: SEC, CLC, SED, CLD, SEI, CLI, CLV</p>
	<p>TODO</p>
	<h3>Clear Operations</h3>
	<p>Opcodes: CLY, CLX, CLA</p>
	<p>TODO</p>
	<h3>Stack Operations</h3>
	<p>Opcodes: PLA, PHA, PLX, PHX, PLY, PHY, PLB, PHB, PLE, PHE, PRB</p>
	<p>TODO</p>
	<h3>Jump Operations</h3>
	<p>Opcodes: JMP, JPU</p>
	<p>TODO</p>
	<h3>Jump Subroutine Operations</h3>
	<p>Opcodes: JSR, BSR</p>
	<p>TODO</p>
	<h3>Return Subroutine Operations</h3>
	<p>Opcodes: RTS, RTI, RTU</p>
	<p>TODO</p>
	<h3>Branch Operations</h3>
	<p>Opcodes: BNE, BEQ, BPL, BMI, BVS, BVC, BCC, BCS, BRA</p>
	<p>TODO</p>
	<h3>Branch Operations</h3>
	<p>Opcodes: BNE, BEQ, BPL, BMI, BVS, BVC, BCC, BCS, BRA</p>
	<p>TODO</p>
	<h3>Move Operations</h3>
	<p>Opcodes: MVN, MVP, MVNTU, MVNFU, MVPTU, MVPFU</p>
	<p>TODO</p>
	<h3>Fill Operations</h3>
	<p>Opcodes: FILU</p>
	<p>TODO</p>
	<h3>Quick Operations</h3>
	<p>Opcodes: DEC, DEY, DEX, INC, INY, INX, ROL, ROR, ASL, LSR, INE, DEE, INB, DEB - quick addressing modes</p>
	<p>TODO</p>
	<h3>Control Register Operations I</h3>
	<p>Opcodes: LCR, SCR, BCR</p>
	<p>TODO</p>
	<h3>Control Register Operations II</h3>
	<p>Opcodes: SENV, SMMU</p>
	<p>TODO</p>
	<h3>Memory Control Operations</h3>
	<p>Opcodes: SCA, LLA, WMB, RMB</p>
	<p>TODO</p>

	<h3>Notes</h3>
	<ol>
	<li>The ALU output value could be directly written to the data bus. This, however, would add the
	ALU processing time to the setup time for the data bus, limiting the possible clock speeds.</li>
	<li>If the ALU does not provide a pass-through mode, then a pass gate from the temp register output to 
	the register input bus is required</li>
	</ol>
       	</div></div><hr>
<p>Return to <a href="../index.html">Homepage</a></p>

  Last modified: 
2012-04-12
	</div></div><div id="rightcol"><div class="top" id="twitter"><div class="tophead">follow</div><div><p>Follow my 8-bit tweets on
		            <a class="extlink" target="_blank" href="https://twitter.com/#!/search/realtime/afachat%20%238bit">Twitter</a> (In new window)</p></div></div><div class="top" id="forum"><div class="tophead">discuss</div><div><p>Discuss my site on <a class="extlink" target="_blank" href="http://forum.6502.org/viewtopic.php?t=956">this 6502.org forum thread</a></p><p>Discuss this page's content on <a class="extlink" target="_blank" href="http://forum.6502.org/viewtopic.php?p=12180"> this 6502.org forum thread</a></p><p>(Forum registration required to post)</p></div></div><div class="top" id="hot"><div class="tophead">hot!</div><div>
<p>Dive into the retro feeling and build yourself a <a href="../cbmhw/ryofat40/index.html">Commodore PET replica</a></p>
<p>Need more speed? Speed up your 6502 computer with this <a href="../adv65/pet816/index.html">10&nbsp;MHz 6502 CPU replacement board</a></p>
<p>Interested in electronics design? Look at the <a href="../icaphw/design.html">design lesson</a> I got from Bil Herd, the hardware designer of the C128</p>
<p>Want 64bit? - pimp the 6502 with the <a href="../65k/index.html">65k processor design!</a></p>

		</div></div></div><div id="footer">&nbsp;</div></div><script type="text/javascript">myUp="../";</script><script type="text/javascript" src="../scripts2-all.js"></script></body></html> 
