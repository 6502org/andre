<!DOCTYPE webpage [ <!ENTITY eacute "&#233; "> <!ENTITY nbsp "&#160;"> ]>
<webpage name="The 65k Project - Architecture Overview">
  <author>
    <name>Andr&eacute; Fachat</name> 
    <email>@EMAIL@</email>
    <homepage>@WEBROOT@</homepage>
    <yearstart>2010</yearstart>
    <yearend></yearend>
  </author>
  <keywords>6502 16bit 32bit expansion</keywords>
  <metadesc>6502 16bit 32bit expansion</metadesc>
  <forum type="6502.org">http://forum.6502.org/viewtopic.php?p=12180</forum>
  <overview>
	<p>
	This page describes an overview on the 65k architecture.
	</p><p>
	</p>
  </overview>
  <news>
    <item date="2010-10-23">
	Published this page
    </item>
    <item date="2010-10-14">
	Started this page
    </item>
  </news>
  <toc/>

  <section toc="preface" name="Preface">
  <subsection toc="lic" name="License">
    <desc><p>
        This content is licensed under the Creative Commons Attribution Share-Alike license, CC-BY-SA version 3.0.
    </p><p>
        Note this "content" includes this web page, but does not include the 6502.org header
        and the left and right web page columns.  Click on the "Maximize" link to see
        the contents covered by this license.
    </p></desc>
    <extlink name="CC-BY-SA legal code" link="http://creativecommons.org/licenses/by-sa/3.0/legalcode"/>
    <extlink name="CC-BY-SA license deed (short form)" link="http://creativecommons.org/licenses/by-sa/3.0/"/>
  </subsection>
  <subsection toc="disc" name="Disclaimer">
    <desc><p>
        The content comes with no warranty at all!
        There is no guarantee and no promise that this specification is correct, consistent, will actually work,
        or will ever be implemented at all.
    </p><p>
        To my understanding the techniques described here have been used by various processors for decades already.
        Still there is no guarantee that a processor according to this spec would not be covered by some patents.
    </p><p>
        Subject to change without notice!
    </p></desc>
  </subsection>
  <subsection toc="cont" name="Contributors">
    <desc><ul>
        <li>Andr&eacute; Fachat - initial author: <a href="http://www.6502.org/users/andre">8bit Homepage</a></li>
    </ul></desc>
  </subsection>
  <subsection toc="chg" name="Changes">
    <desc><p>This section describes the changes to the document:</p>
      <table border="1">
        <tr><th>Date</th><th>Author</th><th>Changes</th></tr>
        <tr><td>2010-10-25</td><td>Andr&eacute; Fachat</td><td>Updated Core Architecture Diagram and Description</td></tr>
      </table>
    </desc>
  </subsection>
  </section>

  <section toc="general" name="General Considerations">
    <desc>
      <p>
	This section describes general considerations for the processor design.
      </p>
    </desc>
    <subsection toc="genrwseq" name="Read/Write Sequencers">
      <desc>
	<p>
	The processor has one problem: addresses are at byte level, bus and register
	widths are in general more than one byte wide - so misaligned accesses can happen:
	</p>
	<table border="1">
	<tr><th>Access Type</th><th>Bus width</th><th>Alignment</th><th>Comment</th></tr>
	<tr><td>Byte data read</td><td>any width</td><td>yes/no</td><td>The data can be read in any width from
									the bus, and the relevant byte be picked
									from it and given to the bus</td></tr>
	<tr><td>Byte data write</td><td>byte width</td><td>automatic</td><td>just write the byte</td></tr>
	<tr><td>Byte data write</td><td>word or larger width</td><td>yes/no</td><td>If the data can not be written
									as byte width but must use a larger width,
									the original data must be read, the relevant
									byte be modified, and the data word be 
									written back</td></tr>
	<tr><td>word or larger data read/write access</td><td>byte width</td><td>automatic</td>
									<td>The data access can just be executed
									one after the other</td></tr>
	<tr><td>word data read/write access</td><td>word width</td><td>aligned</td>
									<td>Just do the access</td></tr>
	<tr><td>word data read/write access</td><td>word width</td><td>misaligned</td>
									<td>The word access must be broken up into
									two byte accesses, and executed as 
									byte acces on a word bus as described above.
									</td></tr>
	<tr><td>...</td><td>...</td><td>...</td><td>...</td></tr>
	</table>
	<p>
	The table only shows a subset of possible combinations. To resolve this problem, specific 
	components are used, read and write sequencers. These components take a read or write request from the
	core and break them up into accesses that the external bus can execute.
	</p><p>
	If some address area is accessed as byte-wide I/O, and other parts of the address area as word-wide or wider
	memory, the processor must have multiple read and write sequencer, one per address width (or a sequencer
	that can handle multiple widths).
	</p><p>
	Doing misaligned accesses slows the processor down from its optimum speed. In general wider bus width
	is still faster than narrower bus widths.
	</p>
      </desc>
    </subsection>

     <subsection toc="smt" name="Simultaneous Multithreading">
	<desc>
	  <p>
	The 6502 - as well as the 65k - is very efficient concerning bus read/write cycles per opcode.
	If, however, a misaligned wide access is broken down into two or more smaller memory
	accesses, the core is waiting.
	  </p><p>
	In this case the core could switch to a separate set of registers, and execute 
	code for a second processor - what is called these days as SMT, simultaneous multithreading.
	  </p><p>
	But as the processor is very memory access efficient, a second thread may not have time
	for many memory accesses on its own. 
	  </p><p>
	This is a topic for a later version though anyway.
	  </p>
       	</desc>
     </subsection>

     <subsection toc="pipelining" name="Pipelining">
	<desc><p>
	Pipelining is a processor technique that divides the execution of an opcode into different
	stages like fetch, decoding, execution and store. Modern processors have pipelines up to 
	31 such stages (Pentium 4, Pentium D, see link). 
	</p><p>
	An advantage of pipelining is that more than
	one opcode can be executed in parallel. The first opcode could be writing back data, the next one
	executing, and next one being decoded and the last one being fetched. This way more functional
	units (fetch, decode, ...) can be used at any time, making the system more efficient. Even
	if each opcode requires more than one cycle, each cycle can start - and finish - an opcode,
	making the processor faster in terms of opcodes per cycle.
	</p><p>
	A disadvantage is that branches can invalidate all the work that has been done for the following
	cycles. Therefore branch prediction techniques have been developed to reduce the cost of 
	pipeline invalidation due to branches.
	</p><p>
	The 6502 already has a limited form of pipelining. The last cycle of any opcode actually is the fetch
	of the next opcode. That is also the reason why the 6502 is little-endian: the processor fetches
	two-byte operands with the low byte first. After the first fetch an index register is added to the
	low byte, while the high byte is being fetched. Then in the next cycle the carry is added to the high
	byte. In fact there is an optimization that eliminates the last cyle when no carry needs to be added
	to the high byte. 
	Here too branches lead to problems: When a branch is taken, the "official" end of the opcode is not reached
	and interrupt handling suspended until the end of the next opcode. 
	</p><p>
	The 65k architecture will in the current version implement pipelining similar to the 6502.
	  </p>
       	</desc>
	<extlink name="Instruction Pipeline" link="http://en.wikipedia.org/wiki/Instruction_pipeline"/>
	<extlink name="Endianness" link="http://en.wikipedia.org/wiki/Little-endian"/>
	<extlink name="6502.org forum: A branch taken delays interrupt ..." link="http://forum.6502.org/viewtopic.php?t=1634&amp;sid=5dae06f4d153431ee0c86b4cc2b01fa6"/>
     </subsection>

  </section>

  <section toc="top" name="Top Level Architecture">
     <desc><p>This section describes the top level architecture, i.e. the top level
	building blocks of the processor and their relations. Compared to the 6502
	there are more such building blocks, the processor is more complex. The 6502
	basically compares to the core - which is described in more detail below.</p>
	<div class="rightimg"><a href="archtop.svg"><img width="300" src="archtop.png"/></a>The top level
	architecture</div>
	<p>
	The following sections describe the components.
	</p>
     </desc>
     <subsection toc="topcore" name="Core">
	<desc>
	<p>
	The core is the actual processor. It contains registers, ALU, and so on. With the 
	rest of the system it communicates using three bus interfaces:
	</p>
	<ol>
	<li>Instruction fetch bus - read the next instruction</li>
	<li>Data read bus - read some data word</li>
	<li>Data write bus - write some data word </li>
	</ol>
	<p>
	</p>
       	</desc>
     </subsection>
     <subsection toc="toprwseq" name="Read / Write Data Sequencer, Read Arbiter">
	<desc>
	  <p>
	  The read and write sequencers break down misaligned memory accesses
	  into accesses that can be executed on the external bus.
	  </p><p>
	  The separate read data and instruction fetch sequencers may look like overkill.
	  But this approach has the advantage that the instruction fetch sequencer can
	  cache data it has already been read but has not yet been used by the CPU - without
	  it being flushed by a data read.
	  </p><p>
	  The place between the read sequencers and the read arbiter can be a good place
	  for a L1 cache - separate for data and instructions - in later versions.
	  On the other hand the place between read arbiter and MMU can be used for a L1
	  cache. Both places must be connected to the write bus, to invalidate modified 
	  cache lines - to allow for self-modifying code.
	  </p><p>
	  Note that the sequencers must be before the MMU, as each of the broken
	  down accesses may result in a different mapping.
	  </p>
	<h3>Write Data Sequencer</h3>
	  <p>
	  The write data sequencer takes a write request from the core, then checks 
	  if the access is aligned or not. If it is not aligned, the access is broken
	  into two separate accesses and forwarded to the MMU.
	  </p>
	<h3>Read Data Sequencer</h3>
	  <p>
	  The read data sequencer takes a read request from the core, then checks 
	  if the access is aligned or not. If it is not aligned, the access is broken
	  into two separate accesses and forwarded to the read arbiter.
	  The result is consolidated and sent to the CPU when the whole data has been read.
	  </p>
	<h3>Instruction Fetch Sequencer</h3>
	  <p>
	  The instruction fetch sequencer takes a fetch request from the CPU,
	  then tries to fulfill as much of it as possible. As the CPU does not know
	  how many bytes an instruction takes, the CPU requests as many bytes as possible,
	  but accepts less bytes than requested. The CPU then decides if it needs more
	  instruction data. 
	  </p>
	<h3>Read Arbiter</h3>
	  <p>
	  The read arbiter takes requests from the read data sequencer and the instruction fetch
	  sequencer, then decides which one to forward to the MMU. 
	  </p>
       	</desc>
     </subsection>

     <subsection toc="topmmu" name="Memory Management Unit">
	<desc>
	  <p>
	The memory management unit is an optional feature. It translates the
	read and write requests from the CPU (actually from the read arbiter and from the
	write sequencer) from effective to physical addresses.
	  </p><p>
	More details are described below.
	  </p>
       	</desc>
     </subsection>

     <subsection toc="topbusif" name="Bus Interface">
	<desc>
	  <p>
	The bus interface takes the read and write requests from the MMU and executes
	them on the physical - external - bus interface. 
	  </p><p>
	For a misaligned bus write access (e.g. a byte write to a word wide bus) the bus
	interface also implements read-modify-write cycles. I.e. the wide bus memory data
	is read, the narrower data from the CPU is set into this memory word, and the 
	data is written back.
	  </p><p>
	Also the bus interface does a bus snoop in case the external bus allows this. The
	bus snooping is used to invalidate cache lines. It also detects accesses that
	invalidates Load-linked/Store-conditional sequences.
	  </p>
       	</desc>
     </subsection>

  </section>

  <section toc="coreanalysis" name="Core Analysis">
     <desc><p>
	This section analyses the requirements for the core architecture.
	</p>
     </desc>
     <subsection toc="adanalysis" name="Addressing Mode Analysis">
	<desc>
	  <p>To define the necessary data paths in the core between registers, ALU and other components,
	here the addressing modes are analysed. As the internal register and data path widths is 
	always full width, arithmethic operations (adds) do not need to be broken up into 
	smaller chunks.
	The example used here is to load a value into the accumulator. They start with 
	the program counter on the address bus and the opcode parameter on the data bus.
	</p><p>
	Note that using a register and taking a new value into the same register can take place
	on the same clock cycle if registers are assumed (as opposed to transparent latches as in the
	original 6502). 
	</p>

	<h3>Immediate</h3>
	<p>The immediate addressing mode is easy...</p>
	<table border="1">
	<tr><th>Step</th><th>Transfer</th><th>Description</th></tr>
	<tr><td>1</td><td>Data bus -&gt; AC</td><td>The opcode parameter value fetched and on the data bus 
		is transferred into the register</td></tr>
	</table>

	<h3>Zeropage and Absolute</h3>
	<p>The zeropage and absolute - including the new long and quad - addressing modes
	have one indirection - the opcode parameter is an address used to fetch the actual value</p>
	<table border="1">
	<tr><th>Step</th><th>Transfer</th><th>Description</th></tr>
	<tr><td>1</td><td>Data bus -&gt; data bus input reg.</td><td>The opcode parameter value fetched and on the data bus 
		is transferred into the data bus input register (Note 1)</td></tr>
	<tr><td rowspan="2">2</td><td>Data bus input reg. -&gt; address bus</td><td>The data bus input 
		register is put onto the address bus</td></tr> 
	<tr><td>data bus -&gt; AC</td><td>The value read from the data bus is taken into the register</td></tr> 
	</table>

	<h3>Zeropage and Absolute Indexed</h3>
	<p>In this addressing mode an index register value is added to the address before reading the actual address.
	</p>
	<table border="1">
	<tr><th>Step</th><th>Transfer</th><th>Description</th></tr>
	<tr><td>1</td><td>Data bus -&gt; data bus input reg.</td><td>The opcode parameter value fetched and on the data bus 
		is transferred into the data bus input register</td></tr>
	<tr><td rowspan="3">2</td><td>Data bus input reg. -&gt; ALU A</td><td>The data bus input register value is put to ALU input A (Note 3)</td></tr> 
	<tr><td>index register -&gt; ALU B</td><td>The index register value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; temp</td><td>The ALU output is written to the temp register</td></tr> 
	<tr><th colspan="3">Step 3 is optional if B,S or P are added (prefix OF bits)</th></tr>
	<tr><td rowspan="3">3</td><td>temp -&gt; ALU A</td><td>The temporary register value is put to ALU input A</td></tr> 
	<tr><td>B,S or PC register -&gt; ALU B</td><td>The index register value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; temp</td><td>The ALU output is written to the temp register (Note 2)</td></tr> 
	<tr><th colspan="3"></th></tr>
	<tr><td rowspan="2">4</td><td>temp -&gt; address bus</td><td>The temporary register is put onto the address bus</td></tr> 
	<tr><td>data bus -&gt; AC</td><td>The value read from the data bus is taken into the register (via Pass5)</td></tr> 
	</table>

	<h3>Zeropage and Absolute Indexed Indirect</h3>
	<p>This is an extension to the previous addressing mode. The value read from the addressing mode above
	is interpreted as address to read the actual value from</p>
	<table border="1">
	<tr><th>Step</th><th>Transfer</th><th>Description</th></tr>
	<tr><td>1</td><td>Data bus -&gt; data bus input reg.</td><td>The opcode parameter value fetched and on the data bus 
		is transferred into the temporary (or the data in) register</td></tr>
	<tr><td rowspan="3">2</td><td>Data bus input reg. -&gt; ALU A</td><td>The data bus input register value is put to ALU input A</td></tr> 
	<tr><td>index register -&gt; ALU B</td><td>The index register value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; temp</td><td>The ALU output is written to the temp register</td></tr> 
	<tr><th colspan="3">Step 3 is optional if B,S or P are added (prefix OF bits)</th></tr>
	<tr><td rowspan="3">3</td><td>temp -&gt; ALU A</td><td>The temporary register value is put to ALU input A</td></tr> 
	<tr><td>B,S or PC register -&gt; ALU B</td><td>The index register value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; temp</td><td>The ALU output is written to the temp register (Note 2)</td></tr> 
	<tr><th colspan="3"></th></tr>
	<tr><td rowspan="2">4</td><td>temp -&gt; address bus</td><td>The temporary register is put onto the address bus</td></tr> 
	<tr><td>data bus -&gt; AC</td><td>The value read from the data bus is taken into the temp register</td></tr> 
	<tr><td rowspan="2">5</td><td>temp -&gt; address bus</td><td>The temporary register is put onto the address bus</td></tr> 
	<tr><td>data bus -&gt; AC</td><td>The value read from the data bus is taken into the register (via Pass5)</td></tr> 
	</table>


	<h3>Zeropage and Absolute Indirect Indexed</h3>
	<table border="1">
	<tr><th>Step</th><th>Transfer</th><th>Description</th></tr>
	<tr><td>1</td><td>Data bus -&gt; data bus input reg.</td><td>The opcode parameter value fetched and on the data bus 
		is transferred into the data bus input register</td></tr>
	<tr><th colspan="3">Step 2 is optional if B,S or P are added (prefix OF bits)</th></tr>
	<tr><td rowspan="3">2</td><td>data bus input reg. -&gt; ALU A</td><td>The temporary register value is put to ALU input A</td></tr> 
	<tr><td>B,S or PC register -&gt; ALU B</td><td>The index register value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; temp</td><td>The ALU output is written to the temp register (Note 2)</td></tr> 
	<tr><th colspan="3"></th></tr>
	<tr><td rowspan="2">3</td><td>temp/data bus input register -&gt; address bus</td><td>The 
		temporary register (resp. the data bus input register if step 2 is not taken) 
		is put onto the address bus (ALU passthrough)</td></tr> 
	<tr><td>data bus -&gt; AC</td><td>The value read from the data bus is taken into the temp register</td></tr> 
	<tr><td rowspan="3">4</td><td>temp -&gt; ALU A</td><td>The temporary register value is put to ALU input A</td></tr> 
	<tr><td>index register -&gt; ALU B</td><td>The index register value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; temp</td><td>The ALU output is written to the temp register</td></tr> 
	<tr><td rowspan="2">5</td><td>temp -&gt; address bus</td><td>The temporary register is put onto the address bus</td></tr> 
	<tr><td>data bus -&gt; AC</td><td>The value read from the data bus is taken into the register</td></tr> 
	</table>

	<h3>Relative</h3>
	<p>The relative addressing mode is for jumps only</p>
	<table border="1">
	<tr><th>Step</th><th>Transfer</th><th>Description</th></tr>
	<tr><td>1</td><td>Data bus -&gt; data bus input reg.</td><td>The opcode parameter value fetched and on the data bus 
		is transferred into the temporary (or the data in) register</td></tr>
	<tr><td rowspan="3">2</td><td>data bus input reg. -&gt; ALU A</td><td>The temporary register value is put to ALU input A</td></tr> 
	<tr><td>PC -&gt; ALU B</td><td>The Program counter value is put to ALU input B</td></tr> 
	<tr><td>ALU out -&gt; PC</td><td>The ALU output is written to the Program counter</td></tr> 
	</table>


	<h3>Notes</h3>
	<ol>
	<li>The value written to the temp register could directly be written to the address bus output register
	and to be put on the address bus in the next step, eliminating the need for the temp register here.</li>
	<li>The ALU output value could be directly written to the address bus. This, however, would add the
	ALU processing time to the setup time for the address bus, limiting the possible clock speeds.</li>
	<li>As the opcode operand is always read full width before actually adding the register value, 
	there can be no optimization by eliminating the high byte add. The processor always works as if there
	was a carry - and thus a 16 bit 65k with 8 bit data bus will actually be one cycle slower than the 6502
	if there is no carry</li>
	</ol>
       	</desc>
     </subsection>
  </section>

  <section toc="core" name="Core Architecture">
     <desc><p>
	This section describes the architecture of the processor core. A block diagram is on the right side, 
	click it to enlarge.
	</p>
	<div class="rightimg"><a href="archcore.svg"><img width="300" src="archcore.png"/></a>The core 
	architecture</div>
	<p>
	The general principle of the core is that every action takes one cycle, from falling phi2 to falling phi2.
	That is with the exception of simple transfer operations.
	This has advantages and disadvantages. The advantage is that the clock can be made faster than if some
	action has to be confined into half a clock cycle. The disadvantage is that computing (adding up)
	an address value at the beginning of the cycle and putting it on the address bus in the same cycle is
	not possible, thus takes an additional cycle. This results in the fact that the processor always 
	behaves as if the original 6502 had used an additiona cycle due to page crossing.
	</p>
     </desc>

     <subsection toc="regfile" name="Register File">
     <desc><p>
	Each of the registers is implemented twice - for example "E" and shadow register "E'". These registers are required
	for abort handling. During an abort, the register value from before the opcode must be restored.
	Therefore the shadow register keeps the register value at the beginning of the opcode execution.
	</p>
	<table border="1">
	<tr><th>Register</th><th>Name</th></tr>
	<tr><td>A</td><td>Accumulator</td></tr>
	<tr><td>X</td><td>X register</td></tr>
	<tr><td>Y</td><td>Y register</td></tr>
	<tr><td>B</td><td>Base offset register</td></tr>
	<tr><td>E</td><td>Effective address register</td></tr>
	<tr><td>S</td><td>Stack pointer</td></tr>
	<tr><td>P</td><td>Status register</td></tr>
	<tr><td>ISR</td><td>Interrupt status register</td></tr>
	<tr><td>ICR</td><td>Interrupt control register</td></tr>
	<tr><td>PCRs</td><td>Processor configuration registers</td></tr>
	</table>
     </desc>
     </subsection>

     <subsection toc="pc" name="PC">
     <desc><p>
	The Program Counter is a special register in that it is used to fetch opcodes and also that it
	is incremented automatically. For this there is the PC increment adder that can add constant values
	selected by the control logic to the PC.
	</p><p>
	The Pass1 and Pass2 drivers separate the PC input and output from the other register's input and
	output busses.
     </p></desc>
     </subsection>

     <subsection toc="alu" name="ALU">
     <desc><p>
	
     </p></desc>
     </subsection>

     <subsection toc="ctrl" name="Control (Interrupt, clock counter, opcode fetch)">
     <desc><p>
	
     </p></desc>
     </subsection>

  </section>

  <section toc="mmu" name="MMU">
     <desc><p>
	
	</p>
     </desc>
     <!--subsection toc="65010" name="65010">
	<desc>
	  <p>Design goals for the 65010 CPU replacement are:</p>
       	</desc>
     </subsection-->

  </section>

  <section toc="busif" name="Bus Interface">
     <desc><p>
	
	</p>
     </desc>
     <!--subsection toc="65010" name="65010">
	<desc>
	  <p>Design goals for the 65010 CPU replacement are:</p>
       	</desc>
     </subsection-->

  </section>

  <closing>
@FOOTER@
  </closing>
</webpage>
