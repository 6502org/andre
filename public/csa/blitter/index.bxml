<!DOCTYPE webpage [ <!ENTITY eacute "&#233; "> <!ENTITY nbsp "&#160;"> ]>
<webpage name="Blitter">
  <author>
    <name>Andr&eacute; Fachat</name> 
    <email>@EMAIL@</email>
    <homepage>@WEBROOT@</homepage>
    <yearstart>2007</yearstart>
    <yearend>2010</yearend>
  </author>
  <keywords>6502 blitter block transfer engine</keywords>
  <metadesc>6502 block transfer engine</metadesc>
  <overview><p>Transfering a block of bytes from one memory location to another
	using the CPU can take a lot of time. A simple transfer loop using absolute
	addressing uses about 13 cycles per byte. Using zeropage indexed addressing 
	it takes even more. That is the reason why computers like the Amiga or the
	later Atari ST have block transfer engines, or PCs have DMA engines in the chipset.
	The 65816 chip even includes special opcodes to do block transfers, with a rate 
	of seven cycles per byte.
	</p><p>
	I thought I should add a block tranfer engine to the CS/A system. 
	Back then in 2007 I did a first design - and utterly failed. It implemented
	two address registers, with a separate adder/incrementer and buffers for each address,
	so it took a whole lot of board space, so I wasn't able to actually place and 
	route it. You can see the design below as V1.
	</p><p>
	In 2010 I had a better look into CPU architectures, and I got the idea that
	I could build a blitter using something similar to a CPU architecture. Using 
	an architecture with address registers, shared busses, and a single ALU I was
	able to produce a new design (see V2 below) that does not need as much board
	space and that I was able to place and route with SMD technology.
	</p><p>
	In the <a href="works.html">How it works</a> page I have described how the
	board works in principle.
	</p>
  </overview>
  <news>
    <item date="2010-09-17">
	Started this page
    </item>
  </news>
  <toc/>

  <section toc="desc" name="Board description">
     <desc><p>In the <a href="works.html">How it works</a> page the principles of operation
	are described. Here I'll describe some of the implementation details (of the V2 board).
     </p></desc>
     <subsection toc="dbus" name="Data Bus Separation">
	<desc><p>
	In the principles the CPU data bus is connected to the INBUS drivers, the increment
	registers, the increment data buffer, and - not shown there - to the input as well as output
	of the data transfer register (where the transferred data is kept). This would put a lot
	of load on the actual CPU data bus. Therefore I added IC15, a data bus driver that separates
	the actual CPU data bus from the board data bus.
	</p></desc>
     </subsection>
     <subsection toc="logic" name="Logic Implementation">
	<desc><p>
	The system actually only as a few bits of "state" if you don't count the address and increment
	registers. It must know if it is active, and when active it needs to know which operation it
	is doing - fetch or store. This state is defined in the signals /ACTIVE and FETCH/-STORE.
	In the 2.0 version these bits were determined by some RS-Flipflops, and all other logic
	was derived from that and implemented in two PAL chips. But my PAL burner is not that 
	reliable and I had a Xilinx 9536 CPLD around, so I decided to move everything into the CPLD
	- which is shown in the 2.1 version. Unfortunately the CPLD is about a few lines short of
	being able to include all the logic. So some small parts are still implemented as inverters
	and AND gates.
	</p><p>
	Note that the 2.1 board contains some "PIN" pads, to be able to easily use the remaining logic
	gates even though these chips are SMD...
	</p></desc>
     </subsection>
     <subsection toc="layout" name="Layout description">
	<desc><p>
	If you look at the layout, it is dominated by an five-by-four array of SOW20 chips with some
	smaller chips to the right. These implement the INBUS, OUTBUS and Increment busses as follows:
	</p><p>
	The first line of chips implements the Increment bus, with two '574 as increment value registers
	for fetch and store. Then there is IC24 ('245) to read out the increment bus, and IC23 ('245)
	to feed a zero increment into the adder.
	</p><p>
	To the right of that comes IC32 ('245) and IC25/IC28 (both '193) that implement the transfer counter.
	</p><p>
	The next three lines of ICs implement the address bits 0-7, 8-15 and 16-19 respectively, including
	their part of the INBUS and OUTBUS busses. First comes the address drivers that are used to
	drive the OUTBUS to the CPU address bus. Then there are the two '574 that hold the fetch and store
	address values; then there is the data bus driver, connecting the INBUS with the CPU data bus.
	The right-most 20-pin chip is the ALU output driver, that drives the adder output onto the
	INBUS. The smaller chips to the right are '293 4-bit adders, implementing the actually "ALU" adder.
	</p></desc>
     </subsection>
  </section>

        <!--driver>
                <name>Simple test suite</name>
                <desc>These tests test the basic functionality of the board, and also do some timing
                        measurement to actually see if the access is fast or not.
                        Note that these tests are small as I had to enter them with the hex editor.
                        Simply assemble them with the <code>xa</code> cross assembler with the <code>-w</code>
                        switch to allow 65816 code.
                <div class="rightimg">
                        <a href="csa_nobogus.png"><img width="200px" src="csa_nobogus.png"/></a><br/><b>Remove bogus accesses</b>: Screenshot of a timing measurement. On the top of the screen you see the result of the original speed, then POKEing to ignore bogus CPU accesses and measuring again. See about 14% speed increase.
                        </div>
                </desc>
                <file ltype="driver" ptype="a65" note="copies all of the lowest 64k but the I/O area onto itself, so it is automatically written to fast RAM ">test1.a65</file>
        </driver-->
        <rev>
                <version>2.1A</version>
                <status>prototype</status>
                <note type="stop">
			This board is a prototype design that I still have to build and test!
                </note>
                <file ltype="schem" ptype="esch">csa_blitter-v2.1a.sch</file>
                <file ltype="schem" ptype="png">csa_blitter-v2.1a-sch.png</file>
                <file ltype="layout" ptype="ebrd">csa_blitter-v2.1a.brd</file>
                <file ltype="layout" ptype="png">csa_blitter-v2.1a-brd.png</file>
        </rev>
        <rev>
                <version>1.0B</version>
                <status>not working</status>
                <note type="stop">
			This is an example of how not to do it. The schematics sport an own 
			adder resp. incrementer for each address, load and store, and the increment value.
			The board layout shows why I decided to start from scratch - no way to route this
			on a two-layer Eurocard PCB. 
                </note>
		<note type="msg">
			The board was supposed to have a daughter board with exchangeable logic 
			to implement transparent DMA - hiding the DMA accesses in the bogus cycles
			between the valid CPU access cycles. That's what the TDMA connector was for.
			Looking at the discussions about how the CPU handles interrupts (they start
			after the opcode fetch, so you'd have to monitor either writes or the interrupt
			line as well) I decided to skip this feature. This also removed the need to
			read the counter register.
		</note>
                <file ltype="schem" ptype="esch">csa_blitter-v1.0b.sch</file>
                <file ltype="schem" ptype="png">csa_blitter-v1.0b-sch.png</file>
                <file ltype="layout" ptype="png">csa_blitter-v1.0b-brd.png</file>
        </rev>

  <closing>
@FOOTER@
  </closing>
</webpage>
