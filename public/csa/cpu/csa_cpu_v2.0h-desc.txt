
Description for CS/A CPU65, version 2.0
---------------------------------------

whatsit	: CPU + MMU
I/O	: MMU at $ff0-$fff
	  Control Register (write only) at $fd0
	  CPU address low (read only) at $fd2
	  CPU address hi (read only) at $fd3
Mem	: --


This is the CPU board with an MMU to extend the 6502 address space
to 1 MByte. Having the MMU block diagram in mind, it's still pretty
straightforward...

Bus interface

U1 is the CPU, which should be a 2MHz version for 1MHz system clock,
or a 4MHz version for 2MHz system clock - the MMU eats some address
setup time, which means we need a faster CPU.
IC2, 3 and 14 make up the bus drivers. 
IC17 is the bus driver for the MMU-mapped address lines A12-A19.
IC18 drives the clock lines. 

Timing generation

The CPU board generates all necessary clock signals. the 16MHz clock
is taken directly from the clock generator. JP5 decides if the divider
IC4 gets 16 MHz or 8 MHz (QA) to divide by 8 to get the system clock (QD).
Since version 2.0 Phi0 can not be driven by the bus anymore.

2Phi2 is generated by taking the normal Phi2 CPU output, delaying it
considerably using the shift register IC10 and XOR-ing with the Phi2 
signal again. This way after each transition of Phi2 we get a high 
signal of a certain length on 2Phi2. I use this signal as a /CAS 
signal on the video card.

Select lines

IC5 is an 8 bit comparator which detects the fixed-address I/O space
at $e***. With jumpers JP1-4 the address range can be modified for example
to $e8** or to $e800-$efff, which are two Commodore PET compatible ranges. 
Using the /IOINH signal on the bus the I/O area selection can be 
disabled dynamically. With /EXTIO the I/O area can be selected from the
bus even in an area that is normally selected as memory via /MEMSEL.

MMU access

Please note that, except for the CPU address line mapping (MA* -> MO*)
the complete MMU interface is on the bus side of the CPU bus buffers.
This way the MMU looks completely like any other I/O device
in the I/O area. IC15 and IC16 select the appropriate I/O area for the MMU.

One half of IC11 forms a RS-flip-flop that is reset when the /RES
line goes active, i.e. at a CPU reset. The MMU then goes to 
pass mode, i.e. it passes MA0-3 to MO8-11, setting all other MO* lines
to zero. Only after the first write access to the MMU registers
the flip-flop is set and /MM becomes active, putting the MMU 
into map mode. Then MA* are translated to MO0-11, using the register
contents. So the first write to the MMU should make sure that
the code the CPU is executing at this moment is not mapped away...

Other I/O

Compared to the 1.x versions this board has additional I/O, that is
also located on the bus side of the CPU-bus interface. 
The CPU control register is a 3-bit register, whose values are 
written to the MMU bits 0-2 (bits 4-11 are used for address
translation) when the CPU writes to the MMU. So for each 
MMU page three more bits can be written, and they are used as
write protect marker, no execute marker and not mapped marker.
More on this below.
The other I/O is the register where the CPU can reads its
address bus. This is useful for the case that an external CPU
halts the main CPU and reads the address where the main CPU
has stopped.
Please note the I/O addresses listed above are not fully 
decoded, so the I/O is mirrored. However, the values noted
above are the official values, the mirrored areas may go away
without warning.

External bus master

With the /BE signal the bus drivers can be disabled. This signal is 
not synchronized, so the external bus master must do it itself.
The normal operation for an external bus master to get the
bus should be:

- assert RDY		-> CPU stops after at least three cycles
- wait three cycles	-> CPU has definitely stopped (not necessary if
			   the CPU is a CMOS version)
- assert /BE 		-> ok, bus is yours.

... do your business

- release /BE 
- release Sync 


Bus errors

The external bus master is useful especially when there is a bus error.
The 6502 can not stop the execution of an opcode and return to the state
of before the execution of this opcode. Therefore, if the 6502 accesses
a memory area that is not mapped, it can not interrupt, map that page in
and continue. Instead the main CPU must be haltet, and an external - 
auxiliary - CPU can take over the control of the bus and map that page in.

This CPU board provides three features to support the auxiliary CPU:
CPU control register bit 0 can be used to set a page to write protected.
A write on such a page is detected and the /MEMSEL line is deactivated,
so that the write is not actually performed to real memory. Similarly
CPU control register bit 1 can set a page to not mapped. CPU control
register bit 2 sets a page to "no execute", i.e. an error occurs when the
CPU fetches an opcode on such a page. All bits are zero on reset, and
must be set to 1 to be active. They are set to the MMU register for every
page, so the values can be set differently for each page.


Bugs

I consider it a bug that /IOSEL is not an open-collector line that 
can be pulled by an external mapping card itself. Then /EXTIO could
be removed. But this is not really important, is it?

