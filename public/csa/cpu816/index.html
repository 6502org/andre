<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<META NAME="keywords" CONTENT="CSA65 65816 CPU">
<TITLE>CS/A 65816 CPU</TITLE>
<LINK REL="stylesheet" TITLE="Default" TYPE="text/css" HREF="../../style.css">
<LINK REL="alternate stylesheet" TITLE="Advanced" TYPE="text/css" HREF="../../advanced.css">
</HEAD>
<BODY>
<DIV ID="menu">
<ul><li class=homepage><a href=../../index.html>Homepage</a></li>
<ul class="menu0" >
<li class="separator">Commodore</li>
<li class="dir"><a href="../../petindex/index.html">CBM PETindex</a></li>
<li class="dir"><a href="../../cbmhw/index.html">CBM hardware and mods</a></li>
<li class="separator">Hardware</li>
<li class="dir"><a href="../../csa/index.html">CS/A65 Caspaer and Gecko computer</a></li>
<ul class="menu1" >
<li class="file"><a href="../memmap.html">Memory Map</a></li>
<li class="separator">Specifications</li>
<li class="file"><a href="../bus.html">Bus V1.0</a></li>
<li class="file"><a href="../bus-1.1.html">Bus V1.1</a></li>
<li class="separator">Main boards</li>
<li class="dir"><a href="../cpu/index.html">CS/A65 CPU</a></li>
<li class="dir"><a href="../bios/index.html">CS/A65 BIOS </a></li>
<li class="dir"><a href="../cpu816v2/index.html">65816 CPU V2</a></li>

<li class="dir"><a href="../petcpu/index.html">64k PET CPU</a></li>
<li class="dir"><a href="../gecko/index.html">Gecko</a></li>
<li class="dir"><a href="../auxcpu/index.html">Auxiliary CPU</a></li>
<li class="dir"><a href="../pwr/index.html">Power Supply</a></li>
<li class="separator">I/O boards</li>
<li class="dir"><a href="../vdc/index.html">Video board</a></li>
<li class="dir"><a href="../petio/index.html">CBM PET I/O</a></li>
<li class="dir"><a href="../shug/index.html">PC floppy</a></li>
<li class="dir"><a href="../drvio/index.html">DRVIO floppy and IEC</a></li>
<li class="dir"><a href="../duart/index.html">Double UART (RS232)</a></li>
<li class="dir"><a href="../scsi/index.html">SCSI/I2C board</a></li>
<li class="dir"><a href="../spi/index.html">MMC/SD-Card</a></li>
<li class="separator">Special purpose</li>
<li class="dir"><a href="../ramdisk/index.html">SIMM RAMDisk</a></li>
<li class="dir"><a href="../copro/index.html">Coprocessor board</a></li>
<li class="dir"><a href="../cpuemu/index.html">Emulate a 6502</a></li>
<li class="dir"><a href="../keyemu/index.html">Emulate a keyboard</a></li>
<li class="dir"><a href="../viaproto/index.html">VIA prototyping</a></li>
<li class="separator">Deprecated boards</li>
<li class="dir"><a href="../cpu816/index.html">65816 CPU V1</a></li>
<li class="dir"><a href="../cpu65b/index.html">64k CPU</a></li>
<li class="dir"><a href="../key/index.html">Keyboard and RS232</a></li>
<li class="dir"><a href="../iec/index.html">IEEE488 and CBM IEC</a></li>
<li class="separator">Other links</li>
<li class="dir"><a href="../gallery/index.html">Gallery</a></li>
<li class="dir"><a href="../emu/index.html">VICE emu of CS/A65</a></li>
<li class="link"><a href="../../cbmhw/c64csa/index.html">C64 CS/A adapter</a></li>
</ul>
<li class="dir"><a href="../../hwinfo/index.html">ICs and Standards Info</a></li>
<li class="dir"><a href="../../mischw/index.html">Other hardware (e.g. tools)</a></li>
<li class="separator">Software</li>
<li class="dir"><a href="../../osa/index.html">GeckOS operating system</a></li>
<li class="dir"><a href="../../lib6502/index.html">Lib6502 standard</a></li>
<li class="dir"><a href="../../o65/index.html">O65 file format</a></li>
<li class="dir"><a href="../../misc/index.html">Misc software</a></li>
<li class="separator">Knowledge Bits</li>
<li class="dir"><a href="../../icapos/index.html">Computer/OS Architecture</a></li>
<li class="dir"><a href="../../icaphw/index.html">6502 Hardware Bits</a></li>
<li class="separator">Misc</li>
<li class="file"><a href="../../contact.html">Contact</a></li>
</ul>
</ul>
</DIV>
<DIV ID="content">
<H1>CS/A 65816 CPU</H1>

<div class="overview">
<p><p>This board implements a 65816 CPU board for the CS/A computer.
		The CPU runs on eight times the bus clock speed, i.e. for a 
		1 MHz bus, the CPU runs on 8 MHz. Currently only 1 MHz bus/8 MHz CPU
		is supported though.
		It features up to 2 MByte fast RAM that is used at CPU speed.
		To access the bus memory and I/O, the CPU is slowed down to bus
		clock speed with the RDY pin.
		</p><p>
		This board is almost all in standard logic, only for the timing-critical parts I had to use
		a GAL. The board has been superseded by <a href="../cpu816v2/index.html">CPU816 V2</a> which uses a CPLD
		as main logic element. If you don't have access to a Xilinx CPLD environment or don't want to use them, 
		you may still want to look at the version 1 page here.</p>
	</p>
</div>
<DIV ID="toc">
<H2>Table of content</H2>
<dir>
<li><a href="#making">Making of</a></li>
<li><a href="#discussion">Discussion</a></li>
<li><a href="#timinglo">Timing - low resolution</a></li>
<li><a href="#timinghi">Timing - high resolution</a></li>
<li><a href="#memmap">Memory Map</a></li>
<li><a href="#future">Notes and possible future enhancements</a></li>
<li><a href="#driver">Driver</a></li>
<dir>
<li><a href="#driver1">Simple test suite</a></li>
<li><a href="#driver2">PET Fat40 ROM patch</a></li>
</dir>
<li><a href="#boards">Board Revisions</a></li>
<dir>
<li>
<a href="#board1">1.1F</a> (prototype)</li>
<li>
<a href="#board2">1.1E</a> (prototype)</li>
</dir>
<li><a href="#blkdiag">Block diagram</a></li>
</dir>
</DIV>
<H2><a name="making">Making of</a></H2>
<p><p>
			The 65816 board took a long time in the making. First of all, to get the
			amount of memory I had imagined, I had to resort to using SMD chips for the
			memory - something I had not done before, but it worked out well.
			</p><p>
			Also, to get the necessary short delay times in the logic signals, I also
			had to use a GAL programmable logic IC. I did not want to use such an IC
			for a long time, as it requires a separate programmer. Also I wanted to 
			build the systems in a ways that are easily understandable from the schematics -
			in a GAL you can hide a lot of 'magic'.
			</p><p>
			Then of course there were the first bugs of the <quote>brown paper bag</quote>
			quality - for example I completely forgot the logic about the <code>XBE</code>
			signal, i.e. IC21D, IC20B and IC21C. 
			This of course made the data bus driver for the CS/A bus a continous driver.
			<div class="rightimg">
                		<img src="Bank0%20adapter.PNG"><br>A '573 replacement fixed for bank 0 - an essential debug tool.
        	        </div>
			And I was wondering why it worked with the Bank0 adapter replacement for IC 10 
			(the typical 65816 design address latch for A16-23) but not with the real '573...
			</p><p>
			The suspicions I had made me introduce the RS-Flipflop with IC16A/IC16B as well -
			it enables the slow memory handling only after the first valid CPU vector pull, 
			i.e. when it reads the RESET vector.
			</p><p>
			One remarkable thing - once I created the <code>XBE</code> signal the system worked
			relatively stable in 1MHz mode, i.e. the circuit to slow down the CPU was essentially
			already working right from the start. Even accessing fast memory and executing
			code in fast memory was working - but it was not finished yet...
			</p><p>
			I found that when writing data from slow memory to fast memory, I had stray writes
			into the corresponding slow memory. E.g. writing to $082000 also wrote the fast bank
			number into $002000. Later I found out that when writing to any slow memory, the
			bank address was ORd with the actual data and stored in the memory too.
			</p><p>
			After a number of timing diagrams drawn - thinking about all the min and max delay
			times makes me wonder why these computers actually work at all... - and corresponding
			changes in the circuit, I finally found that the new 65816 was so fast in changing
			the data lines after <code>Phi2</code> (in this schematic <code>8Phi2</code>) going
			high, that these changes propagated onto the CS/A data bus before the <code>Phi2</code>
			and select lines had a chance to finalize the actually correct memory transfer.
			</p><p>
			One of the changes made was actually replacing the original <code>74LS293</code>-based
			timing signal generation. The '293 is an asynchronous counter, which I ignored in my
			previous designs. I wanted to replace it with a '163, but the '193 was the only 
			synchronous counter my local chip dealer had in stock where I could get it on short
			notice. 
			In the beginning the <code>/MEMSEL</code> and <code>/IOSEL</code> lines were qualified
			by <code>DRDY</code> - which of course does not work when the slow access happens during
			<code>Phi2</code> high: the real access would be at the next <code>Phi2</code> high 
			phase, but the select line would already be assigned. Just another of those brown
			paper bags... So I had to introduce <code>DSL</code> to qualify the select lines.
			As a final change I used the <code>C8Phi2</code> instead of <code>/8Phi2</code> as input
			to IC12B to move the falling edge of <code>/DSL</code> a little earlier, and it 
			worked!
			</p><p>
			Unfortunately my IEEE488 interface broke over the years, so I had to actually resort
			to the 'good old days' method of entering data into a computer: entering code as 
			hex values! Using my 6502 <code>@ASS</code> assembler that I had put into the 
			used PET Fat40 ROM image did not help, as it does not understand 65816 code.
			Finally I built a patched Fat40 ROM that starts up in slow (1 MHz) mode, but switches 
			to fast (8 MHz) mode by entering <code>SYS65080</code>, see the drivers section below.
			</p><p>
			By the way, the PET bell tone becomes a very short chirp when run in 8MHz speed :-)
			</p>
		</p>
<H2><a name="discussion">Discussion</a></H2>
<p><p>
			In this section I want to discuss various parts of the schematics
			</p><p>
			<code>IC13 (V6)</code> in the schematics is the new synchronous clock counter
			to create the 8 MHz <code>8Phi2</code> and <code>Phi2</code> from the 16 MHz clock.
			As both the output signals are inverted, the counter actually counts downward
			to ensure that <code>Phi2</code> phase changes happen at high-low transitions of
			<code>8Phi2</code>.
			</p><p>
			<code>IC15C</code> and <code>IC6C</code> delay <code>8Phi2</code> and <code>Phi2</code>
			respectively. <code>IC15B</code> also delays <code>8Phi2</code>, but for the CS/A bus -
			this way the board-internal and the bus <code>8Phi2</code> signals are decoupled.
			</p><p>
		<div class="rightimg">
                		<a href="CSA%20CPU816%20setup.PNG"><img width="200px" src="CSA%20CPU816%20setup.PNG"></a><br>A 65816 setup with BIOS, VDC, PETIO and PWR boards. Note that the CPU816 board is green, as opposed to the other boards it has protective paint on it so the SMD soldering would work.
       	        </div>
			<code>IC14</code> and <code>IC6A</code> generate the CS/A <code>2Phi2</code> signal,
			which is used for DRAM control for example on the VDC board. 
			Together with <code>IC19A</code> and <code>IC19D</code> the shift register 
			<code>IC14</code> doubles as signal generator for the <code>Q3</code> and <code>Q7</code>
			signals that are used to control the slowdown of the CPU (see timing section below).
			</p><p>
			<code>IC21C</code>, <code>IC20B</code> and <code>IC21D</code> generate the <code>XBE</code>
			signal that enables the data bus driver <code>IC8</code> between the CPU data bus and
			the CS/A data bus during a slow access.
			</p><p>
			<code>ICs 5, 7, 9</code> are the address and control line bus drivers for the CS/A
			bus. They can be disabled by the <code>/BE</code> bus signal so that an external
			CPU could take over the bus. The main signals used by the <a href="../auxcpu/index.html">AUXCPU</a> board to take over the bus,
			namely <code>NOTMAPD</code>, <code>NOEXEC</code>, <code>WPROT</code> and <code>SYNC</code>
			are not used here though.
			</p><p>
			<code>IC19B</code>, <code>IC19C</code>, <code>IC17</code>, the RS flip-flops
			<code>IC20C/IC20D</code> and <code>IC16C/IC16D</code>, <code>IC12B</code> 
			and <code>IC18</code> implement the timing to slow down the CPU during a slow access.
			They mainly create the <code>RDY</code> signal that slows down the CPU, and the
			<code>/SL</code> that is active during the actual slow access cycle, see timing below.
			</p><p>
			<code>IC10</code> is the typical 65816 data bus latch to create the address lines
			<code>A16-23</code>. <code>IC20A</code> creates the latch signal using the
			<code>8Phi2</code> cpu clock and the <code>/RDY</code> line to ensure the address
			is not latched when the CPU is waiting for a data transfer.
			</p><p>
			The RS flip-flop <code>IC16A/IC16B</code> detects the first valid vector pull - i.e.
			when the CPU reads the reset vector. This is (may be?) necessary to avoid that 
			bogus slow memory access cycles are executed before a valid address is used.
			In particular it is avoided that the first vector is read in the middle of a slow
			memory access (as <code>RDY</code> is not obeyed during <code>/RES</code>, the first
			cylce does not wait for a previous - bogus - access to finish).
			</p><p>
			The RS flip-flop <code>IC21A/IC21B</code> is used to determine the BOOT mapping.
			During boot, the CS/A bus (slow) memory is mapped into the low 64k address. This
			allows to boot the CPU using the standard BIOS ROM. But accessing the fourth RAM
			IC (<code>/RSEL3</code>, meaning banks <code>$18-$1f</code>) switches the configuration
			so that bank 0 is now filled with fast RAM - except the I/O area at <code>$e800-$efff</code>
			and the video memory area at <code>$8000-$87ff</code>. The select signals for these
			memory areas are provided by <code>IC4</code>.
			</p><p>
			<code>IC11</code> is the programmable logic IC that does a lot of the 
			address decoding.
			</p><p>
			Finally <code>ICs 1, 2, 3, 23</code> are the 4 512k static RAM chips that provide
			the onboard 2 MByte fast RAM.
			</p>
		</p>
<H2><a name="timinglo">Timing - low resolution</a></H2>
<p><p>
		This section describes the basic <quote>low-res</quote> timing for the different timing
		signals that control the access to the slow memory. Please use the 
		<a href="timing1.png">first timing diagram</a> as sample reference.
		I used this diagram to find out where the bank address could possibly be written
		into the slow memory as a stray write.
		</p><p>
		In the first line you see <code>8Phi2</code>, the main CPU clock signal. As you can see
		a single cycle is covered by 1cm paper (one square is 5mm by 5mm). The <code>Phi2</code>
		signal in the next line visualizes the actual speed difference between the 65816 and the
		bus (slow memory) access. 
		</p><p>
		What is shown in the diagram is actually five memory accesses - the first slow, then three
		fast ones, and then a slow one again (Note that the comments on the top of the diagram are
		not entirely consistent).
		</p><p>
		The next two lines show the signals <code>Q3</code> and <code>Q7</code>. These signal control
		the start and end of the actual slow access respectively. They are generated by ORing the
		correct outputs of the shift register <code>IC14</code> that shifts <code>Phi2</code> with 
		the clock <code>8Phi2</code>.
		</p><p>
		When the 65816 puts a <quote>slow</quote> address on the address lines, it can do so
		at any of the eight <code>8Phi2</code> cycles that make up one <code>Phi2</code> cycle.
		When that happens, the GAL <code>IC11</code> generates the <code>/SLOWMEM</code> signal.
		<code>/SLOWMEM</code> is clocked by <code>8Phi2</code> to create <code>RRDY</code> - any
		floating address lines should have stabilized then. When <code>RRDY</code> becomes active,
		the <code>IC20C/IC20D</code> flip-flop deasserts <code>RDY</code>. This happens directly
		after <code>8Phi2</code> went high, so <code>RDY</code> always goes high when <code>8Phi2</code>
		is high. This now just stops the CPU without setting any select signals, which has to be
		done in a controlled manor.
		</p><p>
		The actual slow cylce is then initiated by <code>Q3</code>. When <code>RDY</code> is deasserted
		during <code>Q3</code>, <code>XQ3</code> is asserted and sampled at the falling edge of 
		<code>8Phi2</code>. This asserts <code>/RSL</code>, and the flip-flop <code>IC16C/IC16D</code>
		asserts <code>/SL</code>. <code>/SL</code> is in turn used by the GAL to activate the
		slow memory select lines <code>/IOSEL</code> and <code>/MEMSEL</code>.
		</p><p>
		The initial <quote>brown paper bag</quote> version did not use <quote>/SL</quote> to create the
		slow memory select lines but <code>DRDY</code>. This resulted in the select lines being 
		asserted even when the slow access was initiated by the cpu just in the middle of a
		slow <code>Phi2</code> high phase. In the diagram there is one slow access, then three fast
		accesses, then one slow access. The slow access is started right after <code>Q3</code>, so
		it has to wait for the next <code>Q3</code> in the next <code>Phi2</code> high phase
		to actually start. The initial version would have asserted the select lines nevertheless.
		That is why now <code>/SL</code> is used to generate the select lines.
		</p><p>
		<code>Q7</code> then initiates the end of the slow cycle (when <code>/SL</code> is asserted).
		<code>XQ7</code> is sampled by <code>IC17B</code> at the rising edge of <code>8Phi2</code> -
		the rising edge of the cpu's clock cycle that actually ends the slow memory access. 
		This leads to <code>/SSL</code> and <code>SRDY</code> becoming active, asserting <code>RDY</code>
		and ending the <code>/SL</code> phase.
		At the end of this <code>8Phi2</code> high phase, the memory access is finished.
		</p><p>
		To complete the select cycle, the select signals must be released when <code>Phi2</code>
		goes low. This is done by using <code>DSL</code>, the delayed <code>/SL</code> signal,
		to create a GAL-internal <code>SLOWSEL</code> signal that times the select signals.
		</p><p>
		In principle that timing diagram governs the 65816 memory accesses. In principle the gate 
		delay times are accounted for and all signals are sufficiently sampled with either 
		<code>8Phi2</code> or <code>/8Phi2</code>.
		</p><p>
		A glimpse of what could happen can be seen in the <code>/SLOWMEM</code> signal. This signal
		is derived from the address lines, <code>A16-23</code> amongst them. Due to the data bus
		multiplexing of the 65816, <code>A16-23</code> partially contain invalid addresses, as the
		actual data is still sent from the cpu. The address value and with it <code>/SLOWMEM</code>
		should be stabilized before <code>8Phi2</code> actually goes high, therefore <code>/SLOWMEM</code>
		is sampled with the rising edge of <code>8Phi2</code>. But it has to be clear that there
		can be and are timing related effects on the signals. 
		</p><p>
		More on these timing effects can be seen in the next section.
		</p></p>
<H2><a name="timinghi">Timing - high resolution</a></H2>
<p><p>
		This section describes the timing of the board in a higher resolution. Please use the 
		<a href="timing2.png">second timing diagram</a> as reference. Its purpose was to determine
		why I still had stray writes at the end of a slow memory access.
		</p><p>
		As you can see in the first line, the scale is much different from the first timing
		diagram. Each millimeter in the diagram represents a single nanosecond (squares on the paper
		are 5mm by 5mm). The first line shows the <code>8Phi2</code> signal - basically a single 
		clock cycle, with the high phase first. The second line shows the end of the
		<code>Phi2</code> cycle, with its high-to-low transition. What you can immediately see
		is that the signals (except <code>8Phi2</code>) have uncertainty intervals. 
		These intervals represent the difference between the <quote>min</quote> and <quote>max</quote>
		delay times given in the datasheets of the relevant ICs. If a signal as an uncertainty
		when it is used as input to an IC, the output has this uncertainty plus the one from the
		IC added. 
		</p><p>
		Note that this is probably a bit too much on the safe side. The uncertainties have a certain
		independent part, for example production tolerances. But they also have a certain dependent
		part, like temperature dependency (most ICs react similar on the same temperature changes).
		While the dependent parts actually add up, the uncertainties of the independent parts would
		have to be added as square root of the sum of squares.
		But as it is not clear how much of the delay is dependent and how much is independent, it 
		can only be added up.
		</p><p>
		A single ALS TTL logic gate typically has a delay of 2-12 ns (for a '02). As you can see the 
		range is great compared to the absolute delay. Having two gates behind each other 
		already results in a delay of 4-24 ns and so on. This can quickly add up to a relevant 
		value. Also compare these values to the 65 ns that a <code>8Phi2</code> signal stays high
		or low at 8 MHz. There quickly is not much time left.
		</p><p>
		In the diagram you can see this in the <code>RDY</code>generation. <code>SRDY</code> has a 
		delay of 2-14ns from <code>8Phi2</code> caused by a 74ALS74. <code>/RDY</code> is derived from
		<code>SRDY</code> by a 74ALS02, which adds 2-12ns. Now <code>RDY</code> is not simply 'just'
		the negative from <code>/RDY</code>, but is created by another 74ALS02, which again adds
		2-12ns!
		</p><p>
		The whole thing becomes interesting when you look at the cpu's D0-D7 signals. 
		As the cpu runs at 8 MHz, the data value only stays up to (guaranteed) 10ns after 
		<code>8Phi2</code> going low. Add the 3-10ns delay of a 74ALS245 and you can only see
		the data values of a write for 13-20ns on the CS/A data bus (notwithstanding any 
		parasitive capacitances). What is worse is, that the 65816 then starts writing out
		the bank address of the next access on the cpu's data bus lines. 33ns from 
		<code>8Phi2</code> going low the bank address is stable - which means they must have
		been put on the bus some time earlier.
		</p><p>
		This also actually means that signals <code>MA16-23</code> can contain the data 
		values instead of the address values, as <code>LATCH</code> enables the '573 latch
		2-12ns after <code>8Phi2</code> goes low.
		</p><p>
		<code>/SL</code> goes high 2-11ns from <code>SRDY</code>. <code>DSL</code>, however, 
		goes low 2-14ns after <code>/8Phi2</code> goes high, which is already 2-10ns behind
		<code>8Phi2</code> going low (Note: this diagram is before the last change where <code>DSL</code>
		generation uses <code>C8Phi2</code> instead of <code>/8Phi2</code>). 
		I.e. <code>DSL</code> goes low 4-24ns after <code>8Phi2</code>
		goes low. The GAL that derives <code>/MEMSEL</code> from <code>DSL</code> adds another
		up to 15ns delay. It is good that <code>XBE</code> also uses <code>LATCH</code> to 
		disconnect the CS/A bus from the cpu's data bus - but this also explains why 
		earlier attempts to remove the <code>LATCH</code> use from <code>XBE</code> failed.
		</p><p>
		In the diagram you can see that the <code>/MEMSEL</code> line can go high as late as 42ns
		after <code>8Phi2</code> going low. This was the reason for me to change the CLK input
		of <code>IC12B</code> from <code>/8Phi2</code> to <code>C8Phi2</code>, which actually is
		the source of <code>8Phi2</code> (via <code>IC15C</code>). 
		</p><p>
		What this diagram shows is that contrary to 1MHz or 2MHz circuits, faster circuits have 
		much harder timing requirements and when with 1MHz you may get away with the proverbial murder,
		with higher clock frequences the timing police will get you...
		</p></p>
<H2><a name="memmap">Memory Map</a></H2>
<p>
		<p>The memory map is relatively simple. There are two modes, <code>BOOT</code> and <code>/BOOT</code>.
		During <code>BOOT</code> the lowest 64k RAM are mapped into the CS/A bus space. Of the lowest
		64k, all but 2k at <code>$8000</code> are directly mapped on the bus. The 2k at
		<code>$8000-$87ff</code> are not mapped into <code>$0xxxx</code> on the CS/A bus, but on 
		<code>$1xxxx</code>. 
		This allows to use the VDC board on <code>$1xxxx</code> and the <code>$8000-$87ff</code> area
		as video memory. This setup is used as standard 'Fat40' setup, which can be achieved with the
		65816 CPU as well.
		</p><p>
		Also the area at <code>$e800-efff</code> is setup as I/O area on the CS/A bus, which also
		supports the 'Fat40' setup.
		</p><p>
		The 2 MByte fast memory are mapped into the CPU's <code>$00xxxx-$1fxxxx</code> area, except for
		the first 64k as described above. After the first access to the highest memory chip, mapped
		at <code>$18xxxx-$1fxxxx</code>, <code>BOOT</code> mode is left and <code>/BOOT</code> mode
		is entered. This means that the first 64k are now also mapped into the fast memory -
		except the video and I/O areas at <code>$008000-0087ff</code> and
		<code>$00e800-00efff</code> respectively.
		</p><p>
		Above the fast memory, the area <code>$20xxxx-2fxxxx</code> is a mirror of the 1 MByte CS/A 
		bus memory address space.
		</p><p>
		To be able to easily copy the boot ROM to fast memory in bank 0, the area
		<code>$30xxxx-37xxxx</code> mirrors the first 512 kByte fast memory, but without the
		low 64k windows. 
		</p><p>
		Due to the fact that the address decoding GAL has no inputs for <code>A22</code> and 
		<code>A23</code>, the whole memory setup is mirrored at <code>$400000</code>,
		<code>$800000</code> and <code>$c00000</code>.
		</p>
		</p>
<H2><a name="future">Notes and possible future enhancements</a></H2>
<p><p>
		This section describes some notes and possible future enhancements of the board
		</p><p>
		1) <code>DRDY</code> is only used to disable <code>/SLOWMEM</code>, so that <code>RRDY</code>
		is only a pulse that can be sampled at the rising edge of <code>8Phi2</code> (it has been used
		for other purposes in the first - faulty - design). Maybe it can be replaced with <code>RDY</code>.
		</p><p>
		2) The GAL used is way too small. It could also replace <code>IC4</code>, as well as generate
		the <code>XBE</code> signal (replacing <code>IC21C, IC20B, IC21D</code>). It could also use
		the 65816's <code>VPB</code>, <code>VPA</code> and <code>VDA</code> lines to determine a 
		correct cpu memory access - and so for example avoid initiating a slow memory access for a 
		typical 6502 bogus memory access!
		</p><p>
		3) Similar to the PET 8296 the whole timing generation could be <quote>modernized</quote>.
		The 8296 uses a '163 synchronous timer, the input of which is given to a small PROM,
		and the output of that PROM again is clocked by the 16MHz clock. This results in absolutely
		synchronous clock signals, which makes timing much easier. In the current design 
		we would need a register clocked at <code>8Phi2</code> and another one at <code>/8Phi2</code>.
		Other approaches could reduce this requirement, though.
		</p><p>
		4) Currently <code>BRDY</code>, the CS/A bus <code>RDY</code> line is sampled at the end of
		<code>Q7</code>, when <code>XQ7</code> is sampled by <code>8Phi2</code>, 65ns before 
		<code>Phi2</code> goes low. This may or may not be a problem for slow memory that uses
		<code>RDY</code>.
 		</p></p>
<H2><A NAME="driver">Driver</A></H2>
<H3><A NAME="driver1">Simple test suite</A></H3>
<p>These tests test the basic functionality of the board, and also do some timing
			measurement to actually see if the access is fast or not.
			Note that these tests are small as I had to enter them with the hex editor.
			Simply assemble them with the <code>xa</code> cross assembler with the <code>-w</code>
			switch to allow 65816 code.
		</p>
<TABLE class="files">
<TR CLASS="R1">
<TD><IMG SRC="../../imgs/file_driver.gif" ALT="driver"></TD>
<TD>
<A HREF="pettest1.a65">pettest1.a65</A>(Copies 4k from (slow) ROM to fast RAM and back to slow RAM. I used it to investigate the stray writes which appeared in the slow memory when writing to the fast memory.)</TD>
</TR>
<TR CLASS="R0">
<TD><IMG SRC="../../imgs/file_driver.gif" ALT="driver"></TD>
<TD>
<A HREF="pettest2.a65">pettest2.a65</A>(Check if CPU executes code in fast RAM by copying a long ump back to slow memory and executing it)</TD>
</TR>
<TR CLASS="R1">
<TD><IMG SRC="../../imgs/file_driver.gif" ALT="driver"></TD>
<TD>
<A HREF="pettest2a.a65">pettest2a.a65</A>(Executes a longer loop in fast memory)</TD>
</TR>
<TR CLASS="R0">
<TD><IMG SRC="../../imgs/file_driver.gif" ALT="driver"></TD>
<TD>
<A HREF="pettest4.a65">pettest4.a65</A>(Executes a loop in slow memory and in fast memory, and times both with the VIA timer)</TD>
</TR>
<TR CLASS="R1">
<TD><IMG SRC="../../imgs/file_driver.gif" ALT="driver"></TD>
<TD>
<A HREF="pettest4a.a65">pettest4a.a65</A>(Use the VIA timer to time exactly one (fast) memory access)</TD>
</TR>
</TABLE>
<H3><A NAME="driver2">PET Fat40 ROM patch</A></H3>
<p><p>This patch lets the PET copy the PET ROM from the slow ROM on the BIOS card to the
		(mirrored) fast bank 0 RAM when it boots. Additional code at address 65080 then switches
		from BOOT mode into normal mode, i.e. unmaps the slow CS/A memory from bank 0 and jumps
		into the copied PET ROM Reset. Besides this code some BIOS card, VDC card and CRTC registers are 
		initialized differently to setup the correct video address and memory setup.
		</p><p>
		To enter the fast mode, enter <code>SYS 65080</code> in the PET Basic editor.
		</p><p>
		Note that the binary image also contains an @MON monitor program adapted for the PET
		(including screen up/down scroll etc - but without 65816 opcodes) at $A000-AFFF. It is started
		with <code>SYS 40960</code>.
		</p><p>
		Also note that IEEE488 has not been tested yet (due to my broken lpt-ieee488 interface).
		</p></p>
<TABLE class="files">
<TR CLASS="R1">
<TD><IMG SRC="../../imgs/file_driver.gif" ALT="driver"></TD>
<TD>
<A HREF="petpatch2.a65">petpatch2.a65</A>(CS/A Fat40 65816 setup ROM Patch to apply to a normal 40col CRTC PET ROM)</TD>
</TR>
<TR CLASS="R0">
<TD><IMG SRC="../../imgs/file_driver.gif" ALT="driver"></TD>
<TD>
<A HREF="fat40_816v4.bin">fat40_816v4.bin</A>(Precompiled CS/A Fat40 65816 setup ROM (32k))</TD>
</TR>
</TABLE>
<H2><A NAME="boards">Board revisions</A></H2>
<H3><A NAME="board1">Version: 1.1F</A></H3>
<P>Status: prototype</P>
<H4>Notes</H4>
<TABLE class="notes">
<TR>
<TD class="noteicon"><IMG SRC="../../imgs/note_msg.gif" ALT="msg"></TD>
<TD>
			Compared to the 1.1E board this board adds a 2k2 pull-up resistor on <code>BRDY</code>. Now
			the CS/A bus RDY handling works, i.e. a CS/A bus board can slow down the CPU even more
			if necessary.
		</TD>
</TR>
</TABLE>
<H4>Files</H4>
<TABLE class="files">
<TR CLASS="R1">
<TD><IMG SRC="../../imgs/file_schem.gif" ALT="schem"></TD>
<TD><A HREF="csa_cpu816-v1.1f.sch">csa_cpu816-v1.1f.sch</A></TD>
</TR>
<TR CLASS="R0">
<TD><IMG SRC="../../imgs/file_schem.gif" ALT="schem"></TD>
<TD><A HREF="csa_cpu816-v1.1f-sch.png">csa_cpu816-v1.1f-sch.png</A></TD>
</TR>
</TABLE>
<H3><A NAME="board2">Version: 1.1E</A></H3>
<P>Status: prototype</P>
<H4>Notes</H4>
<TABLE class="notes">
<TR>
<TD class="noteicon"><IMG SRC="../../imgs/note_msg.gif" ALT="msg"></TD>
<TD>
			The shown schematics has been implemented by patching up
			an older 1.1 board version. However, as there are too many differences,
			and I haven't yet done a new board layout, there is no board schematics.
			With the lessons learned from this version, I'd also rather make
			a new 1.2 version with a complete new layout.
		</TD>
</TR>
<TR>
<TD class="noteicon"><IMG SRC="../../imgs/note_warn.gif" ALT="warn"></TD>
<TD>
			There could be an issue with the VDC memory access. I am not sure if this
			is an issue with the 65816 board or the VDC board and the RAM chip it currently
			uses. I will check the VDC board with my newly acquired skills in drawing 
			timing diagrams though. The issue shows is seldom stray writes into the 
			video memory when scrolling the PET screen. May have been a bad soldering joint
			though, I currently cannot reproduce it.
		</TD>
</TR>
<TR>
<TD class="noteicon"><IMG SRC="../../imgs/note_warn.gif" ALT="warn"></TD>
<TD>
			Preliminary tests indicate that the <code>BRDY</code> handling is not yet correct, i.e.
			when a CS/A bus board tries to slow down the CPU even more.
		</TD>
</TR>
<TR>
<TD class="noteicon"><IMG SRC="../../imgs/note_msg.gif" ALT="msg"></TD>
<TD>
			The TTL types are mostly 'ALS. Please refer to the parts list and not
			to the schematics for the TTL technology type.
		</TD>
</TR>
</TABLE>
<H4>Files</H4>
<TABLE class="files">
<TR CLASS="R1">
<TD><IMG SRC="../../imgs/file_photo.gif" ALT="photo"></TD>
<TD>
<A HREF="CPU816%20top.PNG">CPU816 top.PNG</A>(65816 prototype board from top with replaced ICs ...)</TD>
</TR>
<TR CLASS="R0">
<TD><IMG SRC="../../imgs/file_photo.gif" ALT="photo"></TD>
<TD>
<A HREF="CPU816%20back.PNG">CPU816 back.PNG</A>(... and from the back - where you can clearly see its status too)</TD>
</TR>
<TR CLASS="R1">
<TD><IMG SRC="../../imgs/file_photo.gif" ALT="photo"></TD>
<TD>
<A HREF="PET%20Loop%20slow.PNG">PET Loop slow.PNG</A>(A simple delay loop on the 1MHz PET (CS/A version))</TD>
</TR>
<TR CLASS="R0">
<TD><IMG SRC="../../imgs/file_photo.gif" ALT="photo"></TD>
<TD>
<A HREF="PET%20Loop%20fast.PNG">PET Loop fast.PNG</A>(And the same delay loop after switching to 8MHz :-))</TD>
</TR>
<TR CLASS="R1">
<TD><IMG SRC="../../imgs/file_parts.gif" ALT="parts"></TD>
<TD><A HREF="csa_cpu816-v1.1e-parts.txt">csa_cpu816-v1.1e-parts.txt</A></TD>
</TR>
<TR CLASS="R0">
<TD><IMG SRC="../../imgs/file_schem.gif" ALT="schem"></TD>
<TD><A HREF="csa_cpu816-v1.1e.sch">csa_cpu816-v1.1e.sch</A></TD>
</TR>
<TR CLASS="R1">
<TD><IMG SRC="../../imgs/file_schem.gif" ALT="schem"></TD>
<TD><A HREF="csa_cpu816-v1.1e-sch.png">csa_cpu816-v1.1e-sch.png</A></TD>
</TR>
<TR CLASS="R0">
<TD><IMG SRC="../../imgs/file_logic.gif" ALT="logic"></TD>
<TD>
<A HREF="CPU816%20V04.PLD">CPU816 V04.PLD</A>(The GAL20V8 source)</TD>
</TR>
<TR CLASS="R1">
<TD><IMG SRC="../../imgs/file_logic.gif" ALT="logic"></TD>
<TD>
<A HREF="CPU816V4.jed">CPU816V4.jed</A>(The GAL20V8 compiled logic file)</TD>
</TR>
<TR CLASS="R0">
<TD><IMG SRC="../../imgs/file_timing.gif" ALT="timing"></TD>
<TD>
<A HREF="timing1.png">timing1.png</A>(Sample low-res timing diagram)</TD>
</TR>
<TR CLASS="R1">
<TD><IMG SRC="../../imgs/file_timing.gif" ALT="timing"></TD>
<TD>
<A HREF="timing2.png">timing2.png</A>(Sample high-res timing diagram)</TD>
</TR>
</TABLE>
<H2><A name="blkdiag">Block diagram</A></H2>
<img src="diagram.gif" alt="block diagram"><p>Block diagram of the cpu board. 
		In principle the board is simple - the CPU is connected to the bus and the fast memory with its address and data lines.
		The '573 address latch takes the address bits 16-23 from the data bus during Phi2 low. Everything is controlled by the
		control logic - which is the most complex part here... RDY is used to slow down the CPU during CS/A bus access, which 
		happens at 1MHz speed instead of the 8MHz CPU speed. 
		</p>
<DIV ID="footer">
<P>Last modified: 2010-04-11.</P>
<p>Return to <a href="../../index.html">Homepage</a></p>

</DIV>
</DIV>
</BODY>
</HTML>
