<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;" />
<meta name="author" content="Andr&#xE9; Fachat" />

<meta name="description" content="" />
<meta name="keywords" content="Xilinx programmable-logic CPLD FPGA programmer" />
<link rev="made" href="mailto:afachat@gmx.de" />
<link rel="stylesheet" title="Default" type="text/css" href="../style2-min.css" /><link href="../shariff.complete.css" rel="stylesheet" />
<title>Xilinx tools</title></head>
<body><div id="mainbox"><a name="top" id="top"></a><div id="topsearch"><form method="get" action="http://www.google.com/search" target="_blank" autocomplete="off"><input id="searchinput" alt="search" name="q" size="10" maxlength="255" type="text" value="" /><input class="advbutton" value="Search site" type="submit" /><div id="srchprov">(by Google)</div><input name="sitesearch" value="www.6502.org/users/andre" type="hidden" /></form><div id="topfind"><div id="topprogress"></div></div></div><div id="menubox">


<div id="menu1" class="mclose">
<div id="twist1" class="twisty"></div>
<div class="hdrtxt"><a href="../index.html">Home&nbsp;&gt;</a></div>
<ul class="nav1">
<li>
<ul class="nav2">
<li class="navhdr"><a href="../index.html">Home</a></li>
<li><a href="../contact.html">Contact</a></li>
<li><a href="../design.html">Web design</a></li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Hardware</span></li>
<li><ul class="nav2" >
<li><a href="../65k/index.html">The 65k Project</a>
</li>
<li><a href="../pet816/index.html">PET816 Accelerator</a>
</li>
<li><a href="../csa/index.html">CS/A65</a>
</li>
<li><a href="../cbmhw/index.html">CBM mods</a>
</li>
<li><a href="../spi65b/index.html">SPI65B</a>
</li>
<li><a href="../mischw/index.html">Other hardware</a>
</li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Software</span></li>
<li><ul class="nav2" >
<li><a href="../osa/index.html">GeckOS</a>
</li>
<li><a href="../lib6502/index.html">lib6502 </a>
</li>
<li><a href="../o65/index.html">o65</a>
</li>
<li><a href="../usb65/index.html">usb65</a>
</li>
<li><a href="../xd2031/index.html">XD2031</a>
</li>
<li><a href="../misc/index.html">Misc</a>
</li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Library</span></li>
<li><ul class="nav2" >
<li><a href="../petindex/index.html">PETindex</a>
</li>
<li><a href="../petindex/drives/index.html">PET drives</a>
</li>
<li><a href="../adv65/index.html">Advanced 6502</a>
</li>
<li><a href="../hwinfo/index.html">ICs and Standards</a>
</li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Knowledge Bits</span></li>
<li><ul class="nav2" >
<li><a href="../icapos/index.html">Computer/OS Architecture</a>
</li>
<li><a href="../icaphw/index.html">6502 Hardware Bits</a>
</li>
<li><a href="../emulation/index.html">Emulation</a>
</li>
</ul>
<div class="nend2"></div>
</li>
<div class="nend1"></div>
</ul>
</div>
<div id="menu2" class="mopen">
<div id="twist2" class="twisty"></div>
<div class="hdrtxt"><a href="index.html">Hardware Bits&nbsp;&gt;</a></div>
<ul class="nav1">
<li>
<ul class="nav2">
<li class="navhdr"><a href="index.html">Hardware Bits</a></li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Basics</span></li>
<li><ul class="nav2" >
<li><a href="design.html">Hardware design lesson</a></li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Tools</span></li>
<li><ul class="nav2" >
<li><a href="oscope/index.html">Oscilloscope bits</a>
</li>
<li><a href="xilinx.html">Xilinx CPLD tools</a></li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Interfaces</span></li>
<li><ul class="nav2" >
<li><a href="c64ser.html">UART serial interface</a></li>
<li><a href="remote.html">Infrared remote control</a></li>
<div class="nend2"></div>
</ul>
</li>
<div class="nend1"></div>
</ul>
<ul class="nav1" >
<li><span>Misc</span></li>
<li><ul class="nav2" >
<li><a href="rdy.html">RDY generation</a></li>
<li><a href="../csa/blitter/works.html">&gt;How a Blitter works</a></li>
<li><a href="../petindex/poke/index.html">&gt;The PET Killer Poke</a></li>
</ul>
<div class="nend2"></div>
</li>
<div class="nend1"></div>
</ul>
</div>
	</div><div id="midcol"><div class="top" id="content"><div id="minmax"></div>

<h1>Xilinx tools</h1><p class="copyright">(C)
- André Fachat</p> 
<div class="overview"><p>
		In my newest designs (for example the <a href="../csa/cpu816v2/index.html">CSA 65816 CPU V2</a> I 
		started to use programmable logic from Xilinx, especially a CPLD - 
		<a class="extlink" href="http://www.wikipedia.org/wiki/CPLD">Complex Programmable Logic Devicei</a>.
		</p><p>
		When I started to work on that, I had to decide which manufacturer to use. Unfortunately in the
		area of CPLDs or FPGAs, there are no manufacturer-independent standards in the sense that you
		could simply replace an FPGA from one manufacturer with one from another manufacturer.
		Possible manufacturers are <a class="extlink" href="http://www.xilinx.com">Xilinx</a>,
		<a class="extlink" href="http://www.lattice.com">Lattice</a>, <a class="extlink" href="http://www.atmel.com">Atmel</a>, 
		<a class="extlink" href="http://www.altera.com">Altera</a>, and possibly others.
		Therefore I was looking around and, depending on availability (at my favourite parts suppliers)
		and the licencing and availability of a free development environment, I decided to use the Xilinx
		versions, as they were still availably in 5V, through-hole parts, and the ISE Webkit was available
		for free, without any relicensing every year involved (at least from what I understand).
		</p><p>
		For a deeper introduction look at <a class="extlink" href="http://hackaday.com/2008/12/11/how-to-programmable-logic-devices-cpld/">Hack-a-day CPLD page</a>.
		</p>
	</div><div id="toc" class="h2"><div class="h2h"><div class="h2t"> </div><h2>Table of content</h2></div><div class="h2c"><ul><li><a href="#dev">Development environment</a></li><li><a href="#prog">Programmer</a></li><li><a href="#vhdl">VHDL</a></li><li><a href="#sim">VHDL simulation</a></li><li><a href="#lessons">Lessons learned</a></li><li style="list-style-type:none;"><ul><li><a href="#hwclose">Close to hardware...</a></li><li><a href="#iobus">Not everything works right...</a></li><li><a href="#diag">A diagnostics pin helps...</a></li></ul></li></ul></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="dev" id="dev">Development environment</a></h2></div><div class="h2c"><p>The Xilinx devices can be programmed with the ISE Webpack. You need to register
				with Xilinx though, to be able to download it.
				The Webpack is available for Windows and Linux.
				</p><p>
				I wanted to do everything on Linux, so I first installed the Linux version only.
				I soon found out that to program the devices, the Webpack needed some custom drivers,
				which did not work under my SuSE Linux 11.2 (current version as I write this).
				I then also installed the Windows version, and was able to test-program a CPLD device.
				</p><p>
				In the meantime, however, I have found the libusbdriver code (link below) for Linux
				that I compiled and installed, and now I can easily programm the devices on Linux and
				hope not to need Windows again here!
		</p><ul><li><a href="http://www.xilinx.com/support/download/index.htm" target="_blank" class="extlink">ISE Webpack download site at xilinx</a> </li><li><a href="http://www.rmdir.de/~michael/xilinx/" target="_blank" class="extlink">libusbdriver Driver for Xilinx JTAG tools</a> </li></ul></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="prog" id="prog">Programmer</a></h2></div><div class="h2c"><p>Once you have created the CPLD code, you need to program it into the device. The standard
				CPLDs provide an in-system-programming port that you can connect to with a 6-pin cable.
				But where to connect it on the PC side? As usual, there are solutions for the printer port
				as well as USB. I built myself a "Parallel cable III" clone.
				</p><p>With this cable you are restricted to 200kHz clock while transferring the data,
				but the cable is cheap (2 74HC125 plus some resistors and capacitors).
			</p>
		<ul><li><a href="http://www.xilinx.com/itp/3_1i/data/common/hug/chap01/hug01005.htm" target="_blank" class="extlink">Xilinx parallel cable III</a> </li><li><a href="http://www.ulrichradig.de/home/index.php/cpld/basekit_xilinx_cplds" target="_blank" class="extlink">Schematics for my Programmer cable (page is in German)</a> </li></ul></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="vhdl" id="vhdl">VHDL</a></h2></div><div class="h2c"><p>The Xilinx tools allow you to use different methods of programming.
				One is using a schematics editor, to program the device like you would draw a normal schematics. Other possibilities are VHDL and Verilog.
				</p><p>I chose VHDL, as it supposedly has a stricter type system. I want my designs to "fail fast", as the later you find a bug, the higher the cost and a strict type system helps to find problems earlier in the design process.
				</p><p>
		</p></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="sim" id="sim">VHDL simulation</a></h2></div><div class="h2c"><p>
				Once you have your design ready, you want to test it. As VHDL is also designed as a simulation language,
				with the right tools you can simulate your design. Fortunately there are easy to use, free tools available.
				I found the GHDL compiler - an extension to the gcc (GNU compiler collection) - together with the
				GTKWave viewer a very useful combination (sources see links)
				</p><p>
				In the simulation, you basically do what you do with your normal hardware designs - you 
				wire it up to a testbench, feed it the right (test) inpt signals, and watch the output or
				scope the signals. In VHDL, you thus create a testbench component that includes your CPLD
				design as a component. In your testbench you create the test signals using timing statements
				like <code>wait for 5 ns</code> to generate the input signals.
				</p><p>
				Running the simulation then is a matter of compiling the design with for example the <code>ghdl</code>
				VHDL compiler, and then running it for a given simulation time. The output is stored in an output file
				and contains the values of all the internal signals as defined in your VHDL. Using the GTKWave 
				viewer you can then view the signals as they are on the time axis, zooming in and out as needed.
				See the links for a simple tutorial including a Makefile how to wire the tools together.
				</p><p>
				I am not (yet) very experienced with simulation. In my <a href="../cbmhw/pet816/index.html">PET816</a> 65816
				CPU board though I am using a testbench and intensive simulation - which made my scope almost unemployed...
				</p><p>
				What I also found a great help was to actually emulate the 6502 CPU just as well during the simulation.
				One testbench includes a <code>free6502</code> VHDL core. There it is nice to actually see - in the
				GTKWave viewer - the CPU reading the RESET vector, then the first opcode at $FD16 - of course I 
				simulated the PET kernal in VHDL as well - execute it, fetch the next one and so on...
				The main simulation tests I did with an own, fake 6502 core that has the same interface, but
				that automatically does a specific sequence of memory accesses. These memory accesses test the
				various features of the CPLD in the PET816 board, even including a write to the control register!
			</p>
		<ul><li><a href="http://ghdl.free.fr/" target="_blank" class="extlink">GHDL homepage</a> </li><li><a href="http://gtkwave.sourceforge.net/" target="_blank" class="extlink">GTKWave homepage</a> </li><li><a href="http://mbmn.net/uer/tutorials/vhdl-with-ghdl/" target="_blank" class="extlink">Simulation tutorial with GHDL</a> </li></ul></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="lessons" id="lessons">Lessons learned</a></h2></div><div class="h2c"><p>
					Nevertheless there are some lessons learned which I'll describe in the next sections.
			</p><h3><a name="hwclose" id="hwclose">Close to hardware...</a></h3><p>In the beginning I wrote some simple code that just didn't want to compile.
						What I finally found out is that I tried to modify a signal in two processes.
						That does not work, as after all, the CPLD is still some hardware design and
						the code needs to be compiled into the CPLD.
						</p><p>
						So to program a CPLD it is important to know that the code basically has to fit
						into a large array of D-Registers (one half of a 7474 basically) with some kind
						of GAL-like logic arrays in between.
						I.e. each signal is basically produced by a D-register with a flank-triggered 
						input and asynchronous set- and reset-inputs. Then it automatically becomes
						clear that a signal can only depend on a <em>single</em> "flank" of another 
						signal.
						</p><p>
						When you keep this in mind, you automatically write design the system 
						with a much higher chance that it works :-)
					</p>
				<h3><a name="iobus" id="iobus">Not everything works right...</a></h3><p>With a new technique there comes a learning curve. I found that out when I 
						tried to implement a data bus interface for the 65816 card's control register.
						The bus is a bidirectional pin, and I could use it as input as well as 
						output in VHDL, I could even set it to high impedance all right, all without
						any warning from the Webpack (at least none that I found).
						</p><p>
						However, when I measured the data bus lines, it seemed as if two ICs would
						be fighting each other. Instead of &gt;3V high level, I had less than one
						Volt. And the data bus driver as well as the CPLD were slowly getting 
						hotter. 
						</p><p>
						Obviously the CPLD was pulling down the data bus lines all the time, and the
						high impedance setting didn't have any effect (I controlled the code path
						with a diag pin and it was ok). When I removed the part that allowed to
						read the register, the system suddenly started to work!
						</p><p>
						I don't know yet what was wrong here, if I used the wrong VHDL data type, 
						or the CPLD simply can't do this combination of input and output with high
						impedance on the same pin.
				</p><h3><a name="diag" id="diag">A diagnostics pin helps...</a></h3><p>I found that reserving one pin for diagostics and then in VHDL setting this
						pin in those parts I wanted to debug helped a lot in finding out
						what was actually happening in the chip.
				</p></div></div><hr />
<p>Return to <a href="../index.html">Homepage</a></p>
	  
    Last modified: 
2011-12-23
	</div></div><div id="rightcol"><div class="top" id="share"><div class="tophead">share</div><div><div class="shariff" data-backend-url="https://fachat-shariff-backend.eu-gb.mybluemix.net/" data-theme="grey" data-orientation="vertical"></div></div></div><div class="top" id="twitter"><div class="tophead">follow</div><div><p>Follow my 8-bit tweets on
		            <a class="extlink" target="_blank" href="https://twitter.com/#!/search/realtime/afachat%20%238bit">Twitter</a> (In new window)</p></div></div><div class="top" id="forum"><div class="tophead">discuss</div><div><p>Discuss my site on <a class="extlink" target="_blank" href="http://forum.6502.org/viewtopic.php?t=956">this 6502.org forum thread</a></p><p>(Forum registration required to post)</p></div></div><div class="top" id="hot"><div class="tophead">hot!</div><div>
<p>Dive into the retro feeling and build yourself a <a href="../cbmhw/ryofat40/index.html">Commodore PET replica</a></p>
<p>Need more speed? Speed up your 6502 computer with this <a href="../pet816/index.html">10&nbsp;MHz 6502 CPU accelerator board</a></p>
<p>Interested in electronics design? Look at the <a href="../icaphw/design.html">design lesson</a> I got from Bil Herd, the hardware designer of the C128</p>
<p>Want 64bit? - pimp the 6502 with the <a href="../65k/index.html">65k processor design!</a></p>

		</div></div></div><div id="footer"> </div></div><script type="text/javascript">myUp="../";</script><script type="text/javascript" src="../scripts2-all.js"></script><script type="text/javascript" src="../shariff.min.js"></script></body></html> 

