<!DOCTYPE webpage [ <!ENTITY eacute "&#233; "> <!ENTITY nbsp "&#160;"> ]>
<webpage name="How does the 65816 bord work?">
  <author>
    <name>Andr&eacute; Fachat</name> 
    <email>@EMAIL@</email>
    <homepage>@WEBROOT@</homepage>
    <yearstart>2010</yearstart>
    <yearend>2010</yearend>
  </author>
  <keywords>Commodore PET 6502 65816 cpu replacement board</keywords>
  <metadesc>Commodore PET 65816 CPU replacement board explained</metadesc>
  <overview>
	<p>This page describes the inner workings of the 65816 board,
	what external and internal signals are there and how they work together. Also it
	explains the different parts of the VHDL code.
	</p>
  </overview>
  <!--news>
    <item date="2010-01-04">
	Started this page
    </item>
  </news-->
  <toc/>

  <section toc="gen" name="General">
     <desc>
     </desc>
     <subsection toc="orig" name="Original ROMs ($C000-$FFFF)">
	<desc>
	</desc>
	<extlink name="Original ROMs disassembly" link="@CBMARC@/firmware/computers/pet/d/rom-1.html"/>
     </subsection>
     <subsection toc="orig" name="Original ROMs ($C000-$FFFF)">
	<desc>
	</desc>
	<extlink name="Original ROMs disassembly" link="@CBMARC@/firmware/computers/pet/d/rom-1.html"/>
     </subsection>
     <subsection toc="orig" name="Original ROMs ($C000-$FFFF)">
	<desc>
	</desc>
	<extlink name="Original ROMs disassembly" link="@CBMARC@/firmware/computers/pet/d/rom-1.html"/>
     </subsection>
  </section>

  <section toc="vhdl" name="VHDL Explained...">
     <desc><p>In this section I will describe the main structure of the VHDL code that implements
	the logic in the CPLD. I will also go into ways of efficient testing as I experienced
	while developing the board.</p>
<div class="rightimg">
                <a href="vhdlstruct.svg"><img src="vhdlstruct.png"/></a><br/>VHDL structure
                </div>
	<p>VHDL defines that logic is separated into modules. Each module has input and
		output signals that define the "interface" of the module. In general you can think
		of these modules as being similar to logic ICs. These ICs resp. modules are then
		plugged together in higher level modules, using the input and output signals.
	</p><p>So I have separated the CPLD logic into different modules as well, which I am going
		to explain here. The different modules and their structure is shown in the side image.
	</p>
     </desc>
     <subsection toc="core" name="PET816.vhd">
	<desc><p>
	This module is the top level module. Its input and output lines are the ones that are
	used on the CPLD pins. It does not actually contain any logic. Instead it only passes
	the signals to the Core module. In addition to that it also defines the power-up values
	of the clock and control registers, that are passed to the Core module. 
	</p><p>
	The power-up values for the registers are defined in this module, so that in a debug
	setting I can define different power-up values for the registers without changing the
	Core module.
	</p></desc>
     </subsection>
     <subsection toc="core" name="Core.vhd">
	<desc><p>
	The Core module is the one that holds all the other parts together. Its input and output
	signals are the ones for the CPLD pins, but additionally contains the power-up values for
	the clock and control registers.
	</p><p>
	Internally it wires all the other modules together. Mostly it does this by
	wiring signals from one module to the other. Only a few signals are created in
	the module itself. 
	</p><p>
	The two most important signals generated here are <code>isslow</code>, and <code>isorig</code>.
	The <code>isorig</code> signals goes true when the address selection signals from the 
	SystemMap module (plus some control register values) indicate that the CPU access goes 
	to the slow system bus, using the 6502 bus interface to the base system.
	<code>isslow</code> goes active when a slow system access is detected using the CPU 
	signals - addresses, VPA/VDA (in form of the <code>validaddr</code> signal), R/-W - control
	register bits and more. It is an asynchronous signal that appears when the CPU signals
	fulfill the appropriate conditions. It is then clocked in the ClockSync module.
	</p></desc>
     </subsection>
     <subsection toc="map" name="SystemMap.vhd">
	<desc><p>
	The SystemMap generates signals for the different memory areas. It determines where
	in the memory map the I/O and the video memory areas are. It also determines where the
	mirror RAM (for the lowest 64k) and the system mirror are. This is the only module
	that needs to be replaced for a different type of system (at least in theory).
	</p></desc>
     </subsection>
     <subsection toc="div" name="ClockDivider.vhd">
	<desc><p>
	This module creates the main clock signals. It gets the 50MHz input clock and divides
	the clock signal by 2 (<code>divby2</code>), 
	as well as by the value given from the clock register. 
	The latter signal (<code>masterclk</code>) is then used to generate the 
	actual CPU clock. The clock divider has an enable input that resets the clock signal.
	This is used to restart the fast <code>masterclk</code> with a full phase 1 (phi1 high,
	phi2 low) after a slow access.
	</p></desc>
     </subsection>
     <subsection toc="shift" name="ClockShift.vhd">
	<desc><p>
	The ClockShift module uses the <code>masterclk</code> and <code>divby2</code> signals
	to to delay the slow system clock by defined delay times. The resulting signals 
	<code>phidelayed</code>, <code>phidelayed2</code> and <code>fastr/fastw</code> are used
	to synchronize the CPU with the slow system clock.
	</p></desc>
     </subsection>
     <subsection toc="sync" name="ClockSync.vhd">
	<desc><p>
	This module controls when the CPU is doing a slow memory access (be it orignal system bus, or
	on the board's fast bus - ROM or the SLOWCLK control register bit is set). 
	The <code>slowdetected</code> signal is the <code>isslow</code> signal clocked by the
	rising edge of the CPU clock and signals that the CPU waits for a slow memory access.
	When the correct timing allows to start a slow access, the signal <code>slowaccess</code>
	then enables the slow access cycle. The slow cycle is ended with the <code>startfast</code>
	input - which is generated in the Core module from the <code>fastr/fastw</code> shift 
	module outputs. But <code>startfast</code> is only effective when the system's RDY signal
	allows to end the cycle.
	</p></desc>
     </subsection>
     <subsection toc="div" name="ControlRegister.vhd">
	<desc><p>
	The control register module not only contains the control register, but also the
	clock register. Its input signals contain the power-up init register values, as passed
	from the PET816 module. Its output are the various control register values.
	Unfortunately the registers are only write-only at the moment
	</p></desc>
     </subsection>
     <subsection toc="div" name="BoardMemSel.vhd">
	<desc><p>
	This module creates the select lines for the onboard RAM and ROM ICs, including the 
	ROM's write-enable (for the programming).
	</p></desc>
     </subsection>
  </section>

  <section toc="tests" name="VHDL Testing">
     <desc><p>
	Writing VHDL is one thing, making is work is another thing.	
<div class="rightimg">
                <a href="vhdltest.svg"><img src="vhdltest.png"/></a><br/>VHDL test setup
                </div>
	Here I describe my way of testing the VHDL with VHDL-based simulation.
     </p></desc>
     <subsection toc="testsetup" name="Test Setup">
	<desc><p>
	To be able to test effectively and efficiently you need to take some care and create
	a good setup. The picture on the right shows my test setup. As you can see the 
	Core and its contained modules are exactly the same as in the CPLD setup above.
	The PET816 module is left out though, but that gives the opportunity to pass different,
	test-related power-up values to the registers.
	</p><p>
	The main test setup module is the PET816 Test Bench (TB) module. It simulates the actual 
	system, i.e. it wires together the actual CPLD Core module with a 6502 CPU, some RAM
	and the external test parameter module. In the test bench the hardware of the 
	65816 board is simulated in a basic way. 
	For example the '273 address latches are emulated to simulate the correct system bus 
	address values (and therefore to read the correct data values e.g. from ROM).
	The test bench also contains the clock generators for the internal (50MHz) or system
	bus clock (1MHz or 2MHz depending on config option).
	</p><p>
	The outermost module is the actual test. It contains the test parameters and the test ROMs
	and feeds these values into the actual test bench. Test parameters are the initial
	register values for example. The ROM has a RESET vector, and contains NOP operations as
	default value. Only the code that is needed for the test is put into the emulated ROM.
	This way the only module that is specific to a certain test case is the outermost module
	and is actually implemented as a separate file for each test case.
	</p></desc>
     </subsection>
     <subsection toc="testexec" name="Test Execution">
	<desc><p>
	In my VHDL project setup, which is a Xilinx ISE Webpack project, I have a subdirectory called
	<code>testsuite</code>. In this directory I have created (in further subdirectories) the
	test bench and test case codes. The test bench as well as the free6502 CPU VHDL is in the 
	<code>src</code> subdirectory. The test cases are in the <code>testbench</code> directory.
	</p><p>
	The tests work in a Linux (should work on any Unix) environment and requires the 
	<code>make</code>, <code>ghdl</code> and <code>gtkwave</code> programs installed.
	<code>ghdl</code> is a VHDL simulator based on the GNU Compiler Collection (GCC).
	<code>gtkwave</code> is a viewer to view the output of the <code>ghdl</code> simulation.
	The signal images shown above are made with this tool.
	</p><p>
	Running the tests is done by running
	<pre>
	make ctrl
	</pre>
	or 
	<pre>
	make hbog
	</pre>
	in the testsuite directory, to run the <code>ctrl</code> or <code>hbog</code> test cases 
	respectively.
	</p></desc>
     </subsection>
     <subsection toc="testtiming" name="Test Timing">
	<desc><p>
	On the <code>ctrl</code> test case I ran into a problem when I started to actually
	gate the ROM output with the CPU clock. The CPU latches the data bus values
	at the falling edge of the CPU clock. In the simulation however, the ROM output
	was already set to open before the CPU gated the values, thus it did not work.
	</p><p>
	So here I started to work onto actually simulating delays with VHDL. In the testbench
	I created a new signal
	<pre>
	cpuclk_del &lt;= transport cpuclk after 5 ns;
	</pre>
	This code takes the <code>cpuclk</code> signal and delays it for 5&nbsp;ns. Using
	this delayed clock signal to determine the CPU data input from the ROM output, 
	the VHDL simulation allows the CPU to latch the ROM data when its clock goes low
	and before ROM output goes into tri state:
	<pre>
        if (cpuclk_del = '0') then
             	-- RAM/ROM data switch off time
                core_data_in &lt;= transport "ZZZZZZZZ" after 5 ns;
        else
                if (cpuaddr(15 downto 12) > "1000") then
                        -- ROM access time (from_data is without delay)
                        core_data_in &lt;= reject 10 ns inertial from_data after 70 ns;
                else
                        -- RAM access time (from_data is without delay)
                        core_data_in &lt;= reject 10 ns inertial fram_data_out after 50 ns;
                end if;
        end if;
	</pre>
	In this code there also is a the <code>reject/inertial/after</code> command.
	This construct allows to reject spikes in the signal, here a 10&nbsp;ns spike will
	be ignored (the value after the <code>reject</code>). Then the signal is
	delayed by the time values after the <code>after</code> statement.
	</p><p>
	Please keep in mind that an <code>if</code> has an immediate response, i.e. there is no
	delay or inertial reject involved. If you want to delay the effect of an <code>if</code>
	statement, you have to create a delayed signal that you have to use in the <code>if</code>
	condition as I have done here with the <code>cpuclk_del</code> signal.
	</p><p>
	I have currently done only a very basic simulation. With more test cases (if necessary)
	I expect to get more accurate here and use more of the timing delays. 
	</p><p>
	As far as I understand the transport and inertial delays are ignored when doing the actual
	synthesis, but I haven't tried it so far, though.
	</p></desc>
     </subsection>
  </section>

  <closing>
@FOOTER@
  </closing>
</webpage>
