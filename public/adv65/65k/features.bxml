<!DOCTYPE webpage [ <!ENTITY eacute "&#233; "> <!ENTITY nbsp "&#160;"> ]>
<webpage name="The 65k project - Feature Discussion">
  <author>
    <name>Andr&eacute; Fachat</name> 
    <email>@EMAIL@</email>
    <homepage>@WEBROOT@</homepage>
    <yearstart>2010</yearstart>
    <yearend>2010</yearend>
  </author>
  <keywords>6502 16bit 32bit expansion</keywords>
  <metadesc>6502 16bit 32bit expansion</metadesc>
  <overview><p>	
	This page discusses and defines the features of the <em>65k</em> processor family, thus acts as the
	requirements definition for the new processor.
	</p><p>
	All requirements are based on the original NMOS 6502 processor, using the 
	&quot;legal&quot; opcodes. The 65k should run original NMOS 6502 code without modifications.
	</p><p>
	Goal of these requirements is that they should be:
	</p>
	<ul>
		<li>Implementable - it should be possible to actually implement them...</li>
		<li>Useful - A feature should be reasonably easy to use and provide 
			features that are deemed missing in the 6502</li>
		<li>Simple - apply the KISS principle ("Keep It Simple Sweetheart"), i.e. basically
			try to minimize the lines of code to implement the features.</li>
		<li>Elegant - make an elegant design. This is not really a measurable goal, but a
			goal nevertheless.</li>
	</ul>
  </overview>
  <news>
    <item date="2010-09-18">
	Started this page
    </item>
  </news>
  <toc/>

  <section toc="regexp" name="Register Width Expansion">
     <desc><p>The 6502 has three main registers, <code>AC, XR, YR</code>. These three registers serve
	as accumulator and index registers, and are each 8&nbsp;bit wide.
	Lacking 16&nbsp;bit operations is one of the main issues with the 6502 in modern times.
	So the goal of the register expansion is to provide 16&nbsp;bit registers and arithmetic operations.
     </p></desc>
     <subsection toc="regexp816" name="Register expansion in the 65816">
	<desc><p>
		The 65816 has 16&nbsp;bit registers as well. It expands the existing 8&nbsp;bit registers
		to 16&nbsp;bit using a mode bit. This bit (actually two, one for the AC and one for XR/YR
		is being set by a special instruction. When it is set, the register operations are 
		performed on all 16&nbsp;bit, but using the original opcodes. I.e. an opcode
		<pre>A9 00 : LDA #$00</pre> becomes <pre>A9 00 00 : LDA #$0000</pre> for example.
		</p><p>
		The registers are always used as 16&nbsp;bit. Modifying AC with an 8&nbsp;bit width opcode
		leaves the upper 8&nbsp;bit unchanged. This has strange consequences, when an 8&nbsp;bit
		AC is being transferred into a 16&nbsp;bit XR or YR. The unmodified high byte is transferred
		as well, resulting in a value that maybe was not wanted.
		</p><p>
		This approach has advantages and disadvantages. First of all, the 16&nbsp;bit code can
		be basically as short as the 8&nbsp;bit code (not counting the larger data). 
		On the other hand, switching between 8&nbsp;bit and 16&nbsp;bit operations requires
		an extra instruction. Also it introduces as "hidden state" into the program. A program
		is interpreted differently (and quite differently) depending on a mode bit 
		that is evaluated at runtime. 
		Depending on the mode bit an opcode can have a different length.
		So the assembler program, as well as disassemblers
		(be they code or human)
		always need to know what mode (8 or 16&nbsp;bit) the code is meant for.
		</p><p>
		This situation led me to look for alternatives to get 16&nbsp;bit operations.
		</p>
	</desc>
     </subsection>

     <subsection toc="regexpalt1" name="Alternative 1: New Registers">
	<desc><p>
		The first idea to add 16&nbsp;bit registers to the 6502 is to add new 16&nbsp;bit 
		registers <code>U,V,W</code> that work as 16&nbsp;bit accumulator and index registers.
	</p><p>
		My first naive design approach is in <a href="65k opcodes alternative 1.txt">65k opcodes alternatives 1.txt</a>
	</p><p>
		The approach shown in the file has a number of drawbacks:
	</p>
	<ul>
		<li>It makes the system even more "non-symmetric". The new registers have different capabilities than their
			8&nbsp;bit counterparts. Already on the original 6502, the X and Y registers are not completely symmetric
			and these registers make the situation even worse.</li>
		<li>Each new operation consumes an extra opcode, filling up the opcode space
			quite quickly.</li>
		<li>Linked with the missing symmetry - it might be easier to implement these registers with an own
			complete ALU and internal busses. This would require more logic to implement and thus more chip estate</li>
		<li>It's not elegant, it would violate the design goals from above</li>
	</ul>
	<p>On the other hand they keep the code small and make fetching the code faster.</p>
	</desc>
     </subsection>

     <subsection toc="regexpalt2" name="Alternative 2: Prefix Bytes">
	<desc><p>A Prefix Byte modifies the behaviour of the opcode following the prefix byte. Prefix bytes have a long
		history, they reach back to the Z80 and maybe even further. Also the 6809 used them to expand the opcode space.
		There are two types of prefix bytes:</p>
	<ul>
		<li>Modifier prefix: the following opcode is basically the same as before, but modified for example by using a 
			different number of bits (8&nbsp;bit vs. 16&nbsp;bit) or different registers</li>
		<li>Multi-byte opcodes: a single byte starting a two-byte opcode enables 256 new opcodes in an otherwise 
			single-byte opcode machine. These two-byte opcodes need not have to have anything in common with their
			single-byte counterparts.</li>
	</ul>
		<p>The Z80 for example used both types of prefix bytes.</p>
		<p>To expand the 6502 registers a prefix byte could be used that modifies the existing opcode to use registers
		with an expanded number of bits</p>
	</desc>
	<extlink name="Write Great Code page 280 (Google Books) - about 80x86 prefix bytes" link="http://books.google.de/books?id=tfP4UND566AC&amp;pg=PA280&amp;lpg=PA280&amp;dq=prefix+bytes&amp;source=bl&amp;ots=SmY9zqmD8h&amp;sig=x06ib73uLa0bb5ZYzI1rlrqHAIc&amp;hl=de&amp;ei=md-VTLm5M8vMswby3clk&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=9&amp;ved=0CEgQ6AEwCA"/>
     </subsection>


     <subsection toc="regexpcomp" name="Comparison">
	<desc><p>Here is a comparison of the different approaches to expand the 6502 register width:</p>
	<table border="1">
	<tr><th/><th>Mode bits</th><th>New registers</th><th>Prefix bytes</th></tr>
	<tr><th>Description</th><td>"Hidden state" mode bits switch the existing registers and opcodes between 8 and 16&nbsp;bit</td>
				<td>A new set of 16&nbsp;bit registers with complete new opcodes augment the existing 
					8&nbsp;bit registers and opcodes</td>
				<td>A modifier prefix byte modifies the existing opcodes to use a wider register size</td>
			</tr>
	<tr><th>Program size (and thus fetch speed)</th><td>+ (kept short)</td><td>+ (kept short)</td><td>- (longer for each operation)</td></tr>
	<tr><th>Switching between 8 and 16&nbsp;bit</th><td>- (extra instructions)</td><td>+ (by instruction, no extra cost)</td><td>+ (by instruction, no extra cost)</td></tr>
	<tr><th>Interoperatbility between 8 and 16&nbsp;bit</th><td>+ (same registers)</td><td>- (different registers, need transfer)</td><td>+ (same registers)</td></tr>
	<tr><th>Opcode space usage</th><td>+ (Only single mode switch opcode)</td><td>0 (lots of new opcodes - but could be implemented as multi-byte opcode)</td><td>+ (one modifier prefix would basically suffice)</td></tr>
	<tr><th>Implementation complexity</th><td>+ (single register set, modified opcodes)</td><td>- (new registers, new opcodes)</td><td>+ (single register set, modified opcodes)</td></tr>
	<tr><th>Number of registers</th><td>- (no new registers)</td><td>+ (new set of registers)</td><td>- (no new registers)</td></tr>
	</table>
	</desc>
     </subsection>

     <subsection toc="regexpconcl" name="Conclusion">
	<desc><p>All options basically compare at the same level. The difference is in how I weigh the different options.
	WDC obviously has chosen to go for the small code size route, taking the cost of extra switching opcodes between 8&nbsp;bit and
	16&nbsp;bit operations. 
	</p><p>
	I don't weigh the code size as much. For me it is important to not use hidden state in the CPU as an architectural principle,
	so I weigh the option to switch between 8 and 16&nbsp;bit operation higher. Also that allows me to easily use short 8&nbsp;bit
	code sparsly intermingled with 16&nbsp;bit operations.
	</p><p>
	The option to add new registers and new opcodes requires to add new registers to the processor, requiring more 
	chip estate. These registers are not "symmetric" to the existing ones (different width) and require new opcodes, maybe
	even a new ALU. Although this was my first design approach, this complexity rules it out.
	</p><p class="conclusion">
	The 65k will use <em>modifier prefix bytes</em> to extend the existing registers and opcodes to 16&nbsp;bit width.
	</p></desc>
     </subsection>
  </section>

  <section toc="signext" name="Sign extension handling">
     <subsection toc="signext816" name="65816, 80x86 Sign extension handling">
	<desc><p>In a 65816 all registers are always used as 16&nbsp;bit registers.
	As mentioned above, the 65816 does not modify the high byte of the 16&nbsp;bit AC
	register when modifying the lower 8&nbsp;bit only. This is similar to the behaviour of the
	80x86 architecture, that when computing 8- or 16-bit values no extension happens.
	</p><p>
	This approach is - in case of the 80x86 - also motivated by the fact that historically the 16&nbsp;bit
	registers actually are two 8&nbsp;bit registers combined.
	In the case of the 65816 the AC high byte can be used to "store" extra values that can be swapped
	into AC low byte with the <code>XBA</code> opcode.
	</p><p>
	At least the 80x86 seems to have extra instructions to sign-extend a register.
	</p></desc>
     </subsection>

     <subsection toc="signextauto" name="Automatic Extension">
	<desc><p>Similar to the automatic setting of the status register bits (Z, N for example)
	in the 6502, the processor could automatically extend the sign of an operation.
	This could have advantages when the resulting value is a relative value. It would then
	automatically preserve whether the value is positive or negative.
	</p><p>
	The only operation with relative values is the branch operation. Here the default is 
	8&nbsp;bit - but not even a register value.
	</p></desc>
     </subsection>

     <subsection toc="signextforce0" name="Force Zero">
	<desc><p>
	The 65816 uses a different behaviour for AC and the index registers. The high byte of the
	XR and YR registers is forced to all zeros when 8&nbsp;bit index register operation is selected.
	This allows to use increment/decrement opcodes without caring about the register size.
	</p></desc>
     </subsection>

     <subsection toc="signextconcl" name="Conclusion">
	<desc><p>
	In a "6502 mode" of the 65k, the high byte could always be zero when not using 16&nbsp;bit
	registers at all. 8&nbsp;bit operations would only modify the low 8&nbsp;bits, leaving the others
	to zero.
	Only care would have to be taken to set the high byte to zero when going back
	from 16&nbsp;bit to 8&nbsp;bit operations.
	</p><p>
	A new instruction could be used to clear a register completely - no matter what number of bits
	the register internally has (this should preferably a single-byte opcode to even provide 
	improvement over the original 6502).
	</p><p class="conclusion">
	The 65k will not automatically extend the sign from an 8&nbsp;bit operation to the full
	register width. It will instead provide extension opcodes to extend sign, zeros, or ones.
	It will also provide separate instructions to clear the full register.
	</p></desc>
     </subsection>
  </section>
	
  <section toc="regnum" name="Number of Register">
     <desc><p>The 6502 has three main registers, <code>AC, XR, YR</code>. 
	Compared to other (larger) processors this is a very low number. The 68k for example
	has 8 address and 8 data registers - each 32&nbsp;bit wide. 
	So how can the number of registers be increased?
     </p></desc>
     <subsection toc="regnumset" name="Register Sets">
	<desc><p>Register sets duplicate (or multiply) an existing set of registers with the
		same set of features, and make them
		available via specific exchange instructions. The Z80 for example provides a second set of 
		registers (the <em>'</em> registers) that are supposed to be used by fast interrupt
		routines for example. 
	</p></desc>
     </subsection>
     <subsection toc="regnumzp" name="Zeropage as Registers">
	<desc><p>The 6502 has a specific addressing mode, zeropage, addressing the lowest page
		in memory. The zeropage location is determined
		by the second byte of the opcode. <pre>LDA $12</pre> for example puts the value from
		zeropage location $12 into the accumulator. The zeropage location could be interpreted
		as a register number.
	</p><p>
		Unfortunately even though the zeropage provides 256 bytes, it still is a scarce resource
		and also requires a memory access - which makes it slower than a simple register access.
		The 65816 provides a direct register to move the zeropage to anywhere in bank 0.
	</p></desc>
     </subsection>
     <subsection toc="regnumnew" name="Additional, Separate Registers">
	<desc><p>The processor could simply get new registers in addition to the existing ones.
		In contrast to register sets this would mean new opcodes for operations on these
		new registers.
	</p><p>
		As the 6502 has no means of "numbering" registers, there is no easy means of
		extending the existing operations with new registers. A separate set of
		operations would have to be implemented, a prefix to existing opcodes would not be enough.
	</p></desc>
     </subsection>
     <subsection toc="regnumcomp" name="Comparison">
	<desc><p>Here is a comparison of the different approaches to expand the number of registers:</p>
	<table border="1">
	<tr><th/><th>Register Sets</th><th>Zeropage</th><th>More registers</th></tr>
	<tr><th>Speed</th><td>+ (either prefix, or exchange operation, but no memory access)</td><td>- (zeropage "register number", plus memory access)</td><td>+ (either prefix, or new single byte ops)</td></tr>
	<tr><th>Number of registers</th><td>- (small multiple of 3)</td><td>+ (256 byte resp. 128 word registers)</td><td>- (small) </td></tr>
	<tr><th>Simplicity</th><td>- (new set of operations, prefix, or exchange opcodes)</td><td>+ (already existing opcodes)</td><td>- (new set of operations)</td></tr>
	<tr><th>Interrupt Handling</th><td>- (Need to be explicitely saved - or not used either outside or inside the interrupt)</td><td>+ (no action needed)</td><td>- (Need to be explicitely saved - or not used either outside or inside the interrupt)</td></tr>
	</table>
	</desc>
     </subsection>
     <subsection toc="regnumconcl" name="Conclusion">
	<desc><p>The zeropage alternative actually competes quite well, even though it is an "external" 
	solution and requires memory access.
	</p><p>
	Zeropage register access is actually simple and "known" - the operations already exist in the
	6502.
	</p><p> To speed up the memory access it should be possible to 
	provide a separate zeropage (write-through) cache that does not require memory access 
	(if the processor is faster than memory). A zeropage addressing base register could provide
	a means of easily replacing the "zeropage register set" with another one.
	</p>
	<p class="conclusion">
		The 65k will use zeropage "registers", with zeropage cache where applicable, and a base
		register to move the "zeropage register set".
	</p>
	</desc>
     </subsection>
  </section>

  <section toc="addrexp" name="Address Expansion">
     <desc><p>
	The 6502 has a 16&nbsp;bit address bus. This amounts to a whopping 64&nbsp;kByte of memory.
	Even already the old and famous C64 already had some bank switching schemes to expand the address
	space to more than that. So there is a need to expand the number of address lines available.
	</p><p>
	Also the stack registers and stack size are important here. The 6502 stack is only
	256&nbsp;byte long - and needs to be expanded for larger systems as well.
	</p><p>
	The location of the reset and interrupt vectors also needs to be discussed. 
	If they stay at <code>$FFFC-$FFFF</code>, they would probably be in the middle of the 
	system's RAM instead of ROM. On the other hand RAM is faster than ROM these days.
	</p>
     </desc>

     <subsection toc="addrexp816" name="65816 Address Expansion: Bank Registers">
	<desc><p>The 65816 still has a 16&nbsp;bit program counter register (PC). This
	register is extended by an 8&nbsp;bit Program Bank Register (PBR) to give
	a 24&nbsp;bit physical address.
	</p><p>
	Virtual data addresses are also still 16&nbsp;bit values, and are extended by 
	a Data Bank Register (DBR) to provide a 24&nbsp;bit physical address.
	The program counter can thus not cross bank boundaries, it wraps around from 
	$XXFFFF to $XX0000. Only special instructions that modify the PBR change the
	execution bank.
	</p><p>
	"Direct" addressing modes - formerly known as zeropage addressing - however 	
	is determined by the 16&nbsp;bit Direct register (D) and always results in a 
	physical address in bank 0 ($000000-$00FFFF). Also the stack can only be in 
	bank 0 - its position is determined by the stack high byte register.
	</p><p>
	</p></desc>
     </subsection>

     <subsection toc="addrexpcsa" name="CS/A65 Address Expansion: MMU">
	<desc><p>The <a href="../../csa/index.html">CS/A65</a> computer expands the 6502 CPU
	with an MMU, that maps any of the 16 4k-blocks of virtual (CPU) address space into 
	256 4k-blocks physical address space. The physical address space is 
	1&nbsp;MByte and filled with RAM and ROM. The later versions also include memory management
	features like "no-execute", "write-protect" and "not-mapped" bits.
	This approach is commonly called paging.
	</p><p>The instruction pointer is still always 16&nbsp;bit, as the CPU only sees 16&nbsp;bit
	virtual address space.
	</p><p>Using this MMU requires to load the up to 16 MMU registers during a context switch.
	This can provde costly in a multitasking operating system.
	</p><p>
	Modern systems use a slightly different approach. The program only sets a memory address
	to the MMU, and the MMU then loads the mappings from these memory locations - as needed.
	The loaded "Page Table Entries (PTEs)" are stored in a "Translation Lookaside Buffer (TLB)".
	</p><p>Loading PTEs on demand however, can make opcode timing non-deterministic - when crossing
	an MMU block boundary an extra memory access to read the PTE may be inserted.
	</p></desc>
	<extlink name="Wikipedia on MMU" link="http://en.wikipedia.org/wiki/Memory_management_unit"/>
     </subsection>

     <subsection toc="addrexpbase" name="80x86 - Segmentation">
	<desc><p>The 80x86 architecture since its first 8086 incarnation uses segment registers. In the 
	8088/8086 the segment register was 16&nbsp;bit. Shifted 4 bits to the left was used as base 
	address for a 64k window into the 1&nbsp;MByte physical address space.
	</p><p>Since the 80286 the segment register content points to a descriptor table in memory, 
	that describes the segment. This description includes the - physical - base address, segment
	size (which is being checked), write protection and execute-only protection. 
	</p><p>
	Segmentation has the advantage that it can quickly be changed for example in case of a 
	context switch.
	</p><p>
	Even newer 80x86 also use an MMU and paging in addition to segmentation.
	</p><p>
	The 80x86 can have a 16&nbsp;bit, 32&nbsp;bit or 64&nbsp;bit instruction pointer, depending
	on the mode of operation. The 16&nbsp;bit is extended with a 48&nbsp;bit value to create
	a 64&nbsp;bit virtual address space. The 32&nbsp;bit instruction pointer is zero-extended.
	</p><p>
	"Canonical addressing" means that all unused address bits on the upper end (say address bits
	63 down to 48 when address bits 0-47 form the physical address) are either all zeros or all ones.
	</p></desc>
     </subsection>

     <subsection toc="addrexpvirt" name="Address Virtualization">
	<desc>
	</desc>
     </subsection>
     <subsection toc="addrexpcomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="addrexpconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>

  <section toc="advbus" name="Advanced Bus Features">
     <desc><p>
	The 6502 has a very simple bus interface. Clock, r/-w, address and data lines. The only
	special input signal is <code>RDY</code> that allows to halt the CPU to wait for slow
	memory. <code>SYNC</code> signals the system when an opcode is fetched. 
	</p><p>
	These signals have alread very early be expanded by <code>BE</code> for example. This
	signal decouples the CPU bus (address, data, r/-w) from the system, so that a video
	processor (e.g. the C64 VIC) could take over the bus without extra bus drivers.
	</p>
	<table border="1">
	<tr><th>Signal</th><th>Feature</th><th>Reason</th></tr>
	<tr><td>RDY</td><td>When asserted to the CPU, the cpu waits until it finishes the current
			memory access cylce.</td>
			<td>Used to let the CPU wait for slow memory. Note: for reads only
				on the NMOS6502, for reads and writes on the CMOS versions.</td></tr>
	<tr><td>SYNC</td><td>CPU output. Signals an opcode fetch.</td>
			<td>Can be used to single-step the CPU, or to catch bus errors 
			when an opcode fetch is done on no-execute memory.</td></tr>
	</table><p>
	Other features already implemented in 6502 systems are <code>ABORT</code>, 
	No execute, write protect, and bus error.
	</p><p>
	The signals decided upon here also need to be located either between CPU core and MMU (even if the
	MMU is integrated into the CPU), or between CPU (including MMU) and the system.
     </p></desc>
     <subsection toc="addrexp816" name="65816 Bus Features">
	<desc><p>
		The 65816 has a number of additional signals:
	</p><table border="1">
	<tr><th>Signal</th><th>Feature</th><th>Reason</th></tr>
	<tr><td>ABORT</td><td>When this input signal to the CPU is asserted, the 
			CPU finishes its current opcode, 
			but does not update the register values (including the PC), then
			fetches the ABORT vector similar to an interrupt.</td>
			<td>This is used when an invalid memory location is accessed. The opcode
			is aborted, the CPU can change the memory mapping so that the memory
			location becomes valid, and then rerun the opcode.</td></tr>
	<tr><td>VPA/VDA</td><td>These CPU output signals tell the system whether the current
			cylce is an opcode fetch (VDA+VPA), valid program address (VPA),
			valid data address (VDA) or invalid (none asserted).</td>
			<td>Replaces the SYNC output. Allows to speed up (avoid wait states)
			for invalid cycles when the CPU can run faster than the system.
			May be used for memory mapping.</td></tr>
	<tr><td>/VP</td><td>Asserted by the CPU when an interrupt (IRQ, NMI, RESET, ABORT) vector
			is pulled.</td>
			<td>Can be used to specifically map or dynamically replace interrupt vectors.</td></tr>
	<tr><td>BE</td><td>Bus Enable. Input to decouple address, data and r/-w lines from the system..</td>
			<td>When an external processor (like video) requires memory access, 
			the CPU can be switched off the system bus without further drivers.</td></tr>
	<tr><td>/ML</td><td>Memory Lock. Is asserted by the CPU during the read-modify-write cycles
			of such an opcode (like ROR ABS)</td>
			<td>Locks the memory access to that address for other CPUs.</td></tr>
	<tr><td>M/X</td><td>Outputs the AC and index register mode (8&nbsp;bit vs. 16&nbsp;bit)</td>
			<td>May be used for memory management purposes.</td></tr>
	<tr><td>E</td><td>Outputs the emulation mode (native vs. emulation)</td>
			<td>May be used for memory management purposes.</td></tr>
	</table>
	<p>Of these signals, <code>M/X</code> and <code>E</code> are 65816 specific.
		The signals <code>ABORT, VPA/VDA, /VP, BE</code> and <code>/ML</code> signals are
		candidates for 65k.
	</p></desc>
     </subsection>
     <subsection toc="addrexpcsa" name="CS/A65 Bus Features">
	<desc><p>
		In my <a href="../../csa/index.html">CS/A65</a> system I have implemented some
		other advanced features:</p>
	<table border="1">
	<tr><th>Signal</th><th>Feature</th><th>Reason</th></tr>
	<tr><td>/BE</td><td>Bus Enable. Input to decouple address, data and r/-w lines from the system..</td>
			<td>When an external processor (like video) requires memory access, 
			the CPU can be switched off the system bus without further drivers.</td></tr>
	<tr><td>NOTMAPPED</td><td>The CPU board asserts this signal when a memory location is 
			accessed that is not mapped in the board's MMU. The AUXCPU processor can
			then halt the main CPU (via RDY) and fix the error condition</td>
			<td>This signal detects a bus error condition. The AUXCPU is 
			a kind of replacement for the 65816's ABORT pin.</td></tr>
	<tr><td>WPROT</td><td>The CPU board asserts this signal when a memory location is written to
			that is mapped as read-only in the board's MMU. The AUXCPU processor can
			then halt the main CPU (via RDY) and fix the error condition</td>
			<td>This signal detects a bus error condition. The AUXCPU is 
			a kind of replacement for the 65816's ABORT pin.</td></tr>
	<tr><td>NOEXEC</td><td>The CPU board asserts this signal when an opcode fetch is performed
			on a memory location 
			that is mapped as no-execute in the board's MMU. The AUXCPU processor can
			then halt the main CPU (via RDY) and fix the error condition</td>
			<td>This signal detects a bus error condition. The AUXCPU is 
			a kind of replacement for the 65816's ABORT pin.</td></tr>
	<tr><th colspan="3">&nbsp;</th></tr>
	<tr><td>COPRO</td><td>This board (not signal actually) implements a 6502 co-processor.
			It features a hardware register protected by optimistic locking. This is
			implemented by a hardware load-linked, store-conditional register access.
			</td>
			<td>This feature is implemented to provide safe synchronization between 
			the two processors.</td></tr>
	</table>
	</desc>
     </subsection>
     <subsection toc="addrexpmp" name="Multiprocessor/-core Synchronization">
	<desc><p>
		More modern CPUs provide features to synchronize multiple cores and/or CPUs.
	</p><table border="1">
	<tr><th>Feature</th><th>Description</th><th>Reason</th></tr>
	<tr><td>Test-and-Set opcodes</td><td> This opcode reads a specific memory location,
			and changes that value in an atomic way (i.e. no other CPU can change
			the memory location between the read and write) .</td>
			<td>Used to synchronize multiple CPUs. This is a read-modify-write opcode
			and could be implemented using a memory lock signal.</td></tr>
	<tr><td>Compare-and-Swap opcodes</td><td> This opcode checks that a specific value is in a 
			memory location,
			and only when this is the case, changes that memory location to a new value.</td>
			<td>Used to synchronize multiple CPUs. This is a read-modify-write opcode
			and could be implemented using a memory lock signal.</td></tr>
	<tr><td>Load-Linked/Store-Conditional</td><td> When a memory location is read (load-linked), 
			the CPU monitors
			changes to that location. When the CPU then writes to it (store-conditional)
			the write only succeeds when no modification has been done from other
			CPUs.
			Thus implements a lock-free atomic read-modify-write operation.
			</td>
			<td>Used to synchronize multiple CPUs. Requires bus snooping.</td></tr>
	</table>
	</desc>
     </subsection>
     <subsection toc="addrexpcomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="addrexpconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>

  <section toc="addrmodes" name="Addressing Modes">
     <desc><p>
	The 6502 is lacking some important addressing modes that are needed for</p>
	<ul>
	<li>object-oriented programming</li>
	<li>completely relative programs</li>
	</ul>
     </desc>
     <subsection toc="addrmodes816" name="65816 Address Modes">
	<desc>
	</desc>
	<extlink name="6502 history and future" link="http://homepage.mac.com/jorgechamorro/a2things/PDFs/65xxx.txt"/>
     </subsection>
     <subsection toc="addrmodescomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="addrmodesconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>

  <section toc="opcodes" name="Advanced Opcodes">
     <desc><p>
	- time stamp register
	- LEA
	</p>
     </desc>
     <subsection toc="addrmodes816" name="65816 Address Modes">
	<desc>
	</desc>
	<extlink name="6502 history and future" link="http://homepage.mac.com/jorgechamorro/a2things/PDFs/65xxx.txt"/>
     </subsection>
     <subsection toc="addrmodescomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="addrmodesconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>

  <section toc="opmodes" name="Operating Modes">
     <desc><p>
	"user space"
	"kernal space"
     </p></desc>
     <subsection toc="addrmodes816" name="65816 Address Modes">
	<desc>
	</desc>
	<extlink name="6502 history and future" link="http://homepage.mac.com/jorgechamorro/a2things/PDFs/65xxx.txt"/>
     </subsection>
     <subsection toc="addrmodescomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="addrmodesconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>


  <section toc="memif" name="Memory Interface">
     <desc><p>
	The 6502 has an 8&nbsp;bit wide memory interface. With given clock frequency this limits
	the maximum memory bandwidth. The bandwidth can only be increased by increasing the 
	memory bus width.
	</p><p>
	Additionally a cache can be used to improve the memory bandwidth - by not requiring to read
	some data when it is in the cache already.
	</p>
     </desc>
     <subsection toc="memifwide" name="Wide Memory bus">
	<desc>
	</desc>
     </subsection>
     <subsection toc="memifcache" name="Cache">
	<desc>
	</desc>
     </subsection>
     <subsection toc="memifwrite" name="Write Pipeline">
	<desc>
	</desc>
     </subsection>
     <subsection toc="memifcomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="memifconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>

  <section toc="math" name="Mathematics">
     <desc><p>
	The 6502 only has simple mathematics operations. A multiply would be a great addition,
	but also operations for checksums, or even SIMD (single instruction, multiple data)
	operations.
	</p><p>
	Floating point operations would also be a great addition. 
	</p>
     </desc>
     <subsection toc="memifwide" name="Wide Memory bus">
	<desc>
	</desc>
     </subsection>
     <subsection toc="memifcache" name="Cache">
	<desc>
	</desc>
     </subsection>
     <subsection toc="memifwrite" name="Write Pipeline">
	<desc>
	</desc>
     </subsection>
     <subsection toc="mathcomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="mathconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>

  <section toc="block" name="Vector and Block Operations">
     <desc><p>
	The 65816 already has block move operations.
	</p><p>
	</p>
     </desc>
     <subsection toc="block816" name="65816 MVN/MVP Operations">
	<desc>
	</desc>
     </subsection>
     <subsection toc="blockblitter" name="Blitter Operations">
	<desc>
	</desc>
     </subsection>
     <subsection toc="blockcomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="blockconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>


  <closing>
@FOOTER@
  </closing>
</webpage>
