<!DOCTYPE webpage [ <!ENTITY eacute "&#233; "> <!ENTITY nbsp "&#160;"> ]>
<webpage name="The 65k project - features">
  <author>
    <name>Andr&eacute; Fachat</name> 
    <email>@EMAIL@</email>
    <homepage>@WEBROOT@</homepage>
    <yearstart>2010</yearstart>
    <yearend>2010</yearend>
  </author>
  <keywords>6502 16bit 32bit expansion</keywords>
  <metadesc>6502 16bit 32bit expansion</metadesc>
  <overview><p>	
	This page defines the features of the <em>65k</em> processor family, thus acts as the
	requirements definition for the new processor.
	</p><p>
	All requirements are based on the original NMOS 6502 processor, using the 
	&quot;legal&quot; opcodes. The 65k should run original NMOS 6502 code without modifications.
	</p><p>
	Goal of these requirements is that they should be:
	</p>
	<ul>
		<li>Implementable - it should be possible to actually implement them...</li>
		<li>Useful - A feature should be reasonably easy to use and provide 
			features that are deemed missing in the 6502</li>
		<li>Simple - apply the KISS principle ("Keep It Simple Sweetheart"), i.e. basically
			try to minimize the lines of code to implement the features.</li>
		<li>Elegant - make an elegant design. This is not really a measurable goal, but a
			goal nevertheless.</li>
	</ul>
  </overview>
  <news>
    <item date="2010-09-18">
	Started this page
    </item>
  </news>
  <toc/>

  <section toc="regexp" name="Register Width Expansion">
     <desc><p>The 6502 has three main registers, <code>AC, XR, YR</code>. These three registers serve
	as accumulator and index registers, and are each 8&nbsp;bit wide.
	Lacking 16&nbsp;bit operations is one of the main issues with the 6502 in modern times.
	So the goal of the register expansion is to provide 16&nbsp;bit registers and arithmetic operations.
     </p></desc>
     <subsection toc="regexp816" name="Register expansion in the 65816">
	<desc><p>
		The 65816 has 16&nbsp;bit registers as well. It expands the existing 8&nbsp;bit registers
		to 16&nbsp;bit using a mode bit. This bit (actually two, one for the AC and one for XR/YR
		is being set by a special instruction. When it is set, the register operations are 
		performed on all 16&nbsp;bit, but using the original opcodes. I.e. an opcode
		<pre>A9 00 : LDA #$00</pre> becomes <pre>A9 00 00 : LDA #$0000</pre> for example.
		</p><p>
		This approach has advantages and disadvantages. First of all, the 16&nbsp;bit code can
		be basically as short as the 8&nbsp;bit code (not counting the larger data). 
		On the other hand, switching between 8&nbsp;bit and 16&nbsp;bit operations requires
		an extra instruction. Also it introduces as "hidden state" into the program. A program
		is interpreted differently (and quite differently) depending on a mode bit 
		that is evaluated at runtime. 
		Depending on the mode bit an opcode can have a different length.
		So the assembler program, as well as disassemblers
		(be they code or human)
		always need to know what mode (8 or 16&nbsp;bit) the code is meant for.
		</p><p>
		This situation led me to look for alternatives to get 16&nbsp;bit operations.
		</p>
	</desc>
     </subsection>
     <subsection toc="regexpalt1" name="Alternative 1: New Registers">
	<desc><p>
		The first idea to add 16&nbsp;bit registers to the 6502 is to add new 16&nbsp;bit 
		registers <code>U,V,W</code> that work as 16&nbsp;bit accumulator and index registers.
	</p><p>
		My first naive design approach is in <a href="65k opcodes alternative 1.txt">65k opcodes alternatives 1.txt</a>
	</p><p>
		The approach shown in the file has a number of drawbacks:
	</p>
	<ul>
		<li>It makes the system even more "non-symmetric". The new registers have different capabilities than their
			8&nbsp;bit counterparts. Already on the original 6502, the X and Y registers are not completely symmetric
			and these registers make the situation even worse.</li>
		<li>Each new operation consumes an extra opcode, filling up the opcode space
			quite quickly.</li>
		<li>Linked with the missing symmetry - it might be easier to implement these registers with an own
			complete ALU and internal busses. This would require more logic to implement and thus more chip estate</li>
		<li>It's not elegant, it would violate the design goals from above</li>
	</ul>
	<p>On the other hand they keep the code small and make fetching the code faster.</p>
	</desc>
     </subsection>
     <subsection toc="regexpalt2" name="Alternative 2: Prefix Bytes">
	<desc><p>A Prefix Byte modifies the behaviour of the opcode following the prefix byte. Prefix bytes have a long
		history, they reach back to the Z80 and maybe even further. Also the 6809 used them to expand the opcode space.
		There are two types of prefix bytes:</p>
	<ul>
		<li>Modifier prefix: the following opcode is basically the same as before, but modified for example by using a 
			different number of bits (8&nbsp;bit vs. 16&nbsp;bit) or different registers</li>
		<li>Multi-byte opcodes: a single byte starting a two-byte opcode enables 256 new opcodes in an otherwise 
			single-byte opcode machine. These two-byte opcodes need not have to have anything in common with their
			single-byte counterparts.</li>
	</ul>
		<p>The Z80 for example used both types of prefix bytes.</p>
		<p>To expand the 6502 registers a prefix byte could be used that modifies the existing opcode to use registers
		with an expanded number of bits</p>
	</desc>
	<extlink name="Write Great Code page 280 (Google Books) - about 80x86 prefix bytes" link="http://books.google.de/books?id=tfP4UND566AC&amp;pg=PA280&amp;lpg=PA280&amp;dq=prefix+bytes&amp;source=bl&amp;ots=SmY9zqmD8h&amp;sig=x06ib73uLa0bb5ZYzI1rlrqHAIc&amp;hl=de&amp;ei=md-VTLm5M8vMswby3clk&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=9&amp;ved=0CEgQ6AEwCA"/>
     </subsection>
     <subsection toc="regexpcomp" name="Comparison">
	<desc><p>Here is a comparison of the different approaches to expand the 6502 register width:</p>
	<table border="1">
	<tr><th/><th>Mode bits</th><th>New registers</th><th>Prefix bytes</th></tr>
	<tr><th>Description</th><td>"Hidden state" mode bits switch the existing registers and opcodes between 8 and 16&nbsp;bit</td>
				<td>A new set of 16&nbsp;bit registers with complete new opcodes augment the existing 
					8&nbsp;bit registers and opcodes</td>
				<td>A modifier prefix byte modifies the existing opcodes to use a wider register size</td>
			</tr>
	<tr><th>Program size (and thus fetch speed)</th><td>+ (kept short)</td><td>+ (kept short)</td><td>- (longer for each operation)</td></tr>
	<tr><th>Switching between 8 and 16&nbsp;bit</th><td>- (extra instructions)</td><td>+ (by instruction, no extra cost)</td><td>+ (by instruction, no extra cost)</td></tr>
	<tr><th>Interoperatbility between 8 and 16&nbsp;bit</th><td>+ (same registers)</td><td>- (different registers, need transfer)</td><td>+ (same registers)</td></tr>
	<tr><th>Opcode space usage</th><td>+ (Only single mode switch opcode)</td><td>0 (lots of new opcodes - but could be implemented as multi-byte opcode)</td><td>+ (one modifier prefix would basically suffice)</td></tr>
	<tr><th>Implementation complexity</th><td>+ (single register set, modified opcodes)</td><td>- (new registers, new opcodes)</td><td>+ (single register set, modified opcodes)</td></tr>
	<tr><th>Number of registers</th><td>- (no new registers)</td><td>+ (new set of registers)</td><td>- (no new registers)</td></tr>
	</table>
	</desc>
     </subsection>
     <subsection toc="regexpconcl" name="Conclusion">
	<desc><p>All options basically compare at the same level. The difference is in how I weigh the different options.
	WDC obviously has chosen to go for the small code size route, taking the cost of extra switching opcodes between 8&nbsp;bit and
	16&nbsp;bit operations. 
	</p><p>
	I don't weigh the code size as much. For me it is important to not use hidden state in the CPU as an architectural principle,
	so I weigh the option to switch between 8 and 16&nbsp;bit operation higher. Also that allows me to easily use short 8&nbsp;bit
	code sparsly intermingled with 16&nbsp;bit operations.
	</p><p>
	The option to add new registers and new opcodes requires to add new registers to the processor, requiring more 
	chip estate. These registers are not "symmetric" to the existing ones (different width) and require new opcodes, maybe
	even a new ALU. Although this was my first design approach, this complexity rules it out.
	</p><p class="conclusion">
	The 65k will use <em>modifier prefix bytes</em> to extend the existing registers and opcodes to 16&nbsp;bit width.
	</p></desc>
     </subsection>
  </section>

  <section toc="regnum" name="Number of Register">
     <desc><p>The 6502 has three main registers, <code>AC, XR, YR</code>. 
	Compared to other (larger) processors this is a very low number. The 68k for example
	has 8 address and 8 data registers - each 32&nbsp;bit wide. 
	So how can the number of registers be increased?
     </p></desc>
     <subsection toc="regnumset" name="Register Sets">
	<desc>
	</desc>
     </subsection>
     <subsection toc="regnumzp" name="Zeropage as Registers">
	<desc>
	</desc>
     </subsection>
     <subsection toc="regnumcomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="regnumconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>

  <section toc="addrexp" name="Address Expansion">
     <desc><p>
	The 6502 has a 16&nbsp;bit address bus. This amounts to a whopping 64&nbsp;kByte of memory.
	Even the old and famous C64 already had some bank switching schemes to expand the address
	space to more than that. So there is a need to expand the number of address lines available.
	</p><p>
	Also the stack registers and stack size are important here. The 6502 stack is only
	256&nbsp;byte long - and needs to be expanded for larger systems as well.
	</p><p>
	The location of the reset and interrupt vectors also needs to be discussed. 
	If they stay at <code>$FFFC-$FFFF</code>, they would probably be in the middle of the 
	system's RAM instead of ROM. On the other hand RAM is faster than ROM these days.
	</p>
     </desc>
     <subsection toc="addrexp816" name="65816 Address Expansion: Bank Registers">
	<desc>
	</desc>
     </subsection>
     <subsection toc="addrexpcsa" name="CS/A65 Address Expansion: MMU">
	<desc>
	</desc>
     </subsection>
     <subsection toc="addrexpbase" name="80x86 - Segment Base Registers">
	<desc>
	</desc>
     </subsection>
     <subsection toc="addrexpvirt" name="Address Virtualization">
	<desc>
	</desc>
     </subsection>
     <subsection toc="addrexpcomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="addrexpconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>

  <section toc="advbus" name="Advanced Bus Features">
     <desc><p>
	The 6502 has a very simple bus interface. Clock, r/-w, address and data lines. The only
	special input signal is <code>RDY</code> that allows to halt the CPU to wait for slow
	memory. <code>SYNC</code> signals the system when an opcode is fetched. 
	</p><p>
	These signals have alread very early be expanded by <code>BE</code> for example. This
	signal decouples the CPU bus (address, data, r/-w) from the system, so that a video
	processor (e.g. the C64 VIC) could take over the bus without extra bus drivers.
	</p>
	<table border="1">
	<tr><th>Signal</th><th>Feature</th><th>Reason</th></tr>
	<tr><td>RDY</td><td>When asserted to the CPU, the cpu waits until it finishes the current
			memory access cylce.</td>
			<td>Used to let the CPU wait for slow memory. Note: for reads only
				on the NMOS6502, for reads and writes on the CMOS versions.</td></tr>
	<tr><td>SYNC</td><td>CPU output. Signals an opcode fetch.</td>
			<td>Can be used to single-step the CPU, or to catch bus errors 
			when an opcode fetch is done on no-execute memory.</td></tr>
	</table><p>
	Other features already implemented in 6502 systems are <code>ABORT</code>, 
	No execute, write protect, and bus error.
	</p><p>
	The signals decided upon here also need to be located either between CPU core and MMU (even if the
	MMU is integrated into the CPU), or between CPU (including MMU) and the system.
     </p></desc>
     <subsection toc="addrexp816" name="65816 Bus Features">
	<desc><p>
		The 65816 has a number of additional signals:
	</p><table border="1">
	<tr><th>Signal</th><th>Feature</th><th>Reason</th></tr>
	<tr><td>ABORT</td><td>When this input signal to the CPU is asserted, the 
			CPU finishes its current opcode, 
			but does not update the register values (including the PC), then
			fetches the ABORT vector similar to an interrupt.</td>
			<td>This is used when an invalid memory location is accessed. The opcode
			is aborted, the CPU can change the memory mapping so that the memory
			location becomes valid, and then rerun the opcode.</td></tr>
	<tr><td>VPA/VDA</td><td>These CPU output signals tell the system whether the current
			cylce is an opcode fetch (VDA+VPA), valid program address (VPA),
			valid data address (VDA) or invalid (none asserted).</td>
			<td>Replaces the SYNC output. Allows to speed up (avoid wait states)
			for invalid cycles when the CPU can run faster than the system.
			May be used for memory mapping.</td></tr>
	<tr><td>/VP</td><td>Asserted by the CPU when an interrupt (IRQ, NMI, RESET, ABORT) vector
			is pulled.</td>
			<td>Can be used to specifically map or dynamically replace interrupt vectors.</td></tr>
	<tr><td>BE</td><td>Bus Enable. Input to decouple address, data and r/-w lines from the system..</td>
			<td>When an external processor (like video) requires memory access, 
			the CPU can be switched off the system bus without further drivers.</td></tr>
	<tr><td>/ML</td><td>Memory Lock. Is asserted by the CPU during the read-modify-write cycles
			of such an opcode (like ROR ABS)</td>
			<td>Locks the memory access to that address for other CPUs.</td></tr>
	<tr><td>M/X</td><td>Outputs the AC and index register mode (8&nbsp;bit vs. 16&nbsp;bit)</td>
			<td>May be used for memory management purposes.</td></tr>
	<tr><td>E</td><td>Outputs the emulation mode (native vs. emulation)</td>
			<td>May be used for memory management purposes.</td></tr>
	</table>
	<p>Of these signals, <code>M/X</code> and <code>E</code> are 65816 specific.
		The signals <code>ABORT, VPA/VDA, /VP, BE</code> and <code>/ML</code> signals are
		candidates for 65k.
	</p></desc>
     </subsection>
     <subsection toc="addrexpcsa" name="CS/A65 Bus Features">
	<desc><p>
		In my <a href="../../csa/index.html">CS/A65</a> system I have implemented some
		other advanced features:</p>
	<table border="1">
	<tr><th>Signal</th><th>Feature</th><th>Reason</th></tr>
	<tr><td>/BE</td><td>Bus Enable. Input to decouple address, data and r/-w lines from the system..</td>
			<td>When an external processor (like video) requires memory access, 
			the CPU can be switched off the system bus without further drivers.</td></tr>
	<tr><td>NOTMAPPED</td><td>The CPU board asserts this signal when a memory location is 
			accessed that is not mapped in the board's MMU. The AUXCPU processor can
			then halt the main CPU (via RDY) and fix the error condition</td>
			<td>This signal detects a bus error condition. The AUXCPU is 
			a kind of replacement for the 65816's ABORT pin.</td></tr>
	<tr><td>WPROT</td><td>The CPU board asserts this signal when a memory location is written to
			that is mapped as read-only in the board's MMU. The AUXCPU processor can
			then halt the main CPU (via RDY) and fix the error condition</td>
			<td>This signal detects a bus error condition. The AUXCPU is 
			a kind of replacement for the 65816's ABORT pin.</td></tr>
	<tr><td>NOEXEC</td><td>The CPU board asserts this signal when an opcode fetch is performed
			on a memory location 
			that is mapped as no-execute in the board's MMU. The AUXCPU processor can
			then halt the main CPU (via RDY) and fix the error condition</td>
			<td>This signal detects a bus error condition. The AUXCPU is 
			a kind of replacement for the 65816's ABORT pin.</td></tr>
	<tr><th colspan="3">&nbsp;</th></tr>
	<tr><td>COPRO</td><td>This board (not signal actually) implements a 6502 co-processor.
			It features a hardware register protected by optimistic locking. This is
			implemented by a hardware load-linked, store-conditional register access.
			</td>
			<td>This feature is implemented to provide safe synchronization between 
			the two processors.</td></tr>
	</table>
	</desc>
     </subsection>
     <subsection toc="addrexpmp" name="Multiprocessor/-core Synchronization">
	<desc><p>
		More modern CPUs provide features to synchronize multiple cores and/or CPUs.
	</p><table border="1">
	<tr><th>Feature</th><th>Description</th><th>Reason</th></tr>
	<tr><td>Test-and-Set opcodes</td><td> This opcode reads a specific memory location,
			and changes that value in an atomic way (i.e. no other CPU can change
			the memory location between the read and write) .</td>
			<td>Used to synchronize multiple CPUs. This is a read-modify-write opcode
			and could be implemented using a memory lock signal.</td></tr>
	<tr><td>Compare-and-Swap opcodes</td><td> This opcode checks that a specific value is in a 
			memory location,
			and only when this is the case, changes that memory location to a new value.</td>
			<td>Used to synchronize multiple CPUs. This is a read-modify-write opcode
			and could be implemented using a memory lock signal.</td></tr>
	<tr><td>Load-Linked/Store-Conditional</td><td> When a memory location is read (load-linked), 
			the CPU monitors
			changes to that location. When the CPU then writes to it (store-conditional)
			the write only succeeds when no modification has been done from other
			CPUs.
			Thus implements a lock-free atomic read-modify-write operation.
			</td>
			<td>Used to synchronize multiple CPUs. Requires bus snooping.</td></tr>
	</table>
	</desc>
     </subsection>
     <subsection toc="addrexpcomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="addrexpconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>

  <section toc="addrmodes" name="Addressing Modes">
     <desc><p>
	The 6502 is lacking some important addressing modes that are needed for</p>
	<ul>
	<li>object-oriented programming</li>
	<li>completely relative programs</li>
	</ul>
     </desc>
     <subsection toc="addrmodes816" name="65816 Address Modes">
	<desc>
	</desc>
	<extlink name="6502 history and future" link="http://homepage.mac.com/jorgechamorro/a2things/PDFs/65xxx.txt"/>
     </subsection>
     <subsection toc="addrmodescomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="addrmodesconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>

  <section toc="memif" name="Memory Interface">
     <desc><p>
	The 6502 has an 8&nbsp;bit wide memory interface. With given clock frequency this limits
	the maximum memory bandwidth. The bandwidth can only be increased by increasing the 
	memory bus width.
	</p><p>
	Additionally a cache can be used to improve the memory bandwidth - by not requiring to read
	some data when it is in the cache already.
	</p>
     </desc>
     <subsection toc="memifwide" name="Wide Memory bus">
	<desc>
	</desc>
     </subsection>
     <subsection toc="memifcache" name="Cache">
	<desc>
	</desc>
     </subsection>
     <subsection toc="memifwrite" name="Write Pipeline">
	<desc>
	</desc>
     </subsection>
     <subsection toc="memifcomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="memifconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>

  <section toc="math" name="Mathematics">
     <desc><p>
	The 6502 only has simple mathematics operations. A multiply would be a great addition,
	but also operations for checksums, or even SIMD (single instruction, multiple data)
	operations.
	</p><p>
	Floating point operations would also be a great addition. 
	</p>
     </desc>
     <subsection toc="memifwide" name="Wide Memory bus">
	<desc>
	</desc>
     </subsection>
     <subsection toc="memifcache" name="Cache">
	<desc>
	</desc>
     </subsection>
     <subsection toc="memifwrite" name="Write Pipeline">
	<desc>
	</desc>
     </subsection>
     <subsection toc="mathcomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="mathconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>

  <section toc="block" name="Vector and Block Operations">
     <desc><p>
	The 65816 already has block move operations.
	</p><p>
	</p>
     </desc>
     <subsection toc="block816" name="65816 MVN/MVP Operations">
	<desc>
	</desc>
     </subsection>
     <subsection toc="blockblitter" name="Blitter Operations">
	<desc>
	</desc>
     </subsection>
     <subsection toc="blockcomp" name="Comparison">
	<desc>
	</desc>
     </subsection>
     <subsection toc="blockconcl" name="Conclusion">
	<desc>
	</desc>
     </subsection>
  </section>


  <closing>
@FOOTER@
  </closing>
</webpage>
