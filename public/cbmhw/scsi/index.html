<html><head><base target="_top">
<meta content="AndrÃ©  Fachat" name="author">
<meta content="text/html; charset=iso8859-1" http-equiv="content-type">
<meta content="SCSI controllers for the C64" name="description">
<meta content="C64, SCSI controller" name="keywords">
<title>www.6502.org: SCSI-64: SCSI controller for the C64 and other 6502</title>
<link href="mailto:afachat@gmx.de" rev="made">
<LINK REL="stylesheet" TYPE="text/css" HREF="../../style.css">
</head>
<body>
<DIV ID="menu">
<ul><li class=homepage><a href=../../index.html>Homepage</a></li>
<ul class="menu0" >
<li class="separator">Commodore</li>
<li class="dir"><a href="../../petindex/index.html">CBM PET info</a></li>
<li class="dir"><a href="../../cbmhw/index.html">CBM hardware and mods</a></li>
<ul class="menu1" >
<li class="dir"><a href="../ryofat40/index.html">Build your own new PET!</a></li>
<li class="dir"><a href="../c64csa/index.html">CS/A adapter for C64</a></li>
<li class="dir"><a href="../kernal/index.html">C64 kernal modifications</a></li>
<li class="dir"><a href="../scsi/index.html">CBM SCSI interfaces</a></li>
<ul class="menu2" >
<li class="link"><a href="../../csa/scsi/index.html">CS/A65 SCSI interface</a></li>
</ul>
<li class="dir"><a href="../ieee488/index.html">IEEE488 interfaces</a></li>
</ul>
<li class="separator">Hardware</li>
<li class="dir"><a href="../../csa/index.html">My CS/A65 computer</a></li>
<li class="dir"><a href="../../hwinfo/index.html">Hardware info</a></li>
<li class="separator">Software</li>
<li class="dir"><a href="../../osa/index.html">GeckOS operating system</a></li>
<li class="dir"><a href="../../lib6502/index.html">Lib6502 standard</a></li>
<li class="dir"><a href="../../o65/index.html">O65 file format</a></li>
<li class="dir"><a href="../../misc/index.html">Misc software</a></li>
</ul>
</ul>
</DIV>
<DIV ID="content">
<h1>SCSI-64: SCSI controller for the C64 and other 6502</h1><h2>(C)
1997-2000 Andr&eacute;  Fachat 
&lt;<a href="mailto:afachat@gmx.de">afachat@gmx.de</a>&gt; 
</h2> 
<p>This is the description of several SCSI controllers for the Commodore C64
computer. Some of them may be used with a VIC20 or C128 as well.
All of the controllers are based on one hardware interface that is built
into different setups.
  </p><hr><h3>Description</h3>
<p>
After going a bit into the SCSI standard first I
present the generic interface.
(You can download a slightly older page and all schematics in one archive in
<a href="http://www.zimmers.net/anonftp/pub/cbm/documents/projects/scsi/scsi64-1.tar.gz">scsi64-1.tar.gz</a>. The link to the SCSI standard below is missing).
</p><p>
The driver code is made in a modular way. It consist of the hardware driver
and the partition handler. Both are separated by a well-formed programming
interface, as well as the partition handler presents a nice interface
to the filesystem code. This architecture is presented in the
second part.
</p><p>
The different hardware projects using the generic SCSI interface are described
in the third chapter. Those include a SCSI interface directly for the C64,
as well as disk-drive-like small computers that can be used via the
C64s serial IEC bus.
</p>
    <hr><h4>Disclaimer</h4>
<font size="+1">Before you go on, you should know that all this stuff
comes with <strong>no warranty at all </strong>. Of course this hardware is <strong>not</strong>
to be used in any important or even life-critical systems.
The hardware schematics and software
are provided 'AS IS', WITHOUT WARRANTY of any kind. The entire risk as
to the quality and performance of the hard- and software is with you. Should
the hard- or software prove defective, you assume the cost of all necessary
servicing, repair or correction.</font>
    <hr><h3>Distribution</h3>
<p>This computer system is distributed under the GNU Public License V2.</p>
    <hr><h3>SCSI Standard</h3><p>
SCSI means "Small Computer System Interface". It is an
interface that connectes computers with peripheral devices, like
disks, scanners, CD-ROMs etc. As such it is very flexible.
</p><p>
The first SCSI interfaces were using asynchronous I/O mode. Each
transfered byte was requested and acknowledged with a special
handshake. Nowadays synchronous modes with up to 40 or 80 MByte/s
are supported. Yet, all devices still know the asynchronous mode and
can be used with this interface (at least I did not encounter one, but
I also did not test that many).
</p><p>
The SCSI-II standard defines a number of command sets for a variety
of devices.
Disks are accessed as
"direct access devices", and commands for CD-ROM devices, Printers,
coprocessors etc are defined.
The commands are transferred in a standard way,
which makes the transport level flexible.
And once you know how to send one command, you can easily send
any other. To send a command you can have a look at the software
from this page, that includes SCSI drivers for the 6502.
</p><p>
Unfortunately the SCSI standard cannot be found on the net,
but has to be purchased from the ANSI organization (see
<a href="http://web.ansi.org/">http://web.ansi.org/</a>) or
other sources. A technical or university library might be a place
where you can at least read the standard if they have it.
The SCSI-II standard is refered to as
<em>ANSI X3.131-1990 Small Computer Systems Interface-2 (SCSI-II)</em>.
The SCSI-I standard is X3.131-1986.
</p><p>
<strong>NEW:</strong>You can find anything on the SCSI standard on 
<a href="http://www-128.ibm.com/developerworks/power/library/pa-spec8.html">this IBM developerWorks article</a> by Peter Seebach.
</p><p>
A good source (although a bit hard to read) is the linux kernel source
code. Recommended reading are the comments at the beginning of
<code>drivers/scsi/aha152x.c</code>, the defines in <code>include/scsi/*</code>,
especially the SCSI command opcodes. <code>grep</code>ing for them in the code
will give you an idea
how to use them. One example is the function <code>scan_scsis_single()</code>
in <code>drivers/scsi/scsi.c</code>.
All code references relative to the main source directory, usually under
<code>/usr/src/linux/</code>, of linux kernel version 2.0.36 (although
the linux version should not matter that much here).
</p>
    <hr><h3>Generic 6502 SCSI Interface</h3><p>
The SCSI controller is derived from a very old SASI interface card
published by the german magazin "elektor".
I implemented this interface (heavily modified and modernized) in 1998 as a
<a href="../../csa/scsi/index.html">CS/A65 SCSI board</a>.
</p><p>
The interface is still not at SCSI-II level and it only does basic
asynchronous I/O mode, but nevertheless, it works with my Seagate
ST 1096N (80M) as well as with my IBM Ultra-Wide SCSI-II disk
with 4.3G (I love SCSI for that. Try to add an MFM disk that was still in
use when I bought my Seagate to a PC of today...).
</p><p>
This interface has been designed for the
<a href="../../csa/bus.html">CS/A65 bus system</a>. However, this
bus system basically is the 6502 bus. In fact, besides the <code>/IOSEL</code>
line only 6502 CPU lines are used.<code>/IOSEL</code> selects the I/O area
and is generated from the address lines in the usual way.
This means that the interface can be used on a variety of systems,
and it is used on selfbuilt computers as well as the C64,
as will be seen below. The 6809 has the same bus interface as the 6502,
so it could even be used with this CPU (although no drivers exist for
the 6809).
</p>
    <hr><h3>Software Architecture</h3><p>
The software architecture is kept as flexible as possible.
Three levels work together, the hardware driver, the partition
level that transforms block numbers in a partition into
block numbers in the device, and the third level which is the
filesystem code.
</p><p>
The hardware layer is a low level driver that can detect the
devices connected to the SCSI bus, inquire the device (it returns
the type etc), get the blocksize and read or write single blocks.
As SCSI devices just hold a number of linearly numbered blocks
there is absolutely no need to use any track/sector numbering etc.
In the driver code (see below) the file <code>csascsi1.a65</code>
contains the low level driver for the generic SCSI interface
described above. The file <code>ramdscsi.a65</code> holds a driver
for another interface, that I implemented in the VICE
emulator, not in hardware. You write the block number to some
I/O locations and get the right block memory mapped. This code
shows how easy it is to replace the hardware level if necessary.
</p><p>
The partition level consists of three parts, where only two
are implemented so far.
First in the file <code>part.i65</code>
the format of the partition table is defined.
<code>paccess.a65</code> then translates the block numbers given
to the absolute block numbers on the device using the partition
table. The table is filled in on init by the code in
<code>pcpart.a65</code> that scans the disk for PC-like partition
tables. To use other types of partition tables (like Amiga-type for example),
simply replace this file with a new one that fills in the partition
table appropriately.
The third part would be an <code>fdisk</code> program that uses the low
level routines to manipulate the partition tables. But here I still
rely on the Linux counterpart I already have :-)
</p><p>
The upper level is the filesystem level. It contains code to handle
directories, files, allocation tables etc.
This is not contained in the basic SCSI drivers, because it is
heavily depending on the operating system.
It should be easy to implement any filesystem you like on the level
provided by the partition code.
</p><p>
The most recent SCSI drivers can be found in the <a href="../../osa/index.html">GeckOS/A65 operating
system</a>. An example of a filesystem
implementation can be found in <code>oa-2.0.8/sysapps/fs/fsibm*</code>,
that implement a fileserver task for the GeckOS/A65 operating
system. It handles PC-style disks with the FAT12 or FAT16 filesystem
(no FAT32 and no long filenames). But be warned, it is an early
beta!!! Don't ever try it on a disk that contains anything valuable to you!!!
</p>
    <hr><h3>Hardware projects</h3>Now I will describe the different approaches to use the generic
SCSI interface in a Commodore system, more specifically with a
C64 or C128.
    <ul><li><strong>C64 SCSI (harddisk) adapter</strong><br><br><ul><li><strong>Idea</strong>
	      : 
  	      This interface should directly connect a harddisk to the C64.
The C64 would then have to do all the filesystem handling itself,
but it is fast (no serial IEC bus) and cheap.<br><br></li><li><strong>Description</strong>
	      : 
  	      <p>This is a simple example of how to use the C64-CS/A adapter
with a CS/A65 I/O card.
The <a href="../c64csa/index.html">C64-CS/A adapter</a>
is plugged into the expansion port using one I/O area (at $de** or $df**).
It uses a VIA 6522 to expand the address range so that you can
use the full CS/A bus system with all cards.
</p><p>
The results of the combination with the CS/A-SCSI card
is a simple C64 expansion port card without CS/A bus
interface, in this case in the <font color="#ff0000">C64 SCSI controller</font>.
</p><p>
A picture says more than a thousand words, so here is the C64 SCSI
interface schematics as
<a href="c64scsi/c64scsi.png">c64scsi.png</a> or
<a href="c64scsi/c64scsi.ps.gz">c64scsi.ps.gz</a>.
This is a combination of the CS/A SCSI controller and the
C64 CS/A adapter. However, as only the SCSI controller will be used,
some parts of the combined schematics can be left out (shaded grey),
and only one additional connection has to be made (indicated).
</p>
<p>Matthias Kirchner provided me with an
<a href="http://www.cadsoft.de/">Eagle</a> schematics and board layout
for the C64-SCSI board. However, There is absolutely no warranty with
this schematics and layout, as I could not fully check it.
You can find it in <a href="c64scsi/c64scsi.zip">c64scsi.zip</a>.</p><br><br></li><li><strong>Status</strong>
	      : 
  	      The interface consisting of the C64-CS/A adapter and the CS/A-SCSI
card has been tested on a C64 and works. The "imploded" version
with the left out parts has not been tested.<br><br></li>
</ul></li><br><li><strong>VC-SCSI 1.0 drive</strong><br><br><ul><li><strong>Idea</strong>
	      : 
  	      Provide a separate computer like the VC1541 and interface it with
the C64 via the serial IEC bus. This would keep a lot of work off the
C64, and provide easier access.<br><br></li><li><strong>Description</strong>
	      : 
  	      <p>
This is a combination of the Gecko computer and the SCSI board.
</p><p>
The Gecko (see the <a href="../csa/gecko/index.html">gecko</a> directory) is
a small single-board 6502 computer. The base system provides
32k RAM, 32k ROM and access to the <a href="../csa/bus.html">CS/A I/O bus</a>
(which is the CS/A bus itself, but only using the lower 12 address bits
with <code>/IOSEL</code>). The full Gecko includes an RS232 interface,
as well as a VIA6522 with serial IEC and keyboard interface.
</p><p>
Combining the Gecko with the SCSI interface is simple, just attach it.
If you remove the backplane by putting both cards on the same board
you can also leave out some parts of the Gecko that are of no use.
Those parts are shaded grey in the schematics.
This board can be used with the C64, C128 and VIC20.
</p><p>
The schematics are available as
<a href="vcscsi1/vcscsi-1.0.png">vcscsi-1.0.png</a> or
<a href="vcscsi1/vcscsi-1.0.ps.gz">vcscsi-1.0.ps.gz</a>.
</p><br><br></li><li><strong>Status</strong>
	      : 
  	      The Gecko board and the SCSI interface have been tested separately
and both work. Also the Gecko board works with several other
CS/A cards (my Gecko prototype board developed a bad soldering
so I cannot test it with the SCSI board at this time.).
The SCSI interface has been tested with the orignal CS/A65 computer
and with the C64 using the adapter from above.
This will work with &gt;99.5%.<br><br></li></ul></li><br><li><strong>VC-SCSI 1.x drive</strong><br><br><ul><li><strong>Idea</strong>
	      : 
  	      Modify the Gecko board such that the VIA appears at the same place as
the IEC VIA in the VC1541, and also use the very same IEC schematics
as in the VC1541. This would allow building a VC1541 emulation mode
for all speeders that use the standard FDC routines to acces
a floppy - these routines would then be replaced to access a large file
on the harddrive (a .d64 image basically)<br><br></li><li><strong>Description</strong>
	      : 
  	      <p>
This is basically still the Gecko board. Only the address selection of
the I/O area around IC2 would have to be changed, as well as the
address value at IC9. The VIA would get the very same IEC electronics
as the VC1541 has, removing anything else. The UART (RS232) would be
removed as well.
<br>
The 32k ROM would be divided into an upper 16k part and a lower 16k part.
The upper part would be filled with a modified VC1541 ROM, and the lower
part with the SCSI filesystem code.
<br>
To make the emulation mode reasonably secure part of the RAM - that would
then contain the mapping of VC1541 blocks -&gt; blocks on the disk drive -
should be made write-protectable. This way any floppy speeder going haywire
could with high probability not overwrite other parts of the HD.
</p>
<br><br></li><li><strong>Status</strong>
	      : 
  	      Idea<br><br></li></ul></li><br><li><strong>VC-SCSI 2.0 drive</strong><br><br><ul><li><strong>Idea</strong>
	      : 
  	      When the 6522 is replaced with a 6526 the burst mode of the VC1571 can
be used.<br><br></li><li><strong>Description</strong>
	      : 
  	      <p>
In this schematics I have molded the Gecko and the SCSI
boards more together, without
a bus in between. Also I replaced the 6522 with a 6526. This allows
to use the fast serial IEC bus as used with the C128 (or with a modified
C64). A place for a Speeder Cable is also provided.
</p><p>
Thanks to Nicolas Welte I have improved the parallel speeder cable
support, and provided a way to set the IEC ID.
</p><p>
One word of warning, though: The schematics are preliminary, untested, and
a mess! Again, they are provided AS IS, without warranty!
</p><p>
The schematics are available as
<a href="vcscsi2/vcscsi-2.1C.png">vcscsi-2.1C.png</a> or
<a href="vcscsi2/vcscsi-2.1C.ps.gz">vcscsi-2.1C.ps.gz</a>.
And there is the
<a href="vcscsi2/vcscsi-2.1C-parts.txt">vcscsi-2.1C-parts.txt</a>
parts list.
</p><p>
The memory map has RAM at $0000-$7FFF, ROM at $8000-$DFFF and $E800-$FFFF.
I/O is at $E000-$E7FF, with $E000-$E3FF mirrored at $E400.
$E0** is the 6526, $E1** is the SCSI interface and $E2** is the IEEE488 ID
and speeder flag port.
$E3** is not (yet) used, so there is place for a disk controller or whatever.
</p>
<br><br></li><li><strong>Status</strong>
	      : 
  	      Schematics exist, but they are preliminary, untested, and
a mess! Again, they are provided AS IS, without warranty!<br><br></li></ul></li><br></ul><hr>
  </DIV></body></html>
